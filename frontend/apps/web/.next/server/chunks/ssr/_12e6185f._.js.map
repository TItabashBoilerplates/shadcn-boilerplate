{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/shared/lib/image-blur-svg.ts","turbopack:///[project]/node_modules/next/src/shared/lib/image-config.ts","turbopack:///[project]/node_modules/next/src/shared/lib/get-img-props.ts","turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/contexts/image-config-context.ts","turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/contexts/router-context.ts","turbopack:///[project]/node_modules/next/src/shared/lib/find-closest-quality.ts","turbopack:///[project]/node_modules/next/src/shared/lib/image-loader.ts","turbopack:///[project]/node_modules/next/src/client/use-merged-ref.ts","turbopack:///[project]/node_modules/next/src/client/image-component.tsx","turbopack:///[project]/node_modules/next/src/shared/lib/segment.ts","turbopack:///[project]/node_modules/next/src/client/components/readonly-url-search-params.ts","turbopack:///[project]/node_modules/next/src/client/components/unrecognized-action-error.ts","turbopack:///[project]/node_modules/next/src/client/components/redirect-status-code.ts","turbopack:///[project]/node_modules/next/src/client/components/redirect-error.ts","turbopack:///[project]/node_modules/next/src/client/components/redirect.ts","turbopack:///[project]/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/node_modules/next/src/client/components/not-found.ts","turbopack:///[project]/node_modules/next/src/client/components/forbidden.ts","turbopack:///[project]/node_modules/next/src/client/components/unauthorized.ts","turbopack:///[project]/node_modules/next/src/server/dynamic-rendering-utils.ts","turbopack:///[project]/node_modules/next/src/server/lib/router-utils/is-postpone.ts","turbopack:///[project]/node_modules/next/src/shared/lib/lazy-dynamic/bailout-to-csr.ts","turbopack:///[project]/node_modules/next/src/client/components/is-next-router-error.ts","turbopack:///[project]/node_modules/next/src/client/components/hooks-server-context.ts","turbopack:///[project]/node_modules/next/src/client/components/static-generation-bailout.ts","turbopack:///[project]/node_modules/next/src/lib/framework/boundary-constants.tsx","turbopack:///[project]/node_modules/next/src/lib/scheduler.ts","turbopack:///[project]/node_modules/next/src/shared/lib/invariant-error.ts","turbopack:///[project]/node_modules/next/src/shared/lib/promise-with-resolvers.ts","turbopack:///[project]/node_modules/next/src/server/app-render/staged-rendering.ts","turbopack:///[project]/node_modules/next/src/server/app-render/dynamic-rendering.ts","turbopack:///[project]/node_modules/next/src/client/components/unstable-rethrow.server.ts","turbopack:///[project]/node_modules/next/src/client/components/unstable-rethrow.ts","turbopack:///[project]/node_modules/next/src/client/components/navigation.react-server.ts","turbopack:///[project]/node_modules/next/src/client/components/navigation.ts","turbopack:///[project]/node_modules/next/navigation.js","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/querystring.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/format-url.ts","turbopack:///[project]/node_modules/next/src/shared/lib/utils.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/parse-path.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/add-path-prefix.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/remove-trailing-slash.ts","turbopack:///[project]/node_modules/next/src/client/normalize-trailing-slash.ts","turbopack:///[project]/node_modules/next/src/client/add-base-path.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/html-bots.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/is-bot.ts","turbopack:///[project]/node_modules/next/src/client/components/app-router-utils.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/cache-key.ts","turbopack:///[project]/node_modules/next/src/shared/lib/app-router-types.ts","turbopack:///[project]/node_modules/next/src/client/components/match-segments.ts","turbopack:///[project]/node_modules/next/src/client/components/app-router-headers.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/router-reducer-types.ts","turbopack:///[project]/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/next/src/client/components/use-action-queue.ts","turbopack:///[project]/node_modules/next/src/client/app-call-server.ts","turbopack:///[project]/node_modules/next/src/client/app-find-source-map-url.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment-cache/segment-value-encoding.ts","turbopack:///[project]/node_modules/next/src/client/route-params.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-href-from-url.ts","turbopack:///[project]/node_modules/next/src/client/flight-data-helpers.ts","turbopack:///[project]/node_modules/next/src/client/app-build-id.ts","turbopack:///[project]/node_modules/next/src/shared/lib/hash.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/cache-busting-search-param.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/set-cache-busting-search-param.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/fetch-server-response.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/tuple-map.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/lru.ts","turbopack:///[project]/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/compute-changed-path.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/handle-mutable.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/reducers/navigate-reducer.ts","turbopack:///[project]/node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/cache.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/scheduler.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/prefetch.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/create-router-cache-key.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","turbopack:///[project]/node_modules/next/src/client/components/router-reducer/ppr-navigations.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache-impl/navigation.ts","turbopack:///[project]/node_modules/next/src/client/components/segment-cache.ts","turbopack:///[project]/node_modules/next/src/client/components/links.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/path-has-prefix.ts","turbopack:///[project]/node_modules/next/src/client/has-base-path.ts","turbopack:///[project]/node_modules/next/src/shared/lib/router/utils/is-local-url.ts","turbopack:///[project]/node_modules/next/src/shared/lib/utils/error-once.ts","turbopack:///[project]/node_modules/next/src/client/app-dir/link.tsx","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/react-client/createNavigation.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/routing/config.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/shared/use.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/shared/utils.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/shared/BaseLink.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/shared/utils.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/shared/syncLocaleCookie.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/shared/createSharedNavigationFns.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/navigation/react-client/useBasePathname.js","turbopack:///[project]/node_modules/next-intl/dist/esm/production/routing/defineRouting.js","turbopack:///[project]/apps/web/src/shared/config/i18n/routing.ts","turbopack:///[project]/apps/web/src/shared/lib/i18n/navigation.ts","turbopack:///[project]/apps/web/src/views/home/ui/LanguageSwitcher.tsx"],"sourcesContent":["/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */\nexport function getImageBlurSvg({\n  widthInt,\n  heightInt,\n  blurWidth,\n  blurHeight,\n  blurDataURL,\n  objectFit,\n}: {\n  widthInt?: number\n  heightInt?: number\n  blurWidth?: number\n  blurHeight?: number\n  blurDataURL: string\n  objectFit?: string\n}): string {\n  const std = 20\n  const svgWidth = blurWidth ? blurWidth * 40 : widthInt\n  const svgHeight = blurHeight ? blurHeight * 40 : heightInt\n\n  const viewBox =\n    svgWidth && svgHeight ? `viewBox='0 0 ${svgWidth} ${svgHeight}'` : ''\n  const preserveAspectRatio = viewBox\n    ? 'none'\n    : objectFit === 'contain'\n      ? 'xMidYMid'\n      : objectFit === 'cover'\n        ? 'xMidYMid slice'\n        : 'none'\n\n  return `%3Csvg xmlns='http://www.w3.org/2000/svg' ${viewBox}%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='${std}'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='${preserveAspectRatio}' style='filter: url(%23b);' href='${blurDataURL}'/%3E%3C/svg%3E`\n}\n","export const VALID_LOADERS = [\n  'default',\n  'imgix',\n  'cloudinary',\n  'akamai',\n  'custom',\n] as const\n\nexport type LoaderValue = (typeof VALID_LOADERS)[number]\n\nexport type ImageLoaderProps = {\n  src: string\n  width: number\n  quality?: number\n}\n\nexport type ImageLoaderPropsWithConfig = ImageLoaderProps & {\n  config: Readonly<ImageConfig>\n}\n\nexport type LocalPattern = {\n  /**\n   * Can be literal or wildcard.\n   * Single `*` matches a single path segment.\n   * Double `**` matches any number of path segments.\n   */\n  pathname?: string\n\n  /**\n   * Can be literal query string such as `?v=1` or\n   * empty string meaning no query string.\n   */\n  search?: string\n}\n\nexport type RemotePattern = {\n  /**\n   * Must be `http` or `https`.\n   */\n  protocol?: 'http' | 'https'\n\n  /**\n   * Can be literal or wildcard.\n   * Single `*` matches a single subdomain.\n   * Double `**` matches any number of subdomains.\n   */\n  hostname: string\n\n  /**\n   * Can be literal port such as `8080` or empty string\n   * meaning no port.\n   */\n  port?: string\n\n  /**\n   * Can be literal or wildcard.\n   * Single `*` matches a single path segment.\n   * Double `**` matches any number of path segments.\n   */\n  pathname?: string\n\n  /**\n   * Can be literal query string such as `?v=1` or\n   * empty string meaning no query string.\n   */\n  search?: string\n}\n\ntype ImageFormat = 'image/avif' | 'image/webp'\n\n/**\n * Image configurations\n *\n * @see [Image configuration options](https://nextjs.org/docs/api-reference/next/image#configuration-options)\n */\nexport type ImageConfigComplete = {\n  /** @see [Device sizes documentation](https://nextjs.org/docs/api-reference/next/image#device-sizes) */\n  deviceSizes: number[]\n\n  /** @see [Image sizing documentation](https://nextjs.org/docs/app/building-your-application/optimizing/images#image-sizing) */\n  imageSizes: number[]\n\n  /** @see [Image loaders configuration](https://nextjs.org/docs/api-reference/next/legacy/image#loader) */\n  loader: LoaderValue\n\n  /** @see [Image loader configuration](https://nextjs.org/docs/app/api-reference/components/image#path) */\n  path: string\n\n  /** @see [Image loader configuration](https://nextjs.org/docs/api-reference/next/image#loader-configuration) */\n  loaderFile: string\n\n  /**\n   * @deprecated Use `remotePatterns` instead.\n   */\n  domains: string[]\n\n  /** @see [Disable static image import configuration](https://nextjs.org/docs/api-reference/next/image#disable-static-imports) */\n  disableStaticImages: boolean\n\n  /** @see [Cache behavior](https://nextjs.org/docs/api-reference/next/image#caching-behavior) */\n  minimumCacheTTL: number\n\n  /** @see [Acceptable formats](https://nextjs.org/docs/api-reference/next/image#acceptable-formats) */\n  formats: ImageFormat[]\n\n  /** @see [Maximum Redirects](https://nextjs.org/docs/api-reference/next/image#maximumredirects) */\n  maximumRedirects: number\n\n  /** @see [Dangerously Allow Local IP](https://nextjs.org/docs/api-reference/next/image#dangerously-allow-local-ip) */\n  dangerouslyAllowLocalIP: boolean\n\n  /** @see [Dangerously Allow SVG](https://nextjs.org/docs/api-reference/next/image#dangerously-allow-svg) */\n  dangerouslyAllowSVG: boolean\n\n  /** @see [Content Security Policy](https://nextjs.org/docs/api-reference/next/image#contentsecuritypolicy) */\n  contentSecurityPolicy: string\n\n  /** @see [Content Disposition Type](https://nextjs.org/docs/api-reference/next/image#contentdispositiontype) */\n  contentDispositionType: 'inline' | 'attachment'\n\n  /** @see [Remote Patterns](https://nextjs.org/docs/api-reference/next/image#remotepatterns) */\n  remotePatterns: Array<URL | RemotePattern>\n\n  /** @see [Local Patterns](https://nextjs.org/docs/api-reference/next/image#localPatterns) */\n  localPatterns: LocalPattern[] | undefined\n\n  /** @see [Qualities](https://nextjs.org/docs/api-reference/next/image#qualities) */\n  qualities: number[] | undefined\n\n  /** @see [Unoptimized](https://nextjs.org/docs/api-reference/next/image#unoptimized) */\n  unoptimized: boolean\n}\n\nexport type ImageConfig = Partial<ImageConfigComplete>\n\nexport const imageConfigDefault: ImageConfigComplete = {\n  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  imageSizes: [32, 48, 64, 96, 128, 256, 384],\n  path: '/_next/image',\n  loader: 'default',\n  loaderFile: '',\n  /**\n   * @deprecated Use `remotePatterns` instead to protect your application from malicious users.\n   */\n  domains: [],\n  disableStaticImages: false,\n  minimumCacheTTL: 14400, // 4 hours\n  formats: ['image/webp'],\n  maximumRedirects: 3,\n  dangerouslyAllowLocalIP: false,\n  dangerouslyAllowSVG: false,\n  contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,\n  contentDispositionType: 'attachment',\n  localPatterns: undefined, // default: allow all local images\n  remotePatterns: [], // default: allow no remote images\n  qualities: [75],\n  unoptimized: false,\n}\n","import { warnOnce } from './utils/warn-once'\nimport { getImageBlurSvg } from './image-blur-svg'\nimport { imageConfigDefault } from './image-config'\nimport type {\n  ImageConfigComplete,\n  ImageLoaderProps,\n  ImageLoaderPropsWithConfig,\n} from './image-config'\n\nimport type { CSSProperties, JSX } from 'react'\n\nexport interface StaticImageData {\n  src: string\n  height: number\n  width: number\n  blurDataURL?: string\n  blurWidth?: number\n  blurHeight?: number\n}\n\nexport interface StaticRequire {\n  default: StaticImageData\n}\n\nexport type StaticImport = StaticRequire | StaticImageData\n\nexport type ImageProps = Omit<\n  JSX.IntrinsicElements['img'],\n  'src' | 'srcSet' | 'ref' | 'alt' | 'width' | 'height' | 'loading'\n> & {\n  src: string | StaticImport\n  alt: string\n  width?: number | `${number}`\n  height?: number | `${number}`\n  fill?: boolean\n  loader?: ImageLoader\n  quality?: number | `${number}`\n  preload?: boolean\n  /**\n   * @deprecated Use `preload` prop instead.\n   * See https://nextjs.org/docs/app/api-reference/components/image#preload\n   */\n  priority?: boolean\n  loading?: LoadingValue\n  placeholder?: PlaceholderValue\n  blurDataURL?: string\n  unoptimized?: boolean\n  overrideSrc?: string\n  /**\n   * @deprecated Use `onLoad` instead.\n   * @see https://nextjs.org/docs/app/api-reference/components/image#onload\n   */\n  onLoadingComplete?: OnLoadingComplete\n  /**\n   * @deprecated Use `fill` prop instead of `layout=\"fill\"` or change import to `next/legacy/image`.\n   * @see https://nextjs.org/docs/api-reference/next/legacy/image\n   */\n  layout?: string\n  /**\n   * @deprecated Use `style` prop instead.\n   */\n  objectFit?: string\n  /**\n   * @deprecated Use `style` prop instead.\n   */\n  objectPosition?: string\n  /**\n   * @deprecated This prop does not do anything.\n   */\n  lazyBoundary?: string\n  /**\n   * @deprecated This prop does not do anything.\n   */\n  lazyRoot?: string\n}\n\nexport type ImgProps = Omit<ImageProps, 'src' | 'loader'> & {\n  loading: LoadingValue\n  width: number | undefined\n  height: number | undefined\n  style: NonNullable<JSX.IntrinsicElements['img']['style']>\n  sizes: string | undefined\n  srcSet: string | undefined\n  src: string\n}\n\nconst VALID_LOADING_VALUES = ['lazy', 'eager', undefined] as const\n\n// Object-fit values that are not valid background-size values\nconst INVALID_BACKGROUND_SIZE_VALUES = [\n  '-moz-initial',\n  'fill',\n  'none',\n  'scale-down',\n  undefined,\n]\ntype LoadingValue = (typeof VALID_LOADING_VALUES)[number]\ntype ImageConfig = ImageConfigComplete & {\n  allSizes: number[]\n  output?: 'standalone' | 'export'\n}\n\nexport type ImageLoader = (p: ImageLoaderProps) => string\n\n// Do not export - this is an internal type only\n// because `next.config.js` is only meant for the\n// built-in loaders, not for a custom loader() prop.\ntype ImageLoaderWithConfig = (p: ImageLoaderPropsWithConfig) => string\n\nexport type PlaceholderValue = 'blur' | 'empty' | `data:image/${string}`\nexport type OnLoad = React.ReactEventHandler<HTMLImageElement> | undefined\nexport type OnLoadingComplete = (img: HTMLImageElement) => void\n\nexport type PlaceholderStyle = Partial<\n  Pick<\n    CSSProperties,\n    | 'backgroundSize'\n    | 'backgroundPosition'\n    | 'backgroundRepeat'\n    | 'backgroundImage'\n  >\n>\n\nfunction isStaticRequire(\n  src: StaticRequire | StaticImageData\n): src is StaticRequire {\n  return (src as StaticRequire).default !== undefined\n}\n\nfunction isStaticImageData(\n  src: StaticRequire | StaticImageData\n): src is StaticImageData {\n  return (src as StaticImageData).src !== undefined\n}\n\nfunction isStaticImport(src: string | StaticImport): src is StaticImport {\n  return (\n    !!src &&\n    typeof src === 'object' &&\n    (isStaticRequire(src as StaticImport) ||\n      isStaticImageData(src as StaticImport))\n  )\n}\n\nconst allImgs = new Map<\n  string,\n  { src: string; loading: LoadingValue; placeholder: PlaceholderValue }\n>()\nlet perfObserver: PerformanceObserver | undefined\n\nfunction getInt(x: unknown): number | undefined {\n  if (typeof x === 'undefined') {\n    return x\n  }\n  if (typeof x === 'number') {\n    return Number.isFinite(x) ? x : NaN\n  }\n  if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n    return parseInt(x, 10)\n  }\n  return NaN\n}\n\nfunction getWidths(\n  { deviceSizes, allSizes }: ImageConfig,\n  width: number | undefined,\n  sizes: string | undefined\n): { widths: number[]; kind: 'w' | 'x' } {\n  if (sizes) {\n    // Find all the \"vw\" percent sizes used in the sizes prop\n    const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g\n    const percentSizes = []\n    for (let match; (match = viewportWidthRe.exec(sizes)); match) {\n      percentSizes.push(parseInt(match[2]))\n    }\n    if (percentSizes.length) {\n      const smallestRatio = Math.min(...percentSizes) * 0.01\n      return {\n        widths: allSizes.filter((s) => s >= deviceSizes[0] * smallestRatio),\n        kind: 'w',\n      }\n    }\n    return { widths: allSizes, kind: 'w' }\n  }\n  if (typeof width !== 'number') {\n    return { widths: deviceSizes, kind: 'w' }\n  }\n\n  const widths = [\n    ...new Set(\n      // > This means that most OLED screens that say they are 3x resolution,\n      // > are actually 3x in the green color, but only 1.5x in the red and\n      // > blue colors. Showing a 3x resolution image in the app vs a 2x\n      // > resolution image will be visually the same, though the 3x image\n      // > takes significantly more data. Even true 3x resolution screens are\n      // > wasteful as the human eye cannot see that level of detail without\n      // > something like a magnifying glass.\n      // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n      [width, width * 2 /*, width * 3*/].map(\n        (w) => allSizes.find((p) => p >= w) || allSizes[allSizes.length - 1]\n      )\n    ),\n  ]\n  return { widths, kind: 'x' }\n}\n\ntype GenImgAttrsData = {\n  config: ImageConfig\n  src: string\n  unoptimized: boolean\n  loader: ImageLoaderWithConfig\n  width?: number\n  quality?: number\n  sizes?: string\n}\n\ntype GenImgAttrsResult = {\n  src: string\n  srcSet: string | undefined\n  sizes: string | undefined\n}\n\nfunction generateImgAttrs({\n  config,\n  src,\n  unoptimized,\n  width,\n  quality,\n  sizes,\n  loader,\n}: GenImgAttrsData): GenImgAttrsResult {\n  if (unoptimized) {\n    return { src, srcSet: undefined, sizes: undefined }\n  }\n\n  const { widths, kind } = getWidths(config, width, sizes)\n  const last = widths.length - 1\n\n  return {\n    sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n    srcSet: widths\n      .map(\n        (w, i) =>\n          `${loader({ config, src, quality, width: w })} ${\n            kind === 'w' ? w : i + 1\n          }${kind}`\n      )\n      .join(', '),\n\n    // It's intended to keep `src` the last attribute because React updates\n    // attributes in order. If we keep `src` the first one, Safari will\n    // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n    // updated by React. That causes multiple unnecessary requests if `srcSet`\n    // and `sizes` are defined.\n    // This bug cannot be reproduced in Chrome or Firefox.\n    src: loader({ config, src, quality, width: widths[last] }),\n  }\n}\n\n/**\n * A shared function, used on both client and server, to generate the props for <img>.\n */\nexport function getImgProps(\n  {\n    src,\n    sizes,\n    unoptimized = false,\n    priority = false,\n    preload = false,\n    loading,\n    className,\n    quality,\n    width,\n    height,\n    fill = false,\n    style,\n    overrideSrc,\n    onLoad,\n    onLoadingComplete,\n    placeholder = 'empty',\n    blurDataURL,\n    fetchPriority,\n    decoding = 'async',\n    layout,\n    objectFit,\n    objectPosition,\n    lazyBoundary,\n    lazyRoot,\n    ...rest\n  }: ImageProps,\n  _state: {\n    defaultLoader: ImageLoaderWithConfig\n    imgConf: ImageConfigComplete\n    showAltText?: boolean\n    blurComplete?: boolean\n  }\n): {\n  props: ImgProps\n  meta: {\n    unoptimized: boolean\n    preload: boolean\n    placeholder: NonNullable<ImageProps['placeholder']>\n    fill: boolean\n  }\n} {\n  const { imgConf, showAltText, blurComplete, defaultLoader } = _state\n  let config: ImageConfig\n  let c = imgConf || imageConfigDefault\n  if ('allSizes' in c) {\n    config = c as ImageConfig\n  } else {\n    const allSizes = [...c.deviceSizes, ...c.imageSizes].sort((a, b) => a - b)\n    const deviceSizes = c.deviceSizes.sort((a, b) => a - b)\n    const qualities = c.qualities?.sort((a, b) => a - b)\n    config = { ...c, allSizes, deviceSizes, qualities }\n  }\n\n  if (typeof defaultLoader === 'undefined') {\n    throw new Error(\n      'images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config'\n    )\n  }\n  let loader: ImageLoaderWithConfig = rest.loader || defaultLoader\n\n  // Remove property so it's not spread on <img> element\n  delete rest.loader\n  delete (rest as any).srcSet\n\n  // This special value indicates that the user\n  // didn't define a \"loader\" prop or \"loader\" config.\n  const isDefaultLoader = '__next_img_default' in loader\n\n  if (isDefaultLoader) {\n    if (config.loader === 'custom') {\n      throw new Error(\n        `Image with src \"${src}\" is missing \"loader\" prop.` +\n          `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader`\n      )\n    }\n  } else {\n    // The user defined a \"loader\" prop or config.\n    // Since the config object is internal only, we\n    // must not pass it to the user-defined \"loader\".\n    const customImageLoader = loader as ImageLoader\n    loader = (obj) => {\n      const { config: _, ...opts } = obj\n      return customImageLoader(opts)\n    }\n  }\n\n  if (layout) {\n    if (layout === 'fill') {\n      fill = true\n    }\n    const layoutToStyle: Record<string, Record<string, string> | undefined> = {\n      intrinsic: { maxWidth: '100%', height: 'auto' },\n      responsive: { width: '100%', height: 'auto' },\n    }\n    const layoutToSizes: Record<string, string | undefined> = {\n      responsive: '100vw',\n      fill: '100vw',\n    }\n    const layoutStyle = layoutToStyle[layout]\n    if (layoutStyle) {\n      style = { ...style, ...layoutStyle }\n    }\n    const layoutSizes = layoutToSizes[layout]\n    if (layoutSizes && !sizes) {\n      sizes = layoutSizes\n    }\n  }\n\n  let staticSrc = ''\n  let widthInt = getInt(width)\n  let heightInt = getInt(height)\n  let blurWidth: number | undefined\n  let blurHeight: number | undefined\n  if (isStaticImport(src)) {\n    const staticImageData = isStaticRequire(src) ? src.default : src\n\n    if (!staticImageData.src) {\n      throw new Error(\n        `An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received ${JSON.stringify(\n          staticImageData\n        )}`\n      )\n    }\n    if (!staticImageData.height || !staticImageData.width) {\n      throw new Error(\n        `An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received ${JSON.stringify(\n          staticImageData\n        )}`\n      )\n    }\n\n    blurWidth = staticImageData.blurWidth\n    blurHeight = staticImageData.blurHeight\n    blurDataURL = blurDataURL || staticImageData.blurDataURL\n    staticSrc = staticImageData.src\n\n    if (!fill) {\n      if (!widthInt && !heightInt) {\n        widthInt = staticImageData.width\n        heightInt = staticImageData.height\n      } else if (widthInt && !heightInt) {\n        const ratio = widthInt / staticImageData.width\n        heightInt = Math.round(staticImageData.height * ratio)\n      } else if (!widthInt && heightInt) {\n        const ratio = heightInt / staticImageData.height\n        widthInt = Math.round(staticImageData.width * ratio)\n      }\n    }\n  }\n  src = typeof src === 'string' ? src : staticSrc\n\n  let isLazy =\n    !priority &&\n    !preload &&\n    (loading === 'lazy' || typeof loading === 'undefined')\n  if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n    // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n    unoptimized = true\n    isLazy = false\n  }\n  if (config.unoptimized) {\n    unoptimized = true\n  }\n  if (\n    isDefaultLoader &&\n    !config.dangerouslyAllowSVG &&\n    src.split('?', 1)[0].endsWith('.svg')\n  ) {\n    // Special case to make svg serve as-is to avoid proxying\n    // through the built-in Image Optimization API.\n    unoptimized = true\n  }\n\n  const qualityInt = getInt(quality)\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n      throw new Error(\n        `Image Optimization using the default loader is not compatible with \\`{ output: 'export' }\\`.\n  Possible solutions:\n    - Remove \\`{ output: 'export' }\\` and run \"next start\" to run server mode including the Image Optimization API.\n    - Configure \\`{ images: { unoptimized: true } }\\` in \\`next.config.js\\` to disable the Image Optimization API.\n  Read more: https://nextjs.org/docs/messages/export-image-api`\n      )\n    }\n    if (!src) {\n      // React doesn't show the stack trace and there's\n      // no `src` to help identify which image, so we\n      // instead console.error(ref) during mount.\n      unoptimized = true\n    } else {\n      if (fill) {\n        if (width) {\n          throw new Error(\n            `Image with src \"${src}\" has both \"width\" and \"fill\" properties. Only one should be used.`\n          )\n        }\n        if (height) {\n          throw new Error(\n            `Image with src \"${src}\" has both \"height\" and \"fill\" properties. Only one should be used.`\n          )\n        }\n        if (style?.position && style.position !== 'absolute') {\n          throw new Error(\n            `Image with src \"${src}\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.`\n          )\n        }\n        if (style?.width && style.width !== '100%') {\n          throw new Error(\n            `Image with src \"${src}\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.`\n          )\n        }\n        if (style?.height && style.height !== '100%') {\n          throw new Error(\n            `Image with src \"${src}\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.`\n          )\n        }\n      } else {\n        if (typeof widthInt === 'undefined') {\n          throw new Error(\n            `Image with src \"${src}\" is missing required \"width\" property.`\n          )\n        } else if (isNaN(widthInt)) {\n          throw new Error(\n            `Image with src \"${src}\" has invalid \"width\" property. Expected a numeric value in pixels but received \"${width}\".`\n          )\n        }\n        if (typeof heightInt === 'undefined') {\n          throw new Error(\n            `Image with src \"${src}\" is missing required \"height\" property.`\n          )\n        } else if (isNaN(heightInt)) {\n          throw new Error(\n            `Image with src \"${src}\" has invalid \"height\" property. Expected a numeric value in pixels but received \"${height}\".`\n          )\n        }\n        // eslint-disable-next-line no-control-regex\n        if (/^[\\x00-\\x20]/.test(src)) {\n          throw new Error(\n            `Image with src \"${src}\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.`\n          )\n        }\n        // eslint-disable-next-line no-control-regex\n        if (/[\\x00-\\x20]$/.test(src)) {\n          throw new Error(\n            `Image with src \"${src}\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.`\n          )\n        }\n      }\n    }\n    if (!VALID_LOADING_VALUES.includes(loading)) {\n      throw new Error(\n        `Image with src \"${src}\" has invalid \"loading\" property. Provided \"${loading}\" should be one of ${VALID_LOADING_VALUES.map(\n          String\n        ).join(',')}.`\n      )\n    }\n    if (priority && loading === 'lazy') {\n      throw new Error(\n        `Image with src \"${src}\" has both \"priority\" and \"loading='lazy'\" properties. Only one should be used.`\n      )\n    }\n    if (preload && loading === 'lazy') {\n      throw new Error(\n        `Image with src \"${src}\" has both \"preload\" and \"loading='lazy'\" properties. Only one should be used.`\n      )\n    }\n    if (preload && priority) {\n      throw new Error(\n        `Image with src \"${src}\" has both \"preload\" and \"priority\" properties. Only \"preload\" should be used.`\n      )\n    }\n    if (\n      placeholder !== 'empty' &&\n      placeholder !== 'blur' &&\n      !placeholder.startsWith('data:image/')\n    ) {\n      throw new Error(\n        `Image with src \"${src}\" has invalid \"placeholder\" property \"${placeholder}\".`\n      )\n    }\n    if (placeholder !== 'empty') {\n      if (widthInt && heightInt && widthInt * heightInt < 1600) {\n        warnOnce(\n          `Image with src \"${src}\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.`\n        )\n      }\n    }\n    if (\n      qualityInt &&\n      config.qualities &&\n      !config.qualities.includes(qualityInt)\n    ) {\n      warnOnce(\n        `Image with src \"${src}\" is using quality \"${qualityInt}\" which is not configured in images.qualities [${config.qualities.join(', ')}]. Please update your config to [${[...config.qualities, qualityInt].sort().join(', ')}].` +\n          `\\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-qualities`\n      )\n    }\n    if (placeholder === 'blur' && !blurDataURL) {\n      const VALID_BLUR_EXT = ['jpeg', 'png', 'webp', 'avif'] // should match next-image-loader\n\n      throw new Error(\n        `Image with src \"${src}\" has \"placeholder='blur'\" property but is missing the \"blurDataURL\" property.\n        Possible solutions:\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\n          - Change the \"src\" property to a static import with one of the supported file types: ${VALID_BLUR_EXT.join(\n            ','\n          )} (animated images not supported)\n          - Remove the \"placeholder\" property, effectively no blur effect\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url`\n      )\n    }\n    if ('ref' in rest) {\n      warnOnce(\n        `Image with src \"${src}\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.`\n      )\n    }\n\n    if (!unoptimized && !isDefaultLoader) {\n      const urlStr = loader({\n        config,\n        src,\n        width: widthInt || 400,\n        quality: qualityInt || 75,\n      })\n      let url: URL | undefined\n      try {\n        url = new URL(urlStr)\n      } catch (err) {}\n      if (urlStr === src || (url && url.pathname === src && !url.search)) {\n        warnOnce(\n          `Image with src \"${src}\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.` +\n            `\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width`\n        )\n      }\n    }\n\n    if (onLoadingComplete) {\n      warnOnce(\n        `Image with src \"${src}\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.`\n      )\n    }\n\n    for (const [legacyKey, legacyValue] of Object.entries({\n      layout,\n      objectFit,\n      objectPosition,\n      lazyBoundary,\n      lazyRoot,\n    })) {\n      if (legacyValue) {\n        warnOnce(\n          `Image with src \"${src}\" has legacy prop \"${legacyKey}\". Did you forget to run the codemod?` +\n            `\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13`\n        )\n      }\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      !perfObserver &&\n      window.PerformanceObserver\n    ) {\n      perfObserver = new PerformanceObserver((entryList) => {\n        for (const entry of entryList.getEntries()) {\n          // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n          const imgSrc = entry?.element?.src || ''\n          const lcpImage = allImgs.get(imgSrc)\n          if (\n            lcpImage &&\n            lcpImage.loading === 'lazy' &&\n            lcpImage.placeholder === 'empty' &&\n            !lcpImage.src.startsWith('data:') &&\n            !lcpImage.src.startsWith('blob:')\n          ) {\n            // https://web.dev/lcp/#measure-lcp-in-javascript\n            warnOnce(\n              `Image with src \"${lcpImage.src}\" was detected as the Largest Contentful Paint (LCP). Please add the \\`loading=\"eager\"\\` property if this image is above the fold.` +\n                `\\nRead more: https://nextjs.org/docs/app/api-reference/components/image#loading`\n            )\n          }\n        }\n      })\n      try {\n        perfObserver.observe({\n          type: 'largest-contentful-paint',\n          buffered: true,\n        })\n      } catch (err) {\n        // Log error but don't crash the app\n        console.error(err)\n      }\n    }\n  }\n  const imgStyle = Object.assign(\n    fill\n      ? {\n          position: 'absolute',\n          height: '100%',\n          width: '100%',\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0,\n          objectFit,\n          objectPosition,\n        }\n      : {},\n    showAltText ? {} : { color: 'transparent' },\n    style\n  )\n\n  const backgroundImage =\n    !blurComplete && placeholder !== 'empty'\n      ? placeholder === 'blur'\n        ? `url(\"data:image/svg+xml;charset=utf-8,${getImageBlurSvg({\n            widthInt,\n            heightInt,\n            blurWidth,\n            blurHeight,\n            blurDataURL: blurDataURL || '', // assume not undefined\n            objectFit: imgStyle.objectFit,\n          })}\")`\n        : `url(\"${placeholder}\")` // assume `data:image/`\n      : null\n\n  const backgroundSize = !INVALID_BACKGROUND_SIZE_VALUES.includes(\n    imgStyle.objectFit\n  )\n    ? imgStyle.objectFit\n    : imgStyle.objectFit === 'fill'\n      ? '100% 100%' // the background-size equivalent of `fill`\n      : 'cover'\n\n  let placeholderStyle: PlaceholderStyle = backgroundImage\n    ? {\n        backgroundSize,\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage,\n      }\n    : {}\n\n  if (process.env.NODE_ENV === 'development') {\n    if (\n      placeholderStyle.backgroundImage &&\n      placeholder === 'blur' &&\n      blurDataURL?.startsWith('/')\n    ) {\n      // During `next dev`, we don't want to generate blur placeholders with webpack\n      // because it can delay starting the dev server. Instead, `next-image-loader.js`\n      // will inline a special url to lazily generate the blur placeholder at request time.\n      placeholderStyle.backgroundImage = `url(\"${blurDataURL}\")`\n    }\n  }\n\n  const imgAttributes = generateImgAttrs({\n    config,\n    src,\n    unoptimized,\n    width: widthInt,\n    quality: qualityInt,\n    sizes,\n    loader,\n  })\n\n  const loadingFinal = isLazy ? 'lazy' : loading\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof window !== 'undefined') {\n      let fullUrl: URL\n      try {\n        fullUrl = new URL(imgAttributes.src)\n      } catch (e) {\n        fullUrl = new URL(imgAttributes.src, window.location.href)\n      }\n      allImgs.set(fullUrl.href, { src, loading: loadingFinal, placeholder })\n    }\n  }\n\n  const props: ImgProps = {\n    ...rest,\n    loading: loadingFinal,\n    fetchPriority,\n    width: widthInt,\n    height: heightInt,\n    decoding,\n    className,\n    style: { ...imgStyle, ...placeholderStyle },\n    sizes: imgAttributes.sizes,\n    srcSet: imgAttributes.srcSet,\n    src: overrideSrc || imgAttributes.src,\n  }\n  const meta = { unoptimized, preload: preload || priority, placeholder, fill }\n  return { props, meta }\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].ImageConfigContext\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['contexts'].RouterContext\n","import type { NextConfig } from '../../server/config-shared'\n\n/**\n * Find the closest matching `quality` in the list of `config.qualities`\n * @param quality the quality prop passed to the image component\n * @param config the \"images\" configuration from next.config.js\n * @returns the closest matching quality value\n */\nexport function findClosestQuality(\n  quality: number | undefined,\n  config: NextConfig['images'] | undefined\n): number {\n  const q = quality || 75\n  if (!config?.qualities?.length) {\n    return q\n  }\n  return config.qualities.reduce(\n    (prev, cur) => (Math.abs(cur - q) < Math.abs(prev - q) ? cur : prev),\n    0\n  )\n}\n","import type { ImageLoaderPropsWithConfig } from './image-config'\nimport { findClosestQuality } from './find-closest-quality'\n\nfunction defaultLoader({\n  config,\n  src,\n  width,\n  quality,\n}: ImageLoaderPropsWithConfig): string {\n  if (\n    src.startsWith('/') &&\n    src.includes('?') &&\n    config.localPatterns?.length === 1 &&\n    config.localPatterns[0].pathname === '**' &&\n    config.localPatterns[0].search === ''\n  ) {\n    throw new Error(\n      `Image with src \"${src}\" is using a query string which is not configured in images.localPatterns.` +\n        `\\nRead more: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`\n    )\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    const missingValues = []\n\n    // these should always be provided but make sure they are\n    if (!src) missingValues.push('src')\n    if (!width) missingValues.push('width')\n\n    if (missingValues.length > 0) {\n      throw new Error(\n        `Next Image Optimization requires ${missingValues.join(\n          ', '\n        )} to be provided. Make sure you pass them as props to the \\`next/image\\` component. Received: ${JSON.stringify(\n          { src, width, quality }\n        )}`\n      )\n    }\n\n    if (src.startsWith('//')) {\n      throw new Error(\n        `Failed to parse src \"${src}\" on \\`next/image\\`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)`\n      )\n    }\n\n    if (src.startsWith('/') && config.localPatterns) {\n      if (\n        process.env.NODE_ENV !== 'test' &&\n        // micromatch isn't compatible with edge runtime\n        process.env.NEXT_RUNTIME !== 'edge'\n      ) {\n        // We use dynamic require because this should only error in development\n        const { hasLocalMatch } =\n          require('./match-local-pattern') as typeof import('./match-local-pattern')\n        if (!hasLocalMatch(config.localPatterns, src)) {\n          throw new Error(\n            `Invalid src prop (${src}) on \\`next/image\\` does not match \\`images.localPatterns\\` configured in your \\`next.config.js\\`\\n` +\n              `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns`\n          )\n        }\n      }\n    }\n\n    if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n      let parsedSrc: URL\n      try {\n        parsedSrc = new URL(src)\n      } catch (err) {\n        console.error(err)\n        throw new Error(\n          `Failed to parse src \"${src}\" on \\`next/image\\`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)`\n        )\n      }\n\n      if (\n        process.env.NODE_ENV !== 'test' &&\n        // micromatch isn't compatible with edge runtime\n        process.env.NEXT_RUNTIME !== 'edge'\n      ) {\n        // We use dynamic require because this should only error in development\n        const { hasRemoteMatch } =\n          require('./match-remote-pattern') as typeof import('./match-remote-pattern')\n        if (\n          !hasRemoteMatch(config.domains!, config.remotePatterns!, parsedSrc)\n        ) {\n          throw new Error(\n            `Invalid src prop (${src}) on \\`next/image\\`, hostname \"${parsedSrc.hostname}\" is not configured under images in your \\`next.config.js\\`\\n` +\n              `See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host`\n          )\n        }\n      }\n    }\n  }\n\n  const q = findClosestQuality(quality, config)\n\n  return `${config.path}?url=${encodeURIComponent(src)}&w=${width}&q=${q}${\n    src.startsWith('/_next/static/media/') && process.env.NEXT_DEPLOYMENT_ID\n      ? `&dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n      : ''\n  }`\n}\n\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true\n\nexport default defaultLoader\n","import { useCallback, useRef, type Ref } from 'react'\n\n// This is a compatibility hook to support React 18 and 19 refs.\n// In 19, a cleanup function from refs may be returned.\n// In 18, returning a cleanup function creates a warning.\n// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.\n// This implements cleanup functions with the old behavior in 18.\n// We know refs are always called alternating with `null` and then `T`.\n// So a call with `null` means we need to call the previous cleanup functions.\nexport function useMergedRef<TElement>(\n  refA: Ref<TElement>,\n  refB: Ref<TElement>\n): Ref<TElement> {\n  const cleanupA = useRef<(() => void) | null>(null)\n  const cleanupB = useRef<(() => void) | null>(null)\n\n  // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n  // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n  // But this can cause us to leak a cleanup-ref into user code (previously via `<Link legacyBehavior>`),\n  // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n  // (because it hasn't been updated for React 19)\n  // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n  // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n  return useCallback(\n    (current: TElement | null): void => {\n      if (current === null) {\n        const cleanupFnA = cleanupA.current\n        if (cleanupFnA) {\n          cleanupA.current = null\n          cleanupFnA()\n        }\n        const cleanupFnB = cleanupB.current\n        if (cleanupFnB) {\n          cleanupB.current = null\n          cleanupFnB()\n        }\n      } else {\n        if (refA) {\n          cleanupA.current = applyRef(refA, current)\n        }\n        if (refB) {\n          cleanupB.current = applyRef(refB, current)\n        }\n      }\n    },\n    [refA, refB]\n  )\n}\n\nfunction applyRef<TElement>(\n  refA: NonNullable<Ref<TElement>>,\n  current: TElement\n) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current)\n    if (typeof cleanup === 'function') {\n      return cleanup\n    } else {\n      return () => refA(null)\n    }\n  } else {\n    refA.current = current\n    return () => {\n      refA.current = null\n    }\n  }\n}\n","'use client'\n\nimport React, {\n  useRef,\n  useEffect,\n  useCallback,\n  useContext,\n  useMemo,\n  useState,\n  forwardRef,\n  use,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport Head from '../shared/lib/head'\nimport { getImgProps } from '../shared/lib/get-img-props'\nimport type {\n  ImageProps,\n  ImgProps,\n  OnLoad,\n  OnLoadingComplete,\n  PlaceholderValue,\n} from '../shared/lib/get-img-props'\nimport type {\n  ImageConfigComplete,\n  ImageLoaderProps,\n} from '../shared/lib/image-config'\nimport { imageConfigDefault } from '../shared/lib/image-config'\nimport { ImageConfigContext } from '../shared/lib/image-config-context.shared-runtime'\nimport { warnOnce } from '../shared/lib/utils/warn-once'\nimport { RouterContext } from '../shared/lib/router-context.shared-runtime'\n\n// This is replaced by webpack alias\nimport defaultLoader from 'next/dist/shared/lib/image-loader'\nimport { useMergedRef } from './use-merged-ref'\n\n// This is replaced by webpack define plugin\nconst configEnv = process.env.__NEXT_IMAGE_OPTS as any as ImageConfigComplete\n\nif (typeof window === 'undefined') {\n  ;(globalThis as any).__NEXT_IMAGE_IMPORTED = true\n}\n\nexport type { ImageLoaderProps }\nexport type ImageLoader = (p: ImageLoaderProps) => string\n\ntype ImgElementWithDataProp = HTMLImageElement & {\n  'data-loaded-src': string | undefined\n}\n\ntype ImageElementProps = ImgProps & {\n  unoptimized: boolean\n  placeholder: PlaceholderValue\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>\n  setBlurComplete: (b: boolean) => void\n  setShowAltText: (b: boolean) => void\n  sizesInput: string | undefined\n}\n\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(\n  img: ImgElementWithDataProp,\n  placeholder: PlaceholderValue,\n  onLoadRef: React.MutableRefObject<OnLoad | undefined>,\n  onLoadingCompleteRef: React.MutableRefObject<OnLoadingComplete | undefined>,\n  setBlurComplete: (b: boolean) => void,\n  unoptimized: boolean,\n  sizesInput: string | undefined\n) {\n  const src = img?.src\n  if (!img || img['data-loaded-src'] === src) {\n    return\n  }\n  img['data-loaded-src'] = src\n  const p = 'decode' in img ? img.decode() : Promise.resolve()\n  p.catch(() => {}).then(() => {\n    if (!img.parentElement || !img.isConnected) {\n      // Exit early in case of race condition:\n      // - onload() is called\n      // - decode() is called but incomplete\n      // - unmount is called\n      // - decode() completes\n      return\n    }\n    if (placeholder !== 'empty') {\n      setBlurComplete(true)\n    }\n    if (onLoadRef?.current) {\n      // Since we don't have the SyntheticEvent here,\n      // we must create one with the same shape.\n      // See https://reactjs.org/docs/events.html\n      const event = new Event('load')\n      Object.defineProperty(event, 'target', { writable: false, value: img })\n      let prevented = false\n      let stopped = false\n      onLoadRef.current({\n        ...event,\n        nativeEvent: event,\n        currentTarget: img,\n        target: img,\n        isDefaultPrevented: () => prevented,\n        isPropagationStopped: () => stopped,\n        persist: () => {},\n        preventDefault: () => {\n          prevented = true\n          event.preventDefault()\n        },\n        stopPropagation: () => {\n          stopped = true\n          event.stopPropagation()\n        },\n      })\n    }\n    if (onLoadingCompleteRef?.current) {\n      onLoadingCompleteRef.current(img)\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const origSrc = new URL(src, 'http://n').searchParams.get('url') || src\n      if (img.getAttribute('data-nimg') === 'fill') {\n        if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n          let widthViewportRatio =\n            img.getBoundingClientRect().width / window.innerWidth\n          if (widthViewportRatio < 0.6) {\n            if (sizesInput === '100vw') {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            } else {\n              warnOnce(\n                `Image with src \"${origSrc}\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes`\n              )\n            }\n          }\n        }\n        if (img.parentElement) {\n          const { position } = window.getComputedStyle(img.parentElement)\n          const valid = ['absolute', 'fixed', 'relative']\n          if (!valid.includes(position)) {\n            warnOnce(\n              `Image with src \"${origSrc}\" has \"fill\" and parent element with invalid \"position\". Provided \"${position}\" should be one of ${valid\n                .map(String)\n                .join(',')}.`\n            )\n          }\n        }\n        if (img.height === 0) {\n          warnOnce(\n            `Image with src \"${origSrc}\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.`\n          )\n        }\n      }\n\n      const heightModified =\n        img.height.toString() !== img.getAttribute('height')\n      const widthModified = img.width.toString() !== img.getAttribute('width')\n      if (\n        (heightModified && !widthModified) ||\n        (!heightModified && widthModified)\n      ) {\n        warnOnce(\n          `Image with src \"${origSrc}\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles 'width: \"auto\"' or 'height: \"auto\"' to maintain the aspect ratio.`\n        )\n      }\n    }\n  })\n}\n\nfunction getDynamicProps(\n  fetchPriority?: string\n): Record<string, string | undefined> {\n  if (Boolean(use)) {\n    // In React 19.0.0 or newer, we must use camelCase\n    // prop to avoid \"Warning: Invalid DOM property\".\n    // See https://github.com/facebook/react/pull/25927\n    return { fetchPriority }\n  }\n  // In React 18.2.0 or older, we must use lowercase prop\n  // to avoid \"Warning: Invalid DOM property\".\n  return { fetchpriority: fetchPriority }\n}\n\nconst ImageElement = forwardRef<HTMLImageElement | null, ImageElementProps>(\n  (\n    {\n      src,\n      srcSet,\n      sizes,\n      height,\n      width,\n      decoding,\n      className,\n      style,\n      fetchPriority,\n      placeholder,\n      loading,\n      unoptimized,\n      fill,\n      onLoadRef,\n      onLoadingCompleteRef,\n      setBlurComplete,\n      setShowAltText,\n      sizesInput,\n      onLoad,\n      onError,\n      ...rest\n    },\n    forwardedRef\n  ) => {\n    const ownRef = useCallback(\n      (img: ImgElementWithDataProp | null) => {\n        if (!img) {\n          return\n        }\n        if (onError) {\n          // If the image has an error before react hydrates, then the error is lost.\n          // The workaround is to wait until the image is mounted which is after hydration,\n          // then we set the src again to trigger the error handler (if there was an error).\n          // eslint-disable-next-line no-self-assign\n          img.src = img.src\n        }\n        if (process.env.NODE_ENV !== 'production') {\n          if (!src) {\n            console.error(`Image is missing required \"src\" property:`, img)\n          }\n          if (img.getAttribute('alt') === null) {\n            console.error(\n              `Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.`\n            )\n          }\n        }\n        if (img.complete) {\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }\n      },\n      [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput,\n      ]\n    )\n\n    const ref = useMergedRef(forwardedRef, ownRef)\n\n    return (\n      <img\n        {...rest}\n        {...getDynamicProps(fetchPriority)}\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading={loading}\n        width={width}\n        height={height}\n        decoding={decoding}\n        data-nimg={fill ? 'fill' : '1'}\n        className={className}\n        style={style}\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes={sizes}\n        srcSet={srcSet}\n        src={src}\n        ref={ref}\n        onLoad={(event) => {\n          const img = event.currentTarget as ImgElementWithDataProp\n          handleLoading(\n            img,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            unoptimized,\n            sizesInput\n          )\n        }}\n        onError={(event) => {\n          // if the real image fails to load, this will ensure \"alt\" is visible\n          setShowAltText(true)\n          if (placeholder !== 'empty') {\n            // If the real image fails to load, this will still remove the placeholder.\n            setBlurComplete(true)\n          }\n          if (onError) {\n            onError(event)\n          }\n        }}\n      />\n    )\n  }\n)\n\nfunction ImagePreload({\n  isAppRouter,\n  imgAttributes,\n}: {\n  isAppRouter: boolean\n  imgAttributes: ImgProps\n}) {\n  const opts: ReactDOM.PreloadOptions = {\n    as: 'image',\n    imageSrcSet: imgAttributes.srcSet,\n    imageSizes: imgAttributes.sizes,\n    crossOrigin: imgAttributes.crossOrigin,\n    referrerPolicy: imgAttributes.referrerPolicy,\n    ...getDynamicProps(imgAttributes.fetchPriority),\n  }\n\n  if (isAppRouter && ReactDOM.preload) {\n    ReactDOM.preload(imgAttributes.src, opts)\n    return null\n  }\n\n  return (\n    <Head>\n      <link\n        key={\n          '__nimg-' +\n          imgAttributes.src +\n          imgAttributes.srcSet +\n          imgAttributes.sizes\n        }\n        rel=\"preload\"\n        // Note how we omit the `href` attribute, as it would only be relevant\n        // for browsers that do not support `imagesrcset`, and in those cases\n        // it would cause the incorrect image to be preloaded.\n        //\n        // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n        href={imgAttributes.srcSet ? undefined : imgAttributes.src}\n        {...opts}\n      />\n    </Head>\n  )\n}\n\n/**\n * The `Image` component is used to optimize images.\n *\n * Read more: [Next.js docs: `Image`](https://nextjs.org/docs/app/api-reference/components/image)\n */\nexport const Image = forwardRef<HTMLImageElement | null, ImageProps>(\n  (props, forwardedRef) => {\n    const pagesRouter = useContext(RouterContext)\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter\n\n    const configContext = useContext(ImageConfigContext)\n    const config = useMemo(() => {\n      const c = configEnv || configContext || imageConfigDefault\n\n      const allSizes = [...c.deviceSizes, ...c.imageSizes].sort((a, b) => a - b)\n      const deviceSizes = c.deviceSizes.sort((a, b) => a - b)\n      const qualities = c.qualities?.sort((a, b) => a - b)\n      return {\n        ...c,\n        allSizes,\n        deviceSizes,\n        qualities,\n        // During the SSR, configEnv (__NEXT_IMAGE_OPTS) does not include\n        // security sensitive configs like `localPatterns`, which is needed\n        // during the server render to ensure it's validated. Therefore use\n        // configContext, which holds the config from the server for validation.\n        localPatterns:\n          typeof window === 'undefined'\n            ? configContext?.localPatterns\n            : c.localPatterns,\n      }\n    }, [configContext])\n\n    const { onLoad, onLoadingComplete } = props\n    const onLoadRef = useRef(onLoad)\n\n    useEffect(() => {\n      onLoadRef.current = onLoad\n    }, [onLoad])\n\n    const onLoadingCompleteRef = useRef(onLoadingComplete)\n\n    useEffect(() => {\n      onLoadingCompleteRef.current = onLoadingComplete\n    }, [onLoadingComplete])\n\n    const [blurComplete, setBlurComplete] = useState(false)\n    const [showAltText, setShowAltText] = useState(false)\n    const { props: imgAttributes, meta: imgMeta } = getImgProps(props, {\n      defaultLoader,\n      imgConf: config,\n      blurComplete,\n      showAltText,\n    })\n\n    return (\n      <>\n        {\n          <ImageElement\n            {...imgAttributes}\n            unoptimized={imgMeta.unoptimized}\n            placeholder={imgMeta.placeholder}\n            fill={imgMeta.fill}\n            onLoadRef={onLoadRef}\n            onLoadingCompleteRef={onLoadingCompleteRef}\n            setBlurComplete={setBlurComplete}\n            setShowAltText={setShowAltText}\n            sizesInput={props.sizes}\n            ref={forwardedRef}\n          />\n        }\n        {imgMeta.preload ? (\n          <ImagePreload\n            isAppRouter={isAppRouter}\n            imgAttributes={imgAttributes}\n          />\n        ) : null}\n      </>\n    )\n  }\n)\n","import type { FlightRouterState, Segment } from './app-router-types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport function computeSelectedLayoutSegment(\n  segments: string[] | null,\n  parallelRouteKey: string\n): string | null {\n  if (!segments || segments.length === 0) {\n    return null\n  }\n\n  // For 'children', use first segment; for other parallel routes, use last segment\n  const rawSegment =\n    parallelRouteKey === 'children'\n      ? segments[0]\n      : segments[segments.length - 1]\n\n  // If the default slot is showing, return null since it's not technically \"selected\" (it's a fallback)\n  // Returning an internal value like `__DEFAULT__` would be confusing\n  return rawSegment === DEFAULT_SEGMENT_KEY ? null : rawSegment\n}\n\n/** Get the canonical parameters from the current level to the leaf node. */\nexport function getSelectedLayoutSegmentPath(\n  tree: FlightRouterState,\n  parallelRouteKey: string,\n  first = true,\n  segmentPath: string[] = []\n): string[] {\n  let node: FlightRouterState\n  if (first) {\n    // Use the provided parallel route key on the first parallel route\n    node = tree[1][parallelRouteKey]\n  } else {\n    // After first parallel route prefer children, if there's no children pick the first parallel route.\n    const parallelRoutes = tree[1]\n    node = parallelRoutes.children ?? Object.values(parallelRoutes)[0]\n  }\n\n  if (!node) return segmentPath\n  const segment = node[0]\n\n  let segmentValue = getSegmentValue(segment)\n\n  if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) {\n    return segmentPath\n  }\n\n  segmentPath.push(segmentValue)\n\n  return getSelectedLayoutSegmentPath(\n    node,\n    parallelRouteKey,\n    false,\n    segmentPath\n  )\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","/**\n * ReadonlyURLSearchParams implementation shared between client and server.\n * This file is intentionally not marked as 'use client' or 'use server'\n * so it can be imported by both environments.\n */\n\n/** @internal */\nclass ReadonlyURLSearchParamsError extends Error {\n  constructor() {\n    super(\n      'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'\n    )\n  }\n}\n\n/**\n * A read-only version of URLSearchParams that throws errors when mutation methods are called.\n * This ensures that the URLSearchParams returned by useSearchParams() cannot be mutated.\n */\nexport class ReadonlyURLSearchParams extends URLSearchParams {\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  append() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  delete() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  set() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n  /** @deprecated Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */\n  sort() {\n    throw new ReadonlyURLSearchParamsError()\n  }\n}\n","export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import { RedirectStatusCode } from './redirect-status-code'\nimport {\n  RedirectType,\n  type RedirectError,\n  isRedirectError,\n  REDIRECT_ERROR_CODE,\n} from './redirect-error'\n\nconst actionAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/action-async-storage.external') as typeof import('../../server/app-render/action-async-storage.external')\n      ).actionAsyncStorage\n    : undefined\n\nexport function getRedirectError(\n  url: string,\n  type: RedirectType,\n  statusCode: RedirectStatusCode = RedirectStatusCode.TemporaryRedirect\n): RedirectError {\n  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError\n  error.digest = `${REDIRECT_ERROR_CODE};${type};${url};${statusCode};`\n  return error\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 307/303 to the caller.\n * - In a Server Action, type defaults to 'push' and 'replace' elsewhere.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function redirect(\n  /** The URL to redirect to */\n  url: string,\n  type?: RedirectType\n): never {\n  type ??= actionAsyncStorage?.getStore()?.isAction\n    ? RedirectType.push\n    : RedirectType.replace\n\n  throw getRedirectError(url, type, RedirectStatusCode.TemporaryRedirect)\n}\n\n/**\n * This function allows you to redirect the user to another URL. It can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a meta tag to redirect the user to the target page.\n * - In a Route Handler or Server Action, it will serve a 308/303 to the caller.\n *\n * Read more: [Next.js Docs: `redirect`](https://nextjs.org/docs/app/api-reference/functions/redirect)\n */\nexport function permanentRedirect(\n  /** The URL to redirect to */\n  url: string,\n  type: RedirectType = RedirectType.replace\n): never {\n  throw getRedirectError(url, type, RedirectStatusCode.PermanentRedirect)\n}\n\n/**\n * Returns the encoded URL from the error if it's a RedirectError, null\n * otherwise. Note that this does not validate the URL returned.\n *\n * @param error the error that may be a redirect error\n * @return the url if the error was a redirect error\n */\nexport function getURLFromRedirectError(error: RedirectError): string\nexport function getURLFromRedirectError(error: unknown): string | null {\n  if (!isRedirectError(error)) return null\n\n  // Slices off the beginning of the digest that contains the code and the\n  // separating ';'.\n  return error.digest.split(';').slice(2, -2).join(';')\n}\n\nexport function getRedirectTypeFromError(error: RedirectError): RedirectType {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return error.digest.split(';', 2)[1] as RedirectType\n}\n\nexport function getRedirectStatusCodeFromError(error: RedirectError): number {\n  if (!isRedirectError(error)) {\n    throw new Error('Not a redirect error')\n  }\n\n  return Number(error.digest.split(';').at(-2))\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n/**\n * This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)\n * within a route segment as well as inject a tag.\n *\n * `notFound()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * - In a Server Component, this will insert a `<meta name=\"robots\" content=\"noindex\" />` meta tag and set the status code to 404.\n * - In a Route Handler or Server Action, it will serve a 404 to the caller.\n *\n * Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};404`\n\nexport function notFound(): never {\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import type { NonStaticRenderStage } from './app-render/staged-rendering'\nimport type { RequestStore } from './app-render/work-unit-async-storage.external'\n\nexport function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(\n    public readonly route: string,\n    public readonly expression: string\n  ) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route \"${route}\".`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for cacheComponents where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  route: string,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(route, expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(route, expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n\nexport function makeDevtoolsIOAwarePromise<T>(\n  underlying: T,\n  requestStore: RequestStore,\n  stage: NonStaticRenderStage\n): Promise<T> {\n  if (requestStore.stagedRendering) {\n    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n    return requestStore.stagedRendering.delayUntilStage(\n      stage,\n      undefined,\n      underlying\n    )\n  }\n  // in React DevTools if we resolve in a setTimeout we will observe\n  // the promise resolution as something that can suspend a boundary or root.\n  return new Promise<T>((resolve) => {\n    // Must use setTimeout to be considered IO React DevTools. setImmediate will not work.\n    setTimeout(() => {\n      resolve(underlying)\n    }, 0)\n  })\n}\n","const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone')\n\nexport function isPostpone(error: any): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  )\n}\n","// This has to be a shared module which is shared between client component error boundary and dynamic component\nconst BAILOUT_TO_CSR = 'BAILOUT_TO_CLIENT_SIDE_RENDERING'\n\n/** An error that should be thrown when we want to bail out to client-side rendering. */\nexport class BailoutToCSRError extends Error {\n  public readonly digest = BAILOUT_TO_CSR\n\n  constructor(public readonly reason: string) {\n    super(`Bail out to client-side rendering: ${reason}`)\n  }\n}\n\n/** Checks if a passed argument is an error that is thrown if we want to bail out to client-side rendering. */\nexport function isBailoutToCSRError(err: unknown): err is BailoutToCSRError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === BAILOUT_TO_CSR\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n","const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n","export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\nexport const ROOT_LAYOUT_BOUNDARY_NAME = '__next_root_layout_boundary__'\n","export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = (cb: ScheduledFn<void>) => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = (cb: ScheduledFn<void>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n","export class InvariantError extends Error {\n  constructor(message: string, options?: ErrorOptions) {\n    super(\n      `Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,\n      options\n    )\n    this.name = 'InvariantError'\n  }\n}\n","export function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n\nexport enum RenderStage {\n  Static = 1,\n  Runtime = 2,\n  Dynamic = 3,\n}\n\nexport type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n\nexport class StagedRenderingController {\n  currentStage: RenderStage = RenderStage.Static\n\n  private runtimeStagePromise = createPromiseWithResolvers<void>()\n  private dynamicStagePromise = createPromiseWithResolvers<void>()\n\n  constructor(private abortSignal: AbortSignal | null = null) {\n    if (abortSignal) {\n      abortSignal.addEventListener(\n        'abort',\n        () => {\n          const { reason } = abortSignal\n          if (this.currentStage < RenderStage.Runtime) {\n            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.runtimeStagePromise.reject(reason)\n          }\n          if (this.currentStage < RenderStage.Dynamic) {\n            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n            this.dynamicStagePromise.reject(reason)\n          }\n        },\n        { once: true }\n      )\n    }\n  }\n\n  advanceStage(stage: NonStaticRenderStage) {\n    // If we're already at the target stage or beyond, do nothing.\n    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n    if (this.currentStage >= stage) {\n      return\n    }\n    this.currentStage = stage\n    // Note that we might be going directly from Static to Dynamic,\n    // so we need to resolve the runtime stage as well.\n    if (stage >= RenderStage.Runtime) {\n      this.runtimeStagePromise.resolve()\n    }\n    if (stage >= RenderStage.Dynamic) {\n      this.dynamicStagePromise.resolve()\n    }\n  }\n\n  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n    switch (stage) {\n      case RenderStage.Runtime: {\n        return this.runtimeStagePromise.promise\n      }\n      case RenderStage.Dynamic: {\n        return this.dynamicStagePromise.promise\n      }\n      default: {\n        stage satisfies never\n        throw new InvariantError(`Invalid render stage: ${stage}`)\n      }\n    }\n  }\n\n  waitForStage(stage: NonStaticRenderStage) {\n    return this.getStagePromise(stage)\n  }\n\n  delayUntilStage<T>(\n    stage: NonStaticRenderStage,\n    displayName: string | undefined,\n    resolvedValue: T\n  ) {\n    const ioTriggerPromise = this.getStagePromise(stage)\n\n    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n      ioTriggerPromise,\n      displayName,\n      resolvedValue\n    )\n\n    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n    if (this.abortSignal) {\n      promise.catch(ignoreReject)\n    }\n    return promise\n  }\n}\n\nfunction ignoreReject() {}\n\n// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n// is confusing, we should clean it up.\nfunction makeDevtoolsIOPromiseFromIOTrigger<T>(\n  ioTrigger: Promise<any>,\n  displayName: string | undefined,\n  resolvedValue: T\n): Promise<T> {\n  // If we create a `new Promise` and give it a displayName\n  // (with no userspace code above us in the stack)\n  // React Devtools will use it as the IO cause when determining \"suspended by\".\n  // In particular, it should shadow any inner IO that resolved/rejected the promise\n  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n  const promise = new Promise<T>((resolve, reject) => {\n    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n  })\n  if (displayName !== undefined) {\n    // @ts-expect-error\n    promise.displayName = displayName\n  }\n  return promise\n}\n","/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n  PrerenderStoreModernRuntime,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport {\n  getRuntimeStagePromise,\n  throwForMissingRequestStore,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n  ROOT_LAYOUT_BOUNDARY_NAME,\n} from '../../lib/framework/boundary-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { RenderStage } from './staged-rendering'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicErrorWithStack: null | Error\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspenseAboveBody: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasAllowedDynamic: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspenseAboveBody: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasAllowedDynamic: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n        // Inside cache scopes, marking a scope as dynamic has no effect,\n        // because the outer cache scope creates a cache boundary. This is\n        // subtly different from reading a dynamic data source, which is\n        // forbidden inside a cache scope.\n        return\n      case 'private-cache':\n        // A private cache scope is already dynamic by definition.\n        return\n      case 'prerender-legacy':\n      case 'prerender-ppr':\n      case 'request':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        // We aren't prerendering, but we are generating a static page. We need\n        // to bail out of static generation.\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\n/**\n * This function is meant to be used when prerendering without cacheComponents or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n  switch (workUnitStore.type) {\n    case 'cache':\n    case 'unstable-cache':\n      // Inside cache scopes, marking a scope as dynamic has no effect,\n      // because the outer cache scope creates a cache boundary. This is\n      // subtly different from reading a dynamic data source, which is\n      // forbidden inside a cache scope.\n      return\n    case 'private-cache':\n      // A private cache scope is already dynamic by definition.\n      return\n    case 'prerender':\n    case 'prerender-runtime':\n    case 'prerender-legacy':\n    case 'prerender-ppr':\n    case 'prerender-client':\n      break\n    case 'request':\n      if (process.env.NODE_ENV !== 'production') {\n        workUnitStore.usedDynamic = true\n      }\n      break\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  // It is important that we set this tracking value after aborting. Aborts are executed\n  // synchronously except for the case where you abort during render itself. By setting this\n  // value late we can use it to determine if any of the aborted tasks are the task that\n  // called the sync IO expression in the first place.\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of the prerender stage\n  if (requestStore.stagedRendering) {\n    // TODO: error for sync IO in the runtime stage\n    // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n    requestStore.stagedRendering.advanceStage(RenderStage.Dynamic)\n  }\n}\n\n/**\n * use this function when prerendering with cacheComponents. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in cacheComponents mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n    // It is important that we set this tracking value after aborting. Aborts are executed\n    // synchronously except for the case where you abort during render itself. By setting this\n    // value late we can use it to determine if any of the aborted tasks are the task that\n    // called the sync IO expression in the first place.\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n      }\n    }\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createRenderInBrowserAbortSignal(): AbortSignal {\n  const controller = new AbortController()\n  controller.abort(new BailoutToCSRError('Render in Browser'))\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: WorkUnitStore\n): AbortSignal | undefined {\n  switch (workUnitStore.type) {\n    case 'prerender':\n    case 'prerender-runtime':\n      const controller = new AbortController()\n\n      if (workUnitStore.cacheSignal) {\n        // If we have a cacheSignal it means we're in a prospective render. If\n        // the input we're waiting on is coming from another cache, we do want\n        // to wait for it so that we can resolve this cache entry too.\n        workUnitStore.cacheSignal.inputReady().then(() => {\n          controller.abort()\n        })\n      } else {\n        // Otherwise we're in the final render and we should already have all\n        // our caches filled.\n        // If the prerender uses stages, we have wait until the runtime stage,\n        // at which point all runtime inputs will be resolved.\n        // (otherwise, a runtime prerender might consider `cookies()` hanging\n        //  even though they'd resolve in the next task.)\n        //\n        // We might still be waiting on some microtasks so we\n        // wait one tick before giving up. When we give up, we still want to\n        // render the content of this cache as deeply as we can so that we can\n        // suspend as deeply as possible in the tree or not at all if we don't\n        // end up waiting for the input.\n        const runtimeStagePromise = getRuntimeStagePromise(workUnitStore)\n        if (runtimeStagePromise) {\n          runtimeStagePromise.then(() =>\n            scheduleOnNextTick(() => controller.abort())\n          )\n        } else {\n          scheduleOnNextTick(() => controller.abort())\n        }\n      }\n\n      return controller.signal\n    case 'prerender-client':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return undefined\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workStore && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender-client':\n      case 'prerender': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n\n        if (fallbackParams && fallbackParams.size > 0) {\n          // We are in a prerender with cacheComponents semantics. We are going to\n          // hang here and never resolve. This will cause the currently\n          // rendering component to effectively be a dynamic hole.\n          React.use(\n            makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          )\n        }\n        break\n      }\n      case 'prerender-ppr': {\n        const fallbackParams = workUnitStore.fallbackRouteParams\n        if (fallbackParams && fallbackParams.size > 0) {\n          return postponeWithTracking(\n            workStore.route,\n            expression,\n            workUnitStore.dynamicTracking\n          )\n        }\n        break\n      }\n      case 'prerender-runtime':\n        throw new InvariantError(\n          `\\`${expression}\\` was called during a runtime prerender. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'cache':\n      case 'private-cache':\n        throw new InvariantError(\n          `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n        )\n      case 'prerender-legacy':\n      case 'request':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n}\n\nexport function useDynamicSearchParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore) {\n    // We assume pages router context and just return\n    return\n  }\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(expression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'prerender-client': {\n      React.use(\n        makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      )\n      break\n    }\n    case 'prerender-legacy':\n    case 'prerender-ppr': {\n      if (workStore.forceStatic) {\n        return\n      }\n      throw new BailoutToCSRError(expression)\n    }\n    case 'prerender':\n    case 'prerender-runtime':\n      throw new InvariantError(\n        `\\`${expression}\\` was called from a Server Component. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'cache':\n    case 'unstable-cache':\n    case 'private-cache':\n      throw new InvariantError(\n        `\\`${expression}\\` was called inside a cache scope. Next.js should be preventing ${expression} from being included in server components statically, but did not in this case.`\n      )\n    case 'request':\n      return\n    default:\n      workUnitStore satisfies never\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\n\n// Common implicit body tags that React will treat as body when placed directly in html\nconst bodyAndImplicitTags =\n  'body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6'\n\n// Detects when RootLayoutBoundary (our framework marker component) appears\n// after Suspense in the component stack, indicating the root layout is wrapped\n// within a Suspense boundary. Ensures no body/html/implicit-body components are in between.\n//\n// Example matches:\n//   at Suspense (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\n//\n// Or with other components in between (but not body/html/implicit-body):\n//   at Suspense (<anonymous>)\n//   at SomeComponent (<anonymous>)\n//   at __next_root_layout_boundary__ (<anonymous>)\nconst hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex = new RegExp(\n  `\\\\n\\\\s+at Suspense \\\\(<anonymous>\\\\)(?:(?!\\\\n\\\\s+at (?:${bodyAndImplicitTags}) \\\\(<anonymous>\\\\))[\\\\s\\\\S])*?\\\\n\\\\s+at ${ROOT_LAYOUT_BOUNDARY_NAME} \\\\([^\\\\n]*\\\\)`\n)\n\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  workStore: WorkStore,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (\n    hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex.test(\n      componentStack\n    )\n  ) {\n    // For Suspense within body, the prelude wouldn't be empty so it wouldn't violate the empty static shells rule.\n    // But if you have Suspense above body, the prelude is empty but we allow that because having Suspense\n    // is an explicit signal from the user that they acknowledge the empty shell and want dynamic rendering.\n    dynamicValidation.hasAllowedDynamic = true\n    dynamicValidation.hasSuspenseAboveBody = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    // this error had a Suspense boundary above it so we don't need to report it as a source\n    // of disallowed\n    dynamicValidation.hasAllowedDynamic = true\n    return\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    // This task was the task that called the sync error.\n    dynamicValidation.dynamicErrors.push(\n      clientDynamic.syncDynamicErrorWithStack\n    )\n    return\n  } else {\n    const message =\n      `Route \"${workStore.route}\": Uncached data was accessed outside of ` +\n      '<Suspense>. This delays the entire page from rendering, resulting in a ' +\n      'slow user experience. Learn more: ' +\n      'https://nextjs.org/docs/messages/blocking-route'\n    const error = createErrorWithComponentOrOwnerStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\n/**\n * In dev mode, we prefer using the owner stack, otherwise the provided\n * component stack is used.\n */\nfunction createErrorWithComponentOrOwnerStack(\n  message: string,\n  componentStack: string\n) {\n  const ownerStack =\n    process.env.NODE_ENV !== 'production' && React.captureOwnerStack\n      ? React.captureOwnerStack()\n      : null\n\n  const error = new Error(message)\n  error.stack = error.name + ': ' + message + (ownerStack ?? componentStack)\n  return error\n}\n\nexport enum PreludeState {\n  Full = 0,\n  Empty = 1,\n  Errored = 2,\n}\n\nexport function logDisallowedDynamicError(\n  workStore: WorkStore,\n  error: Error\n): void {\n  console.error(error)\n\n  if (!workStore.dev) {\n    if (workStore.hasReadableErrorStacks) {\n      console.error(\n        `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.`\n      )\n    } else {\n      console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:\n  - Start the app in development mode by running \\`next dev\\`, then open \"${workStore.route}\" in your browser to investigate the error.\n  - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.`)\n    }\n  }\n}\n\nexport function throwIfDisallowedDynamic(\n  workStore: WorkStore,\n  prelude: PreludeState,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState\n): void {\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    logDisallowedDynamicError(\n      workStore,\n      serverDynamic.syncDynamicErrorWithStack\n    )\n    throw new StaticGenBailoutError()\n  }\n\n  if (prelude !== PreludeState.Full) {\n    if (dynamicValidation.hasSuspenseAboveBody) {\n      // This route has opted into allowing fully dynamic rendering\n      // by including a Suspense boundary above the body. In this case\n      // a lack of a shell is not considered disallowed so we simply return\n      return\n    }\n\n    // We didn't have any sync bailouts but there may be user code which\n    // blocked the root. We would have captured these during the prerender\n    // and can log them here and then terminate the build/validating render\n    const dynamicErrors = dynamicValidation.dynamicErrors\n    if (dynamicErrors.length > 0) {\n      for (let i = 0; i < dynamicErrors.length; i++) {\n        logDisallowedDynamicError(workStore, dynamicErrors[i])\n      }\n\n      throw new StaticGenBailoutError()\n    }\n\n    // If we got this far then the only other thing that could be blocking\n    // the root is dynamic Viewport. If this is dynamic then\n    // you need to opt into that by adding a Suspense boundary above the body\n    // to indicate your are ok with fully dynamic rendering.\n    if (dynamicValidation.hasDynamicViewport) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n      )\n      throw new StaticGenBailoutError()\n    }\n\n    if (prelude === PreludeState.Empty) {\n      // If we ever get this far then we messed up the tracking of invalid dynamic.\n      // We still adhere to the constraint that you must produce a shell but invite the\n      // user to report this as a bug in Next.js.\n      console.error(\n        `Route \"${workStore.route}\" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`\n      )\n      throw new StaticGenBailoutError()\n    }\n  } else {\n    if (\n      dynamicValidation.hasAllowedDynamic === false &&\n      dynamicValidation.hasDynamicMetadata\n    ) {\n      console.error(\n        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n      )\n      throw new StaticGenBailoutError()\n    }\n  }\n}\n\nexport function delayUntilRuntimeStage<T>(\n  prerenderStore: PrerenderStoreModernRuntime,\n  result: Promise<T>\n): Promise<T> {\n  if (prerenderStore.runtimeStagePromise) {\n    return prerenderStore.runtimeStagePromise.then(() => result)\n  }\n  return result\n}\n","import { isHangingPromiseRejectionError } from '../../server/dynamic-rendering-utils'\nimport { isPostpone } from '../../server/lib/router-utils/is-postpone'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\nimport {\n  isDynamicPostpone,\n  isPrerenderInterruptedError,\n} from '../../server/app-render/dynamic-rendering'\nimport { isDynamicServerError } from './hooks-server-context'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (\n    isNextRouterError(error) ||\n    isBailoutToCSRError(error) ||\n    isDynamicServerError(error) ||\n    isDynamicPostpone(error) ||\n    isPostpone(error) ||\n    isHangingPromiseRejectionError(error) ||\n    isPrerenderInterruptedError(error)\n  ) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","import { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nexport function unstable_isUnrecognizedActionError(): boolean {\n  throw new Error(\n    '`unstable_isUnrecognizedActionError` can only be used on the client.'\n  )\n}\n\nexport { redirect, permanentRedirect } from './redirect'\nexport { RedirectType } from './redirect-error'\nexport { notFound } from './not-found'\nexport { forbidden } from './forbidden'\nexport { unauthorized } from './unauthorized'\nexport { unstable_rethrow } from './unstable-rethrow'\nexport { ReadonlyURLSearchParams }\n","import type { Params } from '../../server/request/params'\n\nimport React, { useContext, useMemo, use } from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  type AppRouterInstance,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n  NavigationPromisesContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport {\n  computeSelectedLayoutSegment,\n  getSelectedLayoutSegmentPath,\n} from '../../shared/lib/segment'\nimport { ReadonlyURLSearchParams } from './readonly-url-search-params'\n\nconst useDynamicRouteParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicRouteParams\n    : undefined\n\nconst useDynamicSearchParams =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/dynamic-rendering') as typeof import('../../server/app-render/dynamic-rendering')\n      ).useDynamicSearchParams\n    : undefined\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you *read* the current URL's search parameters.\n *\n * Learn more about [`URLSearchParams` on MDN](https://developer.mozilla.org/docs/Web/API/URLSearchParams)\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useSearchParams } from 'next/navigation'\n *\n * export default function Page() {\n *   const searchParams = useSearchParams()\n *   searchParams.get('foo') // returns 'bar' when ?foo=bar\n *   // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSearchParams`](https://nextjs.org/docs/app/api-reference/functions/use-search-params)\n */\n// Client components API\nexport function useSearchParams(): ReadonlyURLSearchParams {\n  useDynamicSearchParams?.('useSearchParams()')\n\n  const searchParams = useContext(SearchParamsContext)\n\n  // In the case where this is `null`, the compat types added in\n  // `next-env.d.ts` will add a new overload that changes the return type to\n  // include `null`.\n  const readonlySearchParams = useMemo(() => {\n    if (!searchParams) {\n      // When the router is not ready in pages, we won't have the search params\n      // available.\n      return null\n    }\n\n    return new ReadonlyURLSearchParams(searchParams)\n  }, [searchParams]) as ReadonlyURLSearchParams\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.searchParams)\n    }\n  }\n\n  return readonlySearchParams\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the current URL's pathname.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { usePathname } from 'next/navigation'\n *\n * export default function Page() {\n *  const pathname = usePathname() // returns \"/dashboard\" on /dashboard?foo=bar\n *  // ...\n * }\n * ```\n *\n * Read more: [Next.js Docs: `usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname)\n */\n// Client components API\nexport function usePathname(): string {\n  useDynamicRouteParams?.('usePathname()')\n\n  // In the case where this is `null`, the compat types added in `next-env.d.ts`\n  // will add a new overload that changes the return type to include `null`.\n  const pathname = useContext(PathnameContext) as string\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.pathname)\n    }\n  }\n\n  return pathname\n}\n\n// Client components API\nexport {\n  ServerInsertedHTMLContext,\n  useServerInsertedHTML,\n} from '../../shared/lib/server-inserted-html.shared-runtime'\n\n/**\n *\n * This hook allows you to programmatically change routes inside [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components).\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useRouter } from 'next/navigation'\n *\n * export default function Page() {\n *  const router = useRouter()\n *  // ...\n *  router.push('/dashboard') // Navigate to /dashboard\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useRouter`](https://nextjs.org/docs/app/api-reference/functions/use-router)\n */\n// Client components API\nexport function useRouter(): AppRouterInstance {\n  const router = useContext(AppRouterContext)\n  if (router === null) {\n    throw new Error('invariant expected app router to be mounted')\n  }\n\n  return router\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read a route's dynamic params filled in by the current URL.\n *\n * @example\n * ```ts\n * \"use client\"\n * import { useParams } from 'next/navigation'\n *\n * export default function Page() {\n *   // on /dashboard/[team] where pathname is /dashboard/nextjs\n *   const { team } = useParams() // team === \"nextjs\"\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useParams`](https://nextjs.org/docs/app/api-reference/functions/use-params)\n */\n// Client components API\nexport function useParams<T extends Params = Params>(): T {\n  useDynamicRouteParams?.('useParams()')\n\n  const params = useContext(PathParamsContext) as T\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      return use(navigationPromises.params) as T\n    }\n  }\n\n  return params\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segments **below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n *\n * import { useSelectedLayoutSegments } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segments = useSelectedLayoutSegments()\n *\n *   return (\n *     <ul>\n *       {segments.map((segment, index) => (\n *         <li key={index}>{segment}</li>\n *       ))}\n *     </ul>\n *   )\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments)\n */\n// Client components API\nexport function useSelectedLayoutSegments(\n  parallelRouteKey: string = 'children'\n): string[] {\n  useDynamicRouteParams?.('useSelectedLayoutSegments()')\n\n  const context = useContext(LayoutRouterContext)\n  // @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts\n  if (!context) return null\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (process.env.NODE_ENV !== 'production' && 'use' in React) {\n    const navigationPromises = use(NavigationPromisesContext)\n    if (navigationPromises) {\n      const promise =\n        navigationPromises.selectedLayoutSegmentsPromises?.get(parallelRouteKey)\n      if (promise) {\n        // We should always have a promise here, but if we don't, it's not worth erroring over.\n        // We just won't be able to instrument it, but can still provide the value.\n        return use(promise)\n      }\n    }\n  }\n\n  return getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey)\n}\n\n/**\n * A [Client Component](https://nextjs.org/docs/app/building-your-application/rendering/client-components) hook\n * that lets you read the active route segment **one level below** the Layout it is called from.\n *\n * @example\n * ```ts\n * 'use client'\n * import { useSelectedLayoutSegment } from 'next/navigation'\n *\n * export default function ExampleClientComponent() {\n *   const segment = useSelectedLayoutSegment()\n *\n *   return <p>Active segment: {segment}</p>\n * }\n * ```\n *\n * Read more: [Next.js Docs: `useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment)\n */\n// Client components API\nexport function useSelectedLayoutSegment(\n  parallelRouteKey: string = 'children'\n): string | null {\n  useDynamicRouteParams?.('useSelectedLayoutSegment()')\n  const navigationPromises = useContext(NavigationPromisesContext)\n  const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey)\n\n  // Instrument with Suspense DevTools (dev-only)\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    navigationPromises &&\n    'use' in React\n  ) {\n    const promise =\n      navigationPromises.selectedLayoutSegmentPromises?.get(parallelRouteKey)\n    if (promise) {\n      // We should always have a promise here, but if we don't, it's not worth erroring over.\n      // We just won't be able to instrument it, but can still provide the value.\n      return use(promise)\n    }\n  }\n\n  return computeSelectedLayoutSegment(selectedLayoutSegments, parallelRouteKey)\n}\n\nexport { unstable_isUnrecognizedActionError } from './unrecognized-action-error'\n\n// Shared components APIs\nexport {\n  notFound,\n  forbidden,\n  unauthorized,\n  redirect,\n  permanentRedirect,\n  RedirectType,\n  ReadonlyURLSearchParams,\n  unstable_rethrow,\n} from './navigation.react-server'\n","module.exports = require('./dist/client/components/navigation')\n","import type { ParsedUrlQuery } from 'querystring'\n\nexport function searchParamsToUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  const query: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    const existing = query[key]\n    if (typeof existing === 'undefined') {\n      query[key] = value\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      query[key] = [existing, value]\n    }\n  }\n  return query\n}\n\nfunction stringifyUrlQueryParam(param: unknown): string {\n  if (typeof param === 'string') {\n    return param\n  }\n\n  if (\n    (typeof param === 'number' && !isNaN(param)) ||\n    typeof param === 'boolean'\n  ) {\n    return String(param)\n  } else {\n    return ''\n  }\n}\n\nexport function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {\n  const searchParams = new URLSearchParams()\n  for (const [key, value] of Object.entries(query)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        searchParams.append(key, stringifyUrlQueryParam(item))\n      }\n    } else {\n      searchParams.set(key, stringifyUrlQueryParam(value))\n    }\n  }\n  return searchParams\n}\n\nexport function assign(\n  target: URLSearchParams,\n  ...searchParamsList: URLSearchParams[]\n): URLSearchParams {\n  for (const searchParams of searchParamsList) {\n    for (const key of searchParams.keys()) {\n      target.delete(key)\n    }\n\n    for (const [key, value] of searchParams.entries()) {\n      target.append(key, value)\n    }\n  }\n\n  return target\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport type { UrlObject } from 'url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport * as querystring from './querystring'\n\nconst slashedProtocols = /https?|ftp|gopher|file/\n\nexport function formatUrl(urlObj: UrlObject) {\n  let { auth, hostname } = urlObj\n  let protocol = urlObj.protocol || ''\n  let pathname = urlObj.pathname || ''\n  let hash = urlObj.hash || ''\n  let query = urlObj.query || ''\n  let host: string | false = false\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''\n\n  if (urlObj.host) {\n    host = auth + urlObj.host\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)\n    if (urlObj.port) {\n      host += ':' + urlObj.port\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || ''\n\n  if (protocol && !protocol.endsWith(':')) protocol += ':'\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '')\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname\n  } else if (!host) {\n    host = ''\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash\n  if (search && search[0] !== '?') search = '?' + search\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent)\n  search = search.replace('#', '%23')\n\n  return `${protocol}${host}${pathname}${search}${hash}`\n}\n\nexport const urlObjectKeys = [\n  'auth',\n  'hash',\n  'host',\n  'hostname',\n  'href',\n  'path',\n  'pathname',\n  'port',\n  'protocol',\n  'query',\n  'search',\n  'slashes',\n]\n\nexport function formatWithValidation(url: UrlObject): string {\n  if (process.env.NODE_ENV === 'development') {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach((key) => {\n        if (!urlObjectKeys.includes(key)) {\n          console.warn(\n            `Unknown key passed via urlObject into url.format: ${key}`\n          )\n        }\n      })\n    }\n  }\n\n  return formatUrl(url)\n}\n","import type { HtmlProps } from './html-context.shared-runtime'\nimport type { ComponentType, JSX } from 'react'\nimport type { DomainLocale } from '../../server/config'\nimport type { Env } from '@next/env'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { NextRouter } from './router/router'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PreviewData } from '../../types'\nimport type { COMPILER_NAMES } from './constants'\nimport type fs from 'fs'\n\nexport type NextComponentType<\n  Context extends BaseContext = NextPageContext,\n  InitialProps = {},\n  Props = {},\n> = ComponentType<Props> & {\n  /**\n   * Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.\n   * Make sure to return plain `Object` without using `Date`, `Map`, `Set`.\n   * @param context Context of `page`\n   */\n  getInitialProps?(context: Context): InitialProps | Promise<InitialProps>\n}\n\nexport type DocumentType = NextComponentType<\n  DocumentContext,\n  DocumentInitialProps,\n  DocumentProps\n>\n\nexport type AppType<P = {}> = NextComponentType<\n  AppContextType,\n  P,\n  AppPropsType<any, P>\n>\n\nexport type AppTreeType = ComponentType<\n  AppInitialProps & { [name: string]: any }\n>\n\n/**\n * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.\n * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting\n */\nexport const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const\nexport type NextWebVitalsMetric = {\n  id: string\n  startTime: number\n  value: number\n  attribution?: { [key: string]: unknown }\n} & (\n  | {\n      label: 'web-vital'\n      name: (typeof WEB_VITALS)[number]\n    }\n  | {\n      label: 'custom'\n      name:\n        | 'Next.js-hydration'\n        | 'Next.js-route-change-to-render'\n        | 'Next.js-render'\n    }\n)\n\nexport type Enhancer<C> = (Component: C) => C\n\nexport type ComponentsEnhancer =\n  | {\n      enhanceApp?: Enhancer<AppType>\n      enhanceComponent?: Enhancer<NextComponentType>\n    }\n  | Enhancer<NextComponentType>\n\nexport type RenderPageResult = {\n  html: string\n  head?: Array<JSX.Element | null>\n}\n\nexport type RenderPage = (\n  options?: ComponentsEnhancer\n) => DocumentInitialProps | Promise<DocumentInitialProps>\n\nexport type BaseContext = {\n  res?: ServerResponse\n  [k: string]: any\n}\n\nexport type NEXT_DATA = {\n  props: Record<string, any>\n  page: string\n  query: ParsedUrlQuery\n  buildId: string\n  assetPrefix?: string\n  nextExport?: boolean\n  autoExport?: boolean\n  isFallback?: boolean\n  isExperimentalCompile?: boolean\n  dynamicIds?: (string | number)[]\n  err?: Error & {\n    statusCode?: number\n    source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer\n  }\n  gsp?: boolean\n  gssp?: boolean\n  customServer?: boolean\n  gip?: boolean\n  appGip?: boolean\n  locale?: string\n  locales?: readonly string[]\n  defaultLocale?: string\n  domainLocales?: readonly DomainLocale[]\n  scriptLoader?: any[]\n  isPreview?: boolean\n  notFoundSrcPage?: string\n}\n\n/**\n * `Next` context\n */\nexport interface NextPageContext {\n  /**\n   * Error object if encountered during rendering\n   */\n  err?: (Error & { statusCode?: number }) | null\n  /**\n   * `HTTP` request object.\n   */\n  req?: IncomingMessage\n  /**\n   * `HTTP` response object.\n   */\n  res?: ServerResponse\n  /**\n   * Path section of `URL`.\n   */\n  pathname: string\n  /**\n   * Query string section of `URL` parsed as an object.\n   */\n  query: ParsedUrlQuery\n  /**\n   * `String` of the actual path including query.\n   */\n  asPath?: string\n  /**\n   * The currently active locale\n   */\n  locale?: string\n  /**\n   * All configured locales\n   */\n  locales?: readonly string[]\n  /**\n   * The configured default locale\n   */\n  defaultLocale?: string\n  /**\n   * `Component` the tree of the App to use if needing to render separately\n   */\n  AppTree: AppTreeType\n}\n\nexport type AppContextType<Router extends NextRouter = NextRouter> = {\n  Component: NextComponentType<NextPageContext>\n  AppTree: AppTreeType\n  ctx: NextPageContext\n  router: Router\n}\n\nexport type AppInitialProps<PageProps = any> = {\n  pageProps: PageProps\n}\n\nexport type AppPropsType<\n  Router extends NextRouter = NextRouter,\n  PageProps = {},\n> = AppInitialProps<PageProps> & {\n  Component: NextComponentType<NextPageContext, any, any>\n  router: Router\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n}\n\nexport type DocumentContext = NextPageContext & {\n  renderPage: RenderPage\n  defaultGetInitialProps(\n    ctx: DocumentContext,\n    options?: { nonce?: string }\n  ): Promise<DocumentInitialProps>\n}\n\nexport type DocumentInitialProps = RenderPageResult & {\n  styles?: React.ReactElement[] | Iterable<React.ReactNode> | JSX.Element\n}\n\nexport type DocumentProps = DocumentInitialProps & HtmlProps\n\n/**\n * Next `API` route request\n */\nexport interface NextApiRequest extends IncomingMessage {\n  /**\n   * Object of `query` values from url\n   */\n  query: Partial<{\n    [key: string]: string | string[]\n  }>\n  /**\n   * Object of `cookies` from header\n   */\n  cookies: Partial<{\n    [key: string]: string\n  }>\n\n  body: any\n\n  env: Env\n\n  draftMode?: boolean\n\n  preview?: boolean\n  /**\n   * Preview data set on the request, if any\n   * */\n  previewData?: PreviewData\n}\n\n/**\n * Send body of response\n */\ntype Send<T> = (body: T) => void\n\n/**\n * Next `API` route response\n */\nexport type NextApiResponse<Data = any> = ServerResponse & {\n  /**\n   * Send data `any` data in response\n   */\n  send: Send<Data>\n  /**\n   * Send data `json` data in response\n   */\n  json: Send<Data>\n  status: (statusCode: number) => NextApiResponse<Data>\n  redirect(url: string): NextApiResponse<Data>\n  redirect(status: number, url: string): NextApiResponse<Data>\n\n  /**\n   * Set draft mode\n   */\n  setDraftMode: (options: { enable: boolean }) => NextApiResponse<Data>\n\n  /**\n   * Set preview data for Next.js' prerender mode\n   */\n  setPreviewData: (\n    data: object | string,\n    options?: {\n      /**\n       * Specifies the number (in seconds) for the preview session to last for.\n       * The given number will be converted to an integer by rounding down.\n       * By default, no maximum age is set and the preview session finishes\n       * when the client shuts down (browser is closed).\n       */\n      maxAge?: number\n      /**\n       * Specifies the path for the preview session to work under. By default,\n       * the path is considered the \"default path\", i.e., any pages under \"/\".\n       */\n      path?: string\n    }\n  ) => NextApiResponse<Data>\n\n  /**\n   * Clear preview data for Next.js' prerender mode\n   */\n  clearPreviewData: (options?: { path?: string }) => NextApiResponse<Data>\n\n  /**\n   * Revalidate a specific page and regenerate it using On-Demand Incremental\n   * Static Regeneration.\n   * The path should be an actual path, not a rewritten path. E.g. for\n   * \"/blog/[slug]\" this should be \"/blog/post-1\".\n   * @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath\n   */\n  revalidate: (\n    urlPath: string,\n    opts?: {\n      unstable_onlyGenerated?: boolean\n    }\n  ) => Promise<void>\n}\n\n/**\n * Next `API` route handler\n */\nexport type NextApiHandler<T = any> = (\n  req: NextApiRequest,\n  res: NextApiResponse<T>\n) => unknown | Promise<unknown>\n\n/**\n * Utils\n */\nexport function execOnce<T extends (...args: any[]) => ReturnType<T>>(\n  fn: T\n): T {\n  let used = false\n  let result: ReturnType<T>\n\n  return ((...args: any[]) => {\n    if (!used) {\n      used = true\n      result = fn(...args)\n    }\n    return result\n  }) as T\n}\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url)\n\nexport function getLocationOrigin() {\n  const { protocol, hostname, port } = window.location\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`\n}\n\nexport function getURL() {\n  const { href } = window.location\n  const origin = getLocationOrigin()\n  return href.substring(origin.length)\n}\n\nexport function getDisplayName<P>(Component: ComponentType<P>) {\n  return typeof Component === 'string'\n    ? Component\n    : Component.displayName || Component.name || 'Unknown'\n}\n\nexport function isResSent(res: ServerResponse) {\n  return res.finished || res.headersSent\n}\n\nexport function normalizeRepeatedSlashes(url: string) {\n  const urlParts = url.split('?')\n  const urlNoQuery = urlParts[0]\n\n  return (\n    urlNoQuery\n      // first we replace any non-encoded backslashes with forward\n      // then normalize repeated forward slashes\n      .replace(/\\\\/g, '/')\n      .replace(/\\/\\/+/g, '/') +\n    (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')\n  )\n}\n\nexport async function loadGetInitialProps<\n  C extends BaseContext,\n  IP = {},\n  P = {},\n>(App: NextComponentType<C, IP, P>, ctx: C): Promise<IP> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (App.prototype?.getInitialProps) {\n      const message = `\"${getDisplayName(\n        App\n      )}.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`\n      throw new Error(message)\n    }\n  }\n  // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || (ctx.ctx && ctx.ctx.res)\n\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),\n      }\n    }\n    return {} as IP\n  }\n\n  const props = await App.getInitialProps(ctx)\n\n  if (res && isResSent(res)) {\n    return props\n  }\n\n  if (!props) {\n    const message = `\"${getDisplayName(\n      App\n    )}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`\n    throw new Error(message)\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(\n        `${getDisplayName(\n          App\n        )} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`\n      )\n    }\n  }\n\n  return props\n}\n\nexport const SP = typeof performance !== 'undefined'\nexport const ST =\n  SP &&\n  (['mark', 'measure', 'getEntriesByName'] as const).every(\n    (method) => typeof performance[method] === 'function'\n  )\n\nexport class DecodeError extends Error {}\nexport class NormalizeError extends Error {}\nexport class PageNotFoundError extends Error {\n  code: string\n\n  constructor(page: string) {\n    super()\n    this.code = 'ENOENT'\n    this.name = 'PageNotFoundError'\n    this.message = `Cannot find module for page: ${page}`\n  }\n}\n\nexport class MissingStaticPage extends Error {\n  constructor(page: string, message: string) {\n    super()\n    this.message = `Failed to load static file for page: ${page} ${message}`\n  }\n}\n\nexport class MiddlewareNotFoundError extends Error {\n  code: string\n  constructor() {\n    super()\n    this.code = 'ENOENT'\n    this.message = `Cannot find the middleware module`\n  }\n}\n\nexport interface CacheFs {\n  existsSync: typeof fs.existsSync\n  readFile: typeof fs.promises.readFile\n  readFileSync: typeof fs.readFileSync\n  writeFile(f: string, d: any): Promise<void>\n  mkdir(dir: string): Promise<void | string>\n  stat(f: string): Promise<{ mtime: Date }>\n}\n\nexport function stringifyError(error: Error) {\n  return JSON.stringify({ message: error.message, stack: error.stack })\n}\n","/**\n * Given a path this function will find the pathname, query and hash and return\n * them. This is useful to parse full paths on the client side.\n * @param path A path to parse e.g. /foo/bar?id=1#hash\n */\nexport function parsePath(path: string) {\n  const hashIndex = path.indexOf('#')\n  const queryIndex = path.indexOf('?')\n  const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex)\n\n  if (hasQuery || hashIndex > -1) {\n    return {\n      pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n      query: hasQuery\n        ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined)\n        : '',\n      hash: hashIndex > -1 ? path.slice(hashIndex) : '',\n    }\n  }\n\n  return { pathname: path, query: '', hash: '' }\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Adds the provided prefix to the given path. It first ensures that the path\n * is indeed starting with a slash.\n */\nexport function addPathPrefix(path: string, prefix?: string) {\n  if (!path.startsWith('/') || !prefix) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  return `${prefix}${pathname}${query}${hash}`\n}\n","/**\n * Removes the trailing slash for a given route or page path. Preserves the\n * root page. Examples:\n *   - `/foo/bar/` -> `/foo/bar`\n *   - `/foo/bar` -> `/foo/bar`\n *   - `/` -> `/`\n */\nexport function removeTrailingSlash(route: string) {\n  return route.replace(/\\/$/, '') || '/'\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import { addPathPrefix } from '../shared/lib/router/utils/add-path-prefix'\nimport { normalizePathTrailingSlash } from './normalize-trailing-slash'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function addBasePath(path: string, required?: boolean): string {\n  return normalizePathTrailingSlash(\n    process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required\n      ? path\n      : addPathPrefix(path, basePath)\n  )\n}\n","// This regex contains the bots that we need to do a blocking render for and can't safely stream the response\n// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.\n// Note: The pattern [\\w-]+-Google captures all Google crawlers with \"-Google\" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)\n// as well as crawlers starting with \"Google-\" (e.g., Google-PageRenderer, Google-InspectionTool)\nexport const HTML_LIMITED_BOT_UA_RE =\n  /[\\w-]+-Google|Google-[\\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i\n","import { HTML_LIMITED_BOT_UA_RE } from './html-bots'\n\n// Bot crawler that will spin up a headless browser and execute JS.\n// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.\n// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers\n// This regex specifically matches \"Googlebot\" but NOT \"Mediapartners-Google\", \"AdsBot-Google\", etc.\nconst HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i\n\nexport const HTML_LIMITED_BOT_UA_RE_STRING = HTML_LIMITED_BOT_UA_RE.source\n\nexport { HTML_LIMITED_BOT_UA_RE }\n\nfunction isDomBotUA(userAgent: string) {\n  return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent)\n}\n\nfunction isHtmlLimitedBotUA(userAgent: string) {\n  return HTML_LIMITED_BOT_UA_RE.test(userAgent)\n}\n\nexport function isBot(userAgent: string): boolean {\n  return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent)\n}\n\nexport function getBotType(userAgent: string): 'dom' | 'html' | undefined {\n  if (isDomBotUA(userAgent)) {\n    return 'dom'\n  }\n  if (isHtmlLimitedBotUA(userAgent)) {\n    return 'html'\n  }\n  return undefined\n}\n","import { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n","// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\n// Only functions in this module should be allowed to create CacheKeys.\nexport type NormalizedHref = Opaque<'NormalizedHref', string>\nexport type NormalizedSearch = Opaque<'NormalizedSearch', string>\nexport type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n\nexport type RouteCacheKey = Opaque<\n  'RouteCacheKey',\n  {\n    href: NormalizedHref\n    search: NormalizedSearch\n    nextUrl: NormalizedNextUrl | null\n\n    // TODO: Eventually the dynamic params will be added here, too.\n  }\n>\n\nexport function createCacheKey(\n  originalHref: string,\n  nextUrl: string | null\n): RouteCacheKey {\n  // TODO: We should remove the hash from the href and track that separately.\n  // There's no reason to vary route entries by hash.\n  const originalUrl = new URL(originalHref)\n  const cacheKey = {\n    href: originalHref as NormalizedHref,\n    search: originalUrl.search as NormalizedSearch,\n    nextUrl: nextUrl as NormalizedNextUrl | null,\n  } as RouteCacheKey\n  return cacheKey\n}\n","/**\n * App Router types - Client-safe types for the Next.js App Router\n *\n * This file contains type definitions that can be safely imported\n * by both client-side and server-side code without circular dependencies.\n */\nimport type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'\nimport type React from 'react'\n\nexport type LoadingModuleData =\n  | [React.JSX.Element, React.ReactNode, React.ReactNode]\n  | null\n\n/** viewport metadata node */\nexport type HeadData = React.ReactNode\n\nexport type ChildSegmentMap = Map<string, CacheNode>\n\n/**\n * Cache node used in app-router / layout-router.\n */\nexport type CacheNode = ReadyCacheNode | LazyCacheNode\n\nexport type LazyCacheNode = {\n  /**\n   * When rsc is null, this is a lazily-initialized cache node.\n   *\n   * If the app attempts to render it, it triggers a lazy data fetch,\n   * postpones the render, and schedules an update to a new tree.\n   *\n   * TODO: This mechanism should not be used when PPR is enabled, though it\n   * currently is in some cases until we've implemented partial\n   * segment fetching.\n   */\n  rsc: null\n\n  /**\n   * A prefetched version of the segment data. See explanation in corresponding\n   * field of ReadyCacheNode (below).\n   *\n   * Since LazyCacheNode mostly only exists in the non-PPR implementation, this\n   * will usually be null, but it could have been cloned from a previous\n   * CacheNode that was created by the PPR implementation. Eventually we want\n   * to migrate everything away from LazyCacheNode entirely.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * A pending response for the lazy data fetch. If this is not present\n   * during render, it is lazily created.\n   */\n  lazyData: Promise<FetchServerResponseResult> | null\n\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  /**\n   * Child parallel routes.\n   */\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  /**\n   * The timestamp of the navigation that last updated the CacheNode's data. If\n   * a CacheNode is reused from a previous navigation, this value is not\n   * updated. Used to track the staleness of the data.\n   */\n  navigatedAt: number\n}\n\nexport type ReadyCacheNode = {\n  /**\n   * When rsc is not null, it represents the RSC data for the\n   * corresponding segment.\n   *\n   * `null` is a valid React Node but because segment data is always a\n   * <LayoutRouter> component, we can use `null` to represent empty.\n   *\n   * TODO: For additional type safety, update this type to\n   * Exclude<React.ReactNode, null>. Need to update createEmptyCacheNode to\n   * accept rsc as an argument, or just inline the callers.\n   */\n  rsc: React.ReactNode\n\n  /**\n   * Represents a static version of the segment that can be shown immediately,\n   * and may or may not contain dynamic holes. It's prefetched before a\n   * navigation occurs.\n   *\n   * During rendering, we will choose whether to render `rsc` or `prefetchRsc`\n   * with `useDeferredValue`. As with the `rsc` field, a value of `null` means\n   * no value was provided. In this case, the LayoutRouter will go straight to\n   * rendering the `rsc` value; if that one is also missing, it will suspend and\n   * trigger a lazy fetch.\n   */\n  prefetchRsc: React.ReactNode\n\n  /**\n   * There should never be a lazy data request in this case.\n   */\n  lazyData: null\n  prefetchHead: HeadData | null\n\n  head: HeadData\n\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n\n  parallelRoutes: Map<string, ChildSegmentMap>\n\n  navigatedAt: number\n}\n\nexport type DynamicParamTypes =\n  | 'catchall'\n  | 'catchall-intercepted'\n  | 'optional-catchall'\n  | 'dynamic'\n  | 'dynamic-intercepted'\n\nexport type DynamicParamTypesShort = 'c' | 'ci' | 'oc' | 'd' | 'di'\n\nexport type Segment =\n  | string\n  | [\n      // Param name\n      paramName: string,\n      // Param cache key (almost the same as the value, but arrays are\n      // concatenated into strings)\n      // TODO: We should change this to just be the value. Currently we convert\n      // it back to a value when passing to useParams. It only needs to be\n      // a string when converted to a a cache key, but that doesn't mean we\n      // need to store it as that representation.\n      paramCacheKey: string,\n      // Dynamic param type\n      dynamicParamType: DynamicParamTypesShort,\n    ]\n\n/**\n * Router state\n */\nexport type FlightRouterState = [\n  segment: Segment,\n  parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },\n  url?: string | null,\n  /**\n   * \"refresh\" and \"refetch\", despite being similarly named, have different\n   * semantics:\n   * - \"refetch\" is used during a request to inform the server where rendering\n   *   should start from.\n   *\n   * - \"refresh\" is used by the client to mark that a segment should re-fetch the\n   *   data from the server for the current segment. It uses the \"url\" property\n   *   above to determine where to fetch from.\n   *\n   * - \"inside-shared-layout\" is used during a prefetch request to inform the\n   *   server that even if the segment matches, it should be treated as if it's\n   *   within the \"new\" part of a navigation  inside the shared layout. If\n   *   the segment doesn't match, then it has no effect, since it would be\n   *   treated as new regardless. If it does match, though, the server does not\n   *   need to render it, because the client already has it.\n   *\n   * - \"metadata-only\" instructs the server to skip rendering the segments and\n   *   only send the head data.\n   *\n   *   A bit confusing, but that's because it has only one extremely narrow use\n   *   case  during a non-PPR prefetch, the server uses it to find the first\n   *   loading boundary beneath a shared layout.\n   *\n   *   TODO: We should rethink the protocol for dynamic requests. It might not\n   *   make sense for the client to send a FlightRouterState, since this type is\n   *   overloaded with concerns.\n   */\n  refresh?:\n    | 'refetch'\n    | 'refresh'\n    | 'inside-shared-layout'\n    | 'metadata-only'\n    | null,\n  isRootLayout?: boolean,\n  /**\n   * Only present when responding to a tree prefetch request. Indicates whether\n   * there is a loading boundary somewhere in the tree. The client cache uses\n   * this to determine if it can skip the data prefetch request.\n   */\n  hasLoadingBoundary?: HasLoadingBoundary,\n]\n\nexport const enum HasLoadingBoundary {\n  // There is a loading boundary in this particular segment\n  SegmentHasLoadingBoundary = 1,\n  // There is a loading boundary somewhere in the subtree (but not in\n  // this segment)\n  SubtreeHasLoadingBoundary = 2,\n  // There is no loading boundary in this segment or any of its descendants\n  SubtreeHasNoLoadingBoundary = 3,\n}\n\n/**\n * Individual Flight response path\n */\nexport type FlightSegmentPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n      segment: Segment,\n      parallelRouterKey: string,\n    ]\n\n/**\n * Represents a tree of segments and the Flight data (i.e. React nodes) that\n * correspond to each one. The tree is isomorphic to the FlightRouterState;\n * however in the future we want to be able to fetch arbitrary partial segments\n * without having to fetch all its children. So this response format will\n * likely change.\n */\nexport type CacheNodeSeedData = [\n  node: React.ReactNode | null,\n  parallelRoutes: {\n    [parallelRouterKey: string]: CacheNodeSeedData | null\n  },\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  isPartial: boolean,\n  /** TODO: this doesn't feel like it belongs here, because it's only used during build, in `collectSegmentData` */\n  hasRuntimePrefetch: boolean,\n]\n\nexport type FlightDataSegment = [\n  /* segment of the rendered slice: */ Segment,\n  /* treePatch */ FlightRouterState,\n  /* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component\n  /* head: viewport */ HeadData,\n  /* isHeadPartial */ boolean,\n]\n\nexport type FlightDataPath =\n  // Uses `any` as repeating pattern can't be typed.\n  | any[]\n  // Looks somewhat like this\n  | [\n      // Holds full path to the segment.\n      ...FlightSegmentPath[],\n      ...FlightDataSegment,\n    ]\n\n/**\n * The Flight response data\n */\nexport type FlightData = Array<FlightDataPath> | string\n\nexport type ActionResult = Promise<any>\n\nexport type InitialRSCPayload = {\n  /** buildId */\n  b: string\n  /** initialCanonicalUrlParts */\n  c: string[]\n  /** initialRenderedSearch */\n  q: string\n  /** couldBeIntercepted */\n  i: boolean\n  /** initialFlightData */\n  f: FlightDataPath[]\n  /** missingSlots */\n  m: Set<string> | undefined\n  /** GlobalError */\n  G: [React.ComponentType<any>, React.ReactNode | undefined]\n  /** postponed */\n  s: boolean\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for normal rendering\nexport type NavigationFlightResponse = {\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n  /** prerendered */\n  S: boolean\n}\n\n// Response from `createFromFetch` for server actions. Action's flight data can be null\nexport type ActionFlightResponse = {\n  /** actionResult */\n  a: ActionResult\n  /** buildId */\n  b: string\n  /** flightData */\n  f: FlightData\n}\n\nexport type RSCPayload =\n  | InitialRSCPayload\n  | NavigationFlightResponse\n  | ActionFlightResponse\n","import type { Segment } from '../../shared/lib/app-router-types'\n\nexport const matchSegment = (\n  existingSegment: Segment,\n  segment: Segment\n): boolean => {\n  // segment is either Array or string\n  if (typeof existingSegment === 'string') {\n    if (typeof segment === 'string') {\n      // Common case: segment is just a string\n      return existingSegment === segment\n    }\n    return false\n  }\n\n  if (typeof segment === 'string') {\n    return false\n  }\n  return existingSegment[0] === segment[0] && existingSegment[1] === segment[1]\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\nexport const NEXT_REQUEST_ID_HEADER = 'x-nextjs-request-id' as const\nexport const NEXT_HTML_REQUEST_ID_HEADER = 'x-nextjs-html-request-id' as const\n","import type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  renderedSearch?: string\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n  collectedDebugInfo?: Array<unknown>\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n  didRevalidate?: boolean\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  historyState: AppHistoryState | undefined\n}\n\nexport type AppHistoryState = {\n  tree: FlightRouterState\n  renderedSearch: string\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   */\n  cache: CacheNode\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  renderedSearch: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n\n  /**\n   * The previous next-url that was used previous to a dynamic navigation.\n   */\n  previousNextUrl: string | null\n\n  debugInfo: Array<unknown> | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState =\n  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n  | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import type { Dispatch } from 'react'\nimport React, { use, useMemo } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  // When navigating to a non-prefetched route, then App Router state will be\n  // blocked until the server responds. We need to transfer the `_debugInfo`\n  // from the underlying Flight response onto the top-level promise that is\n  // passed to React (via `use`) so that the latency is accurately represented\n  // in the React DevTools.\n  const stateWithDebugInfo = useMemo(() => {\n    if (isThenable(state)) {\n      const debugInfo: Array<unknown> = []\n      const promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n        if (asyncState.debugInfo !== null) {\n          debugInfo.push(...asyncState.debugInfo)\n        }\n        return asyncState\n      }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n      promiseWithDebugInfo._debugInfo = debugInfo\n      return promiseWithDebugInfo\n    }\n    return state\n  }, [state])\n\n  return isThenable(stateWithDebugInfo)\n    ? use(stateWithDebugInfo)\n    : stateWithDebugInfo\n}\n","import { startTransition } from 'react'\nimport { ACTION_SERVER_ACTION } from './components/router-reducer/router-reducer-types'\nimport { dispatchAppRouterAction } from './components/use-action-queue'\n\nexport async function callServer(actionId: string, actionArgs: any[]) {\n  return new Promise((resolve, reject) => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_SERVER_ACTION,\n        actionId,\n        actionArgs,\n        resolve,\n        reject,\n      })\n    })\n  })\n}\n","const basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\nconst pathname = `${basePath}/__nextjs_source-map`\n\nexport const findSourceMapURL =\n  process.env.NODE_ENV === 'development'\n    ? function findSourceMapURL(filename: string): string | null {\n        if (filename === '') {\n          return null\n        }\n\n        if (\n          filename.startsWith(document.location.origin) &&\n          filename.includes('/_next/static')\n        ) {\n          // This is a request for a client chunk. This can only happen when\n          // using Turbopack. In this case, since we control how those source\n          // maps are generated, we can safely assume that the sourceMappingURL\n          // is relative to the filename, with an added `.map` extension. The\n          // browser can just request this file, and it gets served through the\n          // normal dev server, without the need to route this through\n          // the `/__nextjs_source-map` dev middleware.\n          return `${filename}.map`\n        }\n\n        const url = new URL(pathname, document.location.origin)\n        url.searchParams.set('filename', filename)\n\n        return url.href\n      }\n    : undefined\n","import { PAGE_SEGMENT_KEY } from '../segment'\nimport type { Segment as FlightRouterStateSegment } from '../app-router-types'\n\n// TypeScript trick to simulate opaque types, like in Flow.\ntype Opaque<K, T> = T & { __brand: K }\n\nexport type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\nexport type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\nexport type SegmentCacheKeyPart = Opaque<'SegmentCacheKeyPart', string>\nexport type SegmentCacheKey = Opaque<'SegmentCacheKey', string>\n\nexport const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\nexport const ROOT_SEGMENT_CACHE_KEY = '' as SegmentCacheKey\n\nexport function createSegmentRequestKeyPart(\n  segment: FlightRouterStateSegment\n): SegmentRequestKeyPart {\n  if (typeof segment === 'string') {\n    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n      // The Flight Router State type sometimes includes the search params in\n      // the page segment. However, the Segment Cache tracks this as a separate\n      // key. So, we strip the search params here, and then add them back when\n      // the cache entry is turned back into a FlightRouterState. This is an\n      // unfortunate consequence of the FlightRouteState being used both as a\n      // transport type and as a cache key; we'll address this once more of the\n      // Segment Cache implementation has settled.\n      // TODO: We should hoist the search params out of the FlightRouterState\n      // type entirely, This is our plan for dynamic route params, too.\n      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n    }\n    const safeName =\n      // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n      // But params typically don't include the leading slash. We should use\n      // a different encoding to avoid this special case.\n      segment === '/_not-found'\n        ? '_not-found'\n        : encodeToFilesystemAndURLSafeString(segment)\n    // Since this is not a dynamic segment, it's fully encoded. It does not\n    // need to be \"hydrated\" with a param value.\n    return safeName as SegmentRequestKeyPart\n  }\n\n  const name = segment[0]\n  const paramType = segment[2]\n  const safeName = encodeToFilesystemAndURLSafeString(name)\n\n  const encodedName = '$' + paramType + '$' + safeName\n  return encodedName as SegmentRequestKeyPart\n}\n\nexport function appendSegmentRequestKeyPart(\n  parentRequestKey: SegmentRequestKey,\n  parallelRouteKey: string,\n  childRequestKeyPart: SegmentRequestKeyPart\n): SegmentRequestKey {\n  // Aside from being filesystem safe, segment keys are also designed so that\n  // each segment and parallel route creates its own subdirectory. Roughly in\n  // the same shape as the source app directory. This is mostly just for easier\n  // debugging (you can open up the build folder and navigate the output); if\n  // we wanted to do we could just use a flat structure.\n\n  // Omit the parallel route key for children, since this is the most\n  // common case. Saves some bytes (and it's what the app directory does).\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childRequestKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n}\n\nexport function createSegmentCacheKeyPart(\n  requestKeyPart: SegmentRequestKeyPart,\n  segment: FlightRouterStateSegment\n): SegmentCacheKeyPart {\n  if (typeof segment === 'string') {\n    return requestKeyPart as any as SegmentCacheKeyPart\n  }\n  const paramValue = segment[1]\n  const safeValue = encodeToFilesystemAndURLSafeString(paramValue)\n  return (requestKeyPart + '$' + safeValue) as SegmentCacheKeyPart\n}\n\nexport function appendSegmentCacheKeyPart(\n  parentSegmentKey: SegmentCacheKey,\n  parallelRouteKey: string,\n  childCacheKeyPart: SegmentCacheKeyPart\n): SegmentCacheKey {\n  const slotKey =\n    parallelRouteKey === 'children'\n      ? childCacheKeyPart\n      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`\n  return (parentSegmentKey + '/' + slotKey) as SegmentCacheKey\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeToFilesystemAndURLSafeString(value: string) {\n  if (simpleParamValueRegex.test(value)) {\n    return value\n  }\n  // If there are any unsafe characters, base64url-encode the entire value.\n  // We also add a ! prefix so it doesn't collide with the simple case.\n  const base64url = btoa(value)\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove trailing '='\n  return '!' + base64url\n}\n\nexport function convertSegmentPathToStaticExportFilename(\n  segmentPath: string\n): string {\n  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n}\n","import type { DynamicParamTypesShort } from '../shared/lib/app-router-types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type { NormalizedSearch } from './components/segment-cache'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\nimport type { ParsedUrlQuery } from 'querystring'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport type RouteParam = {\n  name: string\n  value: RouteParamValue\n  type: DynamicParamTypesShort\n}\n\nexport function getRenderedSearch(\n  response: RSCResponse<unknown> | Response\n): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(\n  response: RSCResponse<unknown> | Response\n): string {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (\n    rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname\n  )\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c':\n    case 'ci': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd':\n    case 'di': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n\nexport function urlSearchParamsToParsedUrlQuery(\n  searchParams: URLSearchParams\n): ParsedUrlQuery {\n  // Converts a URLSearchParams object to the same type used by the server when\n  // creating search params props, i.e. the type returned by Node's\n  // \"querystring\" module.\n  const result: ParsedUrlQuery = {}\n  for (const [key, value] of searchParams.entries()) {\n    if (result[key] === undefined) {\n      result[key] = value\n    } else if (Array.isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [result[key], value]\n    }\n  }\n  return result\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import type {\n  CacheNodeSeedData,\n  FlightData,\n  FlightDataPath,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n  HeadData,\n  InitialRSCPayload,\n} from '../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\nimport type { NormalizedSearch } from './components/segment-cache'\nimport {\n  getCacheKeyForDynamicParam,\n  parseDynamicParamFromURLPart,\n  doesStaticSegmentAppearInURL,\n  getRenderedPathname,\n  getRenderedSearch,\n} from './route-params'\nimport { createHrefFromUrl } from './components/router-reducer/create-href-from-url'\n\nexport type NormalizedFlightData = {\n  /**\n   * The full `FlightSegmentPath` inclusive of the final `Segment`\n   */\n  segmentPath: FlightSegmentPath\n  /**\n   * The `FlightSegmentPath` exclusive of the final `Segment`\n   */\n  pathToSegment: FlightSegmentPath\n  segment: Segment\n  tree: FlightRouterState\n  seedData: CacheNodeSeedData | null\n  head: HeadData\n  isHeadPartial: boolean\n  isRootRender: boolean\n}\n\n// TODO: We should only have to export `normalizeFlightData`, however because the initial flight data\n// that gets passed to `createInitialRouterState` doesn't conform to the `FlightDataPath` type (it's missing the root segment)\n// we're currently exporting it so we can use it directly. This should be fixed as part of the unification of\n// the different ways we express `FlightSegmentPath`.\nexport function getFlightDataPartsFromPath(\n  flightDataPath: FlightDataPath\n): NormalizedFlightData {\n  // Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].\n  const flightDataPathLength = 4\n  // tree, seedData, and head are *always* the last three items in the `FlightDataPath`.\n  const [tree, seedData, head, isHeadPartial] =\n    flightDataPath.slice(-flightDataPathLength)\n  // The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.\n  const segmentPath = flightDataPath.slice(0, -flightDataPathLength)\n\n  return {\n    // TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (\"\")\n    // to the start of the segment path in some places which makes it hard to use solely the segment path.\n    // Look for \"// TODO-APP: remove ''\" in the codebase.\n    pathToSegment: segmentPath.slice(0, -1),\n    segmentPath,\n    // if the `FlightDataPath` corresponds with the root, there'll be no segment path,\n    // in which case we default to ''.\n    segment: segmentPath[segmentPath.length - 1] ?? '',\n    tree,\n    seedData,\n    head,\n    isHeadPartial,\n    isRootRender: flightDataPath.length === flightDataPathLength,\n  }\n}\n\nexport function createInitialRSCPayloadFromFallbackPrerender(\n  response: Response,\n  fallbackInitialRSCPayload: InitialRSCPayload\n): InitialRSCPayload {\n  // This is a static fallback page. In order to hydrate the page, we need to\n  // parse the client params from the URL, but to account for the possibility\n  // that the page was rewritten, we need to check the response headers\n  // for x-nextjs-rewritten-path or x-nextjs-rewritten-query headers. Since\n  // we can't access the headers of the initial document response, the client\n  // performs a fetch request to the current location. Since it's possible that\n  // the fetch request will be dynamically rewritten to a different path than\n  // the initial document, this fetch request delivers _all_ the hydration data\n  // for the page; it was not inlined into the document, like it normally\n  // would be.\n  //\n  // TODO: Consider treating the case where fetch is rewritten to a different\n  // path from the document as a special deopt case. We should optimistically\n  // assume this won't happen, inline the data into the document, and perform\n  // a minimal request (like a HEAD or range request) to verify that the\n  // response matches. Tricky to get right because we need to account for\n  // all the different deployment environments we support, like output:\n  // \"export\" mode, where we currently don't assume that custom response\n  // headers are present.\n\n  // Patch the Flight data sent by the server with the correct params parsed\n  // from the URL + response object.\n  const renderedPathname = getRenderedPathname(response)\n  const renderedSearch = getRenderedSearch(response)\n  const canonicalUrl = createHrefFromUrl(new URL(location.href))\n  const originalFlightDataPath = fallbackInitialRSCPayload.f[0]\n  const originalFlightRouterState = originalFlightDataPath[0]\n  return {\n    b: fallbackInitialRSCPayload.b,\n    c: canonicalUrl.split('/'),\n    q: renderedSearch,\n    i: fallbackInitialRSCPayload.i,\n    f: [\n      [\n        fillInFallbackFlightRouterState(\n          originalFlightRouterState,\n          renderedPathname,\n          renderedSearch as NormalizedSearch\n        ),\n        originalFlightDataPath[1],\n        originalFlightDataPath[2],\n        originalFlightDataPath[2],\n      ],\n    ],\n    m: fallbackInitialRSCPayload.m,\n    G: fallbackInitialRSCPayload.G,\n    s: fallbackInitialRSCPayload.s,\n    S: fallbackInitialRSCPayload.S,\n  }\n}\n\nfunction fillInFallbackFlightRouterState(\n  flightRouterState: FlightRouterState,\n  renderedPathname: string,\n  renderedSearch: NormalizedSearch\n): FlightRouterState {\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  return fillInFallbackFlightRouterStateImpl(\n    flightRouterState,\n    renderedSearch,\n    pathnameParts,\n    index\n  )\n}\n\nfunction fillInFallbackFlightRouterStateImpl(\n  flightRouterState: FlightRouterState,\n  renderedSearch: NormalizedSearch,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): FlightRouterState {\n  const originalSegment = flightRouterState[0]\n  let newSegment: Segment\n  let doesAppearInURL: boolean\n  if (typeof originalSegment === 'string') {\n    newSegment = originalSegment\n    doesAppearInURL = doesStaticSegmentAppearInURL(originalSegment)\n  } else {\n    const paramName = originalSegment[0]\n    const paramType = originalSegment[2]\n    const paramValue = parseDynamicParamFromURLPart(\n      paramType,\n      pathnameParts,\n      pathnamePartsIndex\n    )\n    const cacheKey = getCacheKeyForDynamicParam(paramValue, renderedSearch)\n    newSegment = [paramName, cacheKey, paramType]\n    doesAppearInURL = true\n  }\n\n  // Only increment the index if the segment appears in the URL. If it's a\n  // \"virtual\" segment, like a route group, it remains the same.\n  const childPathnamePartsIndex = doesAppearInURL\n    ? pathnamePartsIndex + 1\n    : pathnamePartsIndex\n\n  const children = flightRouterState[1]\n  const newChildren: { [key: string]: FlightRouterState } = {}\n  for (let key in children) {\n    const childFlightRouterState = children[key]\n    newChildren[key] = fillInFallbackFlightRouterStateImpl(\n      childFlightRouterState,\n      renderedSearch,\n      pathnameParts,\n      childPathnamePartsIndex\n    )\n  }\n\n  const newState: FlightRouterState = [\n    newSegment,\n    newChildren,\n    null,\n    flightRouterState[3],\n    flightRouterState[4],\n  ]\n  return newState\n}\n\nexport function getNextFlightSegmentPath(\n  flightSegmentPath: FlightSegmentPath\n): FlightSegmentPath {\n  // Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items\n  // to get the next segment path.\n  return flightSegmentPath.slice(2)\n}\n\nexport function normalizeFlightData(\n  flightData: FlightData\n): NormalizedFlightData[] | string {\n  // FlightData can be a string when the server didn't respond with a proper flight response,\n  // or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.\n  if (typeof flightData === 'string') {\n    return flightData\n  }\n\n  return flightData.map((flightDataPath) =>\n    getFlightDataPartsFromPath(flightDataPath)\n  )\n}\n\n/**\n * This function is used to prepare the flight router state for the request.\n * It removes markers that are not needed by the server, and are purely used\n * for stashing state on the client.\n * @param flightRouterState - The flight router state to prepare.\n * @param isHmrRefresh - Whether this is an HMR refresh request.\n * @returns The prepared flight router state.\n */\nexport function prepareFlightRouterStateForRequest(\n  flightRouterState: FlightRouterState,\n  isHmrRefresh?: boolean\n): string {\n  // HMR requests need the complete, unmodified state for proper functionality\n  if (isHmrRefresh) {\n    return encodeURIComponent(JSON.stringify(flightRouterState))\n  }\n\n  return encodeURIComponent(\n    JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState))\n  )\n}\n\n/**\n * Recursively strips client-only data from FlightRouterState while preserving\n * server-needed information for proper rendering decisions.\n */\nfunction stripClientOnlyDataFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): FlightRouterState {\n  const [\n    segment,\n    parallelRoutes,\n    _url, // Intentionally unused - URLs are client-only\n    refreshMarker,\n    isRootLayout,\n    hasLoadingBoundary,\n  ] = flightRouterState\n\n  // __PAGE__ segments are always fetched from the server, so there's\n  // no need to send them up\n  const cleanedSegment = stripSearchParamsFromPageSegment(segment)\n\n  // Recursively process parallel routes\n  const cleanedParallelRoutes: { [key: string]: FlightRouterState } = {}\n  for (const [key, childState] of Object.entries(parallelRoutes)) {\n    cleanedParallelRoutes[key] =\n      stripClientOnlyDataFromFlightRouterState(childState)\n  }\n\n  const result: FlightRouterState = [\n    cleanedSegment,\n    cleanedParallelRoutes,\n    null, // URLs omitted - server reconstructs paths from segments\n    shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : null,\n  ]\n\n  // Append optional fields if present\n  if (isRootLayout !== undefined) {\n    result[4] = isRootLayout\n  }\n  if (hasLoadingBoundary !== undefined) {\n    result[5] = hasLoadingBoundary\n  }\n\n  return result\n}\n\n/**\n * Strips search parameters from __PAGE__ segments to prevent sensitive\n * client-side data from being sent to the server.\n */\nfunction stripSearchParamsFromPageSegment(segment: Segment): Segment {\n  if (\n    typeof segment === 'string' &&\n    segment.startsWith(PAGE_SEGMENT_KEY + '?')\n  ) {\n    return PAGE_SEGMENT_KEY\n  }\n  return segment\n}\n\n/**\n * Determines whether the refresh marker should be sent to the server\n * Client-only markers like 'refresh' are stripped, while server-needed markers\n * like 'refetch' and 'inside-shared-layout' are preserved.\n */\nfunction shouldPreserveRefreshMarker(\n  refreshMarker: FlightRouterState[3]\n): boolean {\n  return Boolean(refreshMarker && refreshMarker !== 'refresh')\n}\n","// This gets assigned as a side-effect during app initialization. Because it\n// represents the build used to create the JS bundle, it should never change\n// after being set, so we store it in a global variable.\n//\n// When performing RSC requests, if the incoming data has a different build ID,\n// we perform an MPA navigation/refresh to load the updated build and ensure\n// that the client and server in sync.\n\n// Starts as an empty string. In practice, because setAppBuildId is called\n// during initialization before hydration starts, this will always get\n// reassigned to the actual build ID before it's ever needed by a navigation.\n// If for some reasons it didn't, due to a bug or race condition, then on\n// navigation the build comparision would fail and trigger an MPA navigation.\nlet globalBuildId: string = ''\n\nexport function setAppBuildId(buildId: string) {\n  globalBuildId = buildId\n}\n\nexport function getAppBuildId(): string {\n  return globalBuildId\n}\n","// http://www.cse.yorku.ca/~oz/hash.html\n// More specifically, 32-bit hash via djbxor\n// (ref: https://gist.github.com/eplawless/52813b1d8ad9af510d85?permalink_comment_id=3367765#gistcomment-3367765)\n// This is due to number type differences between rust for turbopack to js number types,\n// where rust does not have easy way to repreesnt js's 53-bit float number type for the matching\n// overflow behavior. This is more `correct` in terms of having canonical hash across different runtime / implementation\n// as can gaurantee determinstic output from 32bit hash.\nexport function djb2Hash(str: string) {\n  let hash = 5381\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) + hash + char) & 0xffffffff\n  }\n  return hash >>> 0\n}\n\nexport function hexHash(str: string) {\n  return djb2Hash(str).toString(36).slice(0, 5)\n}\n","import { hexHash } from '../../hash'\n\nexport function computeCacheBustingSearchParam(\n  prefetchHeader: '1' | '2' | '0' | undefined,\n  segmentPrefetchHeader: string | string[] | undefined,\n  stateTreeHeader: string | string[] | undefined,\n  nextUrlHeader: string | string[] | undefined\n): string {\n  if (\n    (prefetchHeader === undefined || prefetchHeader === '0') &&\n    segmentPrefetchHeader === undefined &&\n    stateTreeHeader === undefined &&\n    nextUrlHeader === undefined\n  ) {\n    return ''\n  }\n  return hexHash(\n    [\n      prefetchHeader || '0',\n      segmentPrefetchHeader || '0',\n      stateTreeHeader || '0',\n      nextUrlHeader || '0',\n    ].join(',')\n  )\n}\n","'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromReadableStream as createFromReadableStreamBrowser,\n  createFromFetch as createFromFetchBrowser,\n} from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_HTML_REQUEST_ID_HEADER,\n  NEXT_REQUEST_ID_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport {\n  getRenderedSearch,\n  urlToUrlWithoutFlightMarker,\n} from '../../route-params'\nimport type { NormalizedSearch } from '../segment-cache'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\nlet createDebugChannel:\n  | typeof import('../../dev/debug-channel').createDebugChannel\n  | undefined\n\nif (\n  process.env.NODE_ENV !== 'production' &&\n  process.env.__NEXT_REACT_DEBUG_CHANNEL\n) {\n  createDebugChannel = (\n    require('../../dev/debug-channel') as typeof import('../../dev/debug-channel')\n  ).createDebugChannel\n}\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\ntype SpaFetchServerResponseResult = {\n  flightData: NormalizedFlightData[]\n  canonicalUrl: URL\n  renderedSearch: NormalizedSearch\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n  debugInfo: Array<any> | null\n}\n\ntype MpaFetchServerResponseResult = string\n\nexport type FetchServerResponseResult =\n  | MpaFetchServerResponseResult\n  | SpaFetchServerResponseResult\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n  [NEXT_HTML_REQUEST_ID_HEADER]?: string // dev-only\n  [NEXT_REQUEST_ID_HEADER]?: string // dev-only\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return urlToUrlWithoutFlightMarker(new URL(url, location.origin)).toString()\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  // In static export mode, we need to modify the URL to request the .txt file,\n  // but we should preserve the original URL for the canonical URL and error handling.\n  const originalUrl = url\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    // Typically, during a navigation, we decode the response using Flight's\n    // `createFromFetch` API, which accepts a `fetch` promise.\n    // TODO: Remove this check once the old PPR flag is removed\n    const isLegacyPPR =\n      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n    const shouldImmediatelyDecode = !isLegacyPPR\n    const res = await createFetch<NavigationFlightResponse>(\n      url,\n      headers,\n      fetchPriority,\n      shouldImmediatelyDecode,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : originalUrl\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    // TODO: This needs to happen in the Flight Client.\n    // Or Webpack needs to include the runtime update in the Flight response as\n    // a blocking script.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    let flightResponsePromise = res.flightResponse\n    if (flightResponsePromise === null) {\n      // Typically, `createFetch` would have already started decoding the\n      // Flight response. If it hasn't, though, we need to decode it now.\n      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n      // without Cache Components). Remove this branch once legacy PPR\n      // is deleted.\n      const flightStream = postponed\n        ? createUnclosingPrefetchStream(res.body)\n        : res.body\n      flightResponsePromise =\n        createFromNextReadableStream<NavigationFlightResponse>(\n          flightStream,\n          headers\n        )\n    }\n\n    const flightResponse = await flightResponsePromise\n\n    if (getAppBuildId() !== flightResponse.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    const normalizedFlightData = normalizeFlightData(flightResponse.f)\n    if (typeof normalizedFlightData === 'string') {\n      return doMpaNavigation(normalizedFlightData)\n    }\n\n    return {\n      flightData: normalizedFlightData,\n      canonicalUrl: canonicalUrl,\n      renderedSearch: getRenderedSearch(res),\n      couldBeIntercepted: interception,\n      prerendered: flightResponse.S,\n      postponed,\n      staleTime,\n      debugInfo: flightResponsePromise._debugInfo ?? null,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${originalUrl}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return originalUrl.toString()\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse<T> = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n}\n\nexport async function createFetch<T>(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  shouldImmediatelyDecode: boolean,\n  signal?: AbortSignal\n): Promise<RSCResponse<T>> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (self.__next_r) {\n      headers[NEXT_HTML_REQUEST_ID_HEADER] = self.__next_r\n    }\n\n    // Create a new request ID for the server action request. The server uses\n    // this to tag debug information sent via WebSocket to the client, which\n    // then routes those chunks to the debug channel associated with this ID.\n    headers[NEXT_REQUEST_ID_HEADER] = crypto\n      .getRandomValues(new Uint32Array(1))[0]\n      .toString(16)\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let fetchPromise = fetch(fetchUrl, fetchOptions)\n  // Immediately pass the fetch promise to the Flight client so that the debug\n  // info includes the latency from the client to the server. The internal timer\n  // in React starts as soon as `createFromFetch` is called.\n  //\n  // The only case where we don't do this is during a prefetch, because we have\n  // to do some extra processing of the response stream (see\n  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n  // prefetch response never blocks a navigation; if it hasn't already been\n  // written into the cache by the time the navigation happens, the router will\n  // go straight to a dynamic request.\n  let flightResponsePromise = shouldImmediatelyDecode\n    ? createFromNextFetch<T>(fetchPromise, headers)\n    : null\n  let browserResponse = await fetchPromise\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid  when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      // TODO: We should abort the previous request.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      fetchPromise = fetch(fetchUrl, fetchOptions)\n      flightResponsePromise = shouldImmediatelyDecode\n        ? createFromNextFetch<T>(fetchPromise, headers)\n        : null\n      browserResponse = await fetchPromise\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse<T> = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n\n    // This is the exact promise returned by `createFromFetch`. It contains\n    // debug information that we need to transfer to any derived promises that\n    // are later rendered by React.\n    flightResponse: flightResponsePromise,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream<T>(\n  flightStream: ReadableStream<Uint8Array>,\n  requestHeaders: RequestHeaders\n): Promise<T> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createFromNextFetch<T>(\n  promiseForResponse: Promise<Response>,\n  requestHeaders: RequestHeaders\n): Promise<T> & { _debugInfo?: Array<any> } {\n  return createFromFetch(promiseForResponse, {\n    callServer,\n    findSourceMapURL,\n    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","// Utility type. Prefix<[A, B, C, D]> matches [A], [A, B], [A, B, C] etc.\nexport type Prefix<T extends any[]> = T extends [infer First, ...infer Rest]\n  ? [] | [First] | [First, ...Prefix<Rest>]\n  : []\n\nexport type TupleMap<Keypath extends Array<any>, V> = {\n  set(keys: Prefix<Keypath>, value: V): void\n  get(keys: Prefix<Keypath>): V | null\n  delete(keys: Prefix<Keypath>): void\n}\n\n/**\n * Creates a map whose keys are tuples. Tuples are compared per-element. This\n * is useful when a key has multiple parts, but you don't want to concatenate\n * them into a single string value.\n *\n * In the Segment Cache, we use this to store cache entries by both their href\n * and their Next-URL.\n *\n * Example:\n *   map.set(['https://localhost', 'foo/bar/baz'], 'yay');\n *   map.get(['https://localhost', 'foo/bar/baz']); // returns 'yay'\n */\nexport function createTupleMap<Keypath extends Array<any>, V>(): TupleMap<\n  Keypath,\n  V\n> {\n  type MapEntryShared = {\n    parent: MapEntry | null\n    key: any\n    map: Map<any, MapEntry> | null\n  }\n\n  type EmptyMapEntry = MapEntryShared & {\n    value: null\n    hasValue: false\n  }\n\n  type FullMapEntry = MapEntryShared & {\n    value: V\n    hasValue: true\n  }\n\n  type MapEntry = EmptyMapEntry | FullMapEntry\n\n  let rootEntry: MapEntry = {\n    parent: null,\n    key: null,\n    hasValue: false,\n    value: null,\n    map: null,\n  }\n\n  // To optimize successive lookups, we cache the last accessed keypath.\n  // Although it's not encoded in the type, these are both null or\n  // both non-null. It uses object equality, so to take advantage of this\n  // optimization, you must pass the same array instance to each successive\n  // method call, and you must also not mutate the array between calls.\n  let lastAccessedEntry: MapEntry | null = null\n  let lastAccessedKeys: Prefix<Keypath> | null = null\n\n  function getOrCreateEntry(keys: Prefix<Keypath>): MapEntry {\n    if (lastAccessedKeys === keys) {\n      return lastAccessedEntry!\n    }\n\n    // Go through each level of keys until we find the entry that matches,\n    // or create a new one if it doesn't already exist.\n    let entry = rootEntry\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      let map = entry.map\n      if (map !== null) {\n        const existingEntry = map.get(key)\n        if (existingEntry !== undefined) {\n          // Found a match. Keep going.\n          entry = existingEntry\n          continue\n        }\n      } else {\n        map = new Map()\n        entry.map = map\n      }\n      // No entry exists yet at this level. Create a new one.\n      const newEntry: MapEntry = {\n        parent: entry,\n        key,\n        value: null,\n        hasValue: false,\n        map: null,\n      }\n      map.set(key, newEntry)\n      entry = newEntry\n    }\n\n    lastAccessedKeys = keys\n    lastAccessedEntry = entry\n\n    return entry\n  }\n\n  function getEntryIfExists(keys: Prefix<Keypath>): MapEntry | null {\n    if (lastAccessedKeys === keys) {\n      return lastAccessedEntry\n    }\n\n    // Go through each level of keys until we find the entry that matches, or\n    // return null if no match exists.\n    let entry = rootEntry\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n      let map = entry.map\n      if (map !== null) {\n        const existingEntry = map.get(key)\n        if (existingEntry !== undefined) {\n          // Found a match. Keep going.\n          entry = existingEntry\n          continue\n        }\n      }\n      // No entry exists at this level.\n      return null\n    }\n\n    lastAccessedKeys = keys\n    lastAccessedEntry = entry\n\n    return entry\n  }\n\n  function set(keys: Prefix<Keypath>, value: V): void {\n    const entry = getOrCreateEntry(keys)\n    entry.hasValue = true\n    entry.value = value\n  }\n\n  function get(keys: Prefix<Keypath>): V | null {\n    const entry = getEntryIfExists(keys)\n    if (entry === null || !entry.hasValue) {\n      return null\n    }\n    return entry.value\n  }\n\n  function deleteEntry(keys: Prefix<Keypath>): void {\n    const entry = getEntryIfExists(keys)\n    if (entry === null || !entry.hasValue) {\n      return\n    }\n\n    // Found a match. Delete it from the cache.\n    const deletedEntry: EmptyMapEntry = entry as any\n    deletedEntry.hasValue = false\n    deletedEntry.value = null\n\n    // Check if we can garbage collect the entry.\n    if (deletedEntry.map === null) {\n      // Since this entry has no value, and also no child entries, we can\n      // garbage collect it. Remove it from its parent, and keep garbage\n      // collecting the parents until we reach a non-empty entry.\n\n      // Unlike a `set` operation, these are no longer valid because the entry\n      // itself is being modified, not just the value it contains.\n      lastAccessedEntry = null\n      lastAccessedKeys = null\n\n      let parent = deletedEntry.parent\n      let key = deletedEntry.key\n      while (parent !== null) {\n        const parentMap = parent.map\n        if (parentMap !== null) {\n          parentMap.delete(key)\n          if (parentMap.size === 0) {\n            // We just removed the last entry in the parent map.\n            parent.map = null\n            if (parent.value === null) {\n              // The parent node has no child entries, nor does it have a value\n              // on itself. It can be garbage collected. Keep going.\n              key = parent.key\n              parent = parent.parent\n              continue\n            }\n          }\n        }\n        // The parent is not empty. Stop garbage collecting.\n        break\n      }\n    }\n  }\n\n  return {\n    set,\n    get,\n    delete: deleteEntry,\n  }\n}\n","export type LRU<T extends LRUNode> = {\n  put(node: T): void\n  delete(node: T): void\n  updateSize(node: T, size: number): void\n}\n\n// Doubly-linked list\ntype LRUNode<T = any> = {\n  // Although it's not encoded in the type, these are both null if the node is\n  // not in the LRU; both non-null if it is.\n  prev: T | null\n  next: T | null\n  size: number\n}\n\n// Rather than create an internal LRU node, the passed-in type must conform\n// the LRUNode interface. This is just a memory optimization to avoid creating\n// another object; we only use this for Segment Cache entries so it doesn't need\n// to be general purpose.\nexport function createLRU<T extends LRUNode>(\n  // From the LRU's perspective, the size unit is arbitrary, but for our\n  // purposes this is the byte size.\n  maxLruSize: number,\n  onEviction: (node: T) => void\n): LRU<T> {\n  let head: T | null = null\n  let didScheduleCleanup: boolean = false\n  let lruSize: number = 0\n\n  function put(node: T) {\n    if (head === node) {\n      // Already at the head\n      return\n    }\n    const prev = node.prev\n    const next = node.next\n    if (next === null || prev === null) {\n      // This is an insertion\n      lruSize += node.size\n      // Whenever we add an entry, we need to check if we've exceeded the\n      // max size. We don't evict entries immediately; they're evicted later in\n      // an asynchronous task.\n      ensureCleanupIsScheduled()\n    } else {\n      // This is a move. Remove from its current position.\n      prev.next = next\n      next.prev = prev\n    }\n\n    // Move to the front of the list\n    if (head === null) {\n      // This is the first entry\n      node.prev = node\n      node.next = node\n    } else {\n      // Add to the front of the list\n      const tail = head.prev\n      node.prev = tail\n      tail.next = node\n      node.next = head\n      head.prev = node\n    }\n    head = node\n  }\n\n  function updateSize(node: T, newNodeSize: number) {\n    // This is a separate function from `put` so that we can resize the entry\n    // regardless of whether it's currently being tracked by the LRU.\n    const prevNodeSize = node.size\n    node.size = newNodeSize\n    if (node.next === null) {\n      // This entry is not currently being tracked by the LRU.\n      return\n    }\n    // Update the total LRU size\n    lruSize = lruSize - prevNodeSize + newNodeSize\n    ensureCleanupIsScheduled()\n  }\n\n  function deleteNode(deleted: T) {\n    const next = deleted.next\n    const prev = deleted.prev\n    if (next !== null && prev !== null) {\n      lruSize -= deleted.size\n\n      deleted.next = null\n      deleted.prev = null\n\n      // Remove from the list\n      if (head === deleted) {\n        // Update the head\n        if (next === head) {\n          // This was the last entry\n          head = null\n        } else {\n          head = next\n        }\n      } else {\n        prev.next = next\n        next.prev = prev\n      }\n    } else {\n      // Already deleted\n    }\n  }\n\n  function ensureCleanupIsScheduled() {\n    if (didScheduleCleanup || lruSize <= maxLruSize) {\n      return\n    }\n    didScheduleCleanup = true\n    requestCleanupCallback(cleanup)\n  }\n\n  function cleanup() {\n    didScheduleCleanup = false\n\n    // Evict entries until we're at 90% capacity. We can assume this won't\n    // infinite loop because even if `maxLruSize` were 0, eventually\n    // `deleteNode` sets `head` to `null` when we run out entries.\n    const ninetyPercentMax = maxLruSize * 0.9\n    while (lruSize > ninetyPercentMax && head !== null) {\n      const tail = head.prev\n      deleteNode(tail)\n      onEviction(tail)\n    }\n  }\n\n  return {\n    put,\n    delete: deleteNode,\n    updateSize,\n  }\n}\n\nconst requestCleanupCallback =\n  typeof requestIdleCallback === 'function'\n    ? requestIdleCallback\n    : (cb: () => void) => setTimeout(cb, 0)\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\ntype InterceptionRouteInformation = {\n  /**\n   * The intercepting route. This is the route that is being intercepted or the\n   * route that the user was coming from. This is matched by the Next-Url\n   * header.\n   */\n  interceptingRoute: string\n\n  /**\n   * The intercepted route. This is the route that is being intercepted or the\n   * route that the user is going to. This is matched by the request pathname.\n   */\n  interceptedRoute: string\n}\n\nexport function extractInterceptionRouteInformation(\n  path: string\n): InterceptionRouteInformation {\n  let interceptingRoute: string | undefined\n  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n  let interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let previousNextUrl = state.previousNextUrl\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      previousNextUrl = nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: mutable.canonicalUrl ?? state.canonicalUrl,\n    renderedSearch: mutable.renderedSearch ?? state.renderedSearch,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? (mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths)\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n    previousNextUrl: previousNextUrl,\n    debugInfo: mutable.collectedDebugInfo ?? null,\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../shared/lib/app-router-types'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  Mutable,\n  NavigateAction,\n  ReadonlyReducerState,\n  ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\n\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache'\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.renderedSearch = result.data.renderedSearch\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  // Temporary glue code between the router reducer and the new navigation\n  // implementation. Eventually we'll rewrite the router reducer to a\n  // state machine.\n  const currentUrl = new URL(state.canonicalUrl, location.origin)\n  const result = navigateUsingSegmentCache(\n    url,\n    currentUrl,\n    state.cache,\n    state.tree,\n    state.nextUrl,\n    shouldScroll,\n    mutable\n  )\n  return handleNavigationResult(url, state, mutable, pendingPush, result)\n}\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNodeSeedData,\n  DynamicParamTypesShort,\n  Segment as FlightRouterStateSegment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  type RSCResponse,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  isPrefetchTaskDirty,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n  startRevalidationCooldown,\n} from './scheduler'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type {\n  NormalizedHref,\n  NormalizedNextUrl,\n  NormalizedSearch,\n  RouteCacheKey,\n} from './cache-key'\n// TODO: Rename this module to avoid confusion with other types of cache keys\nimport { createCacheKey as createPrefetchRequestKey } from './cache-key'\nimport {\n  doesStaticSegmentAppearInURL,\n  getCacheKeyForDynamicParam,\n  getParamValueFromCacheKey,\n  getRenderedPathname,\n  getRenderedSearch,\n  parseDynamicParamFromURLPart,\n  type RouteParam,\n} from '../../route-params'\nimport { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\nimport { createLRU } from './lru'\nimport {\n  appendSegmentCacheKeyPart,\n  appendSegmentRequestKeyPart,\n  convertSegmentPathToStaticExportFilename,\n  createSegmentCacheKeyPart,\n  createSegmentRequestKeyPart,\n  ROOT_SEGMENT_CACHE_KEY,\n  ROOT_SEGMENT_REQUEST_KEY,\n  type SegmentCacheKey,\n  type SegmentRequestKey,\n} from '../../../shared/lib/segment-cache/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../shared/lib/app-router-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n} from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\nimport { pingVisibleLinks } from '../links'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport {\n  DOC_PREFETCH_RANGE_HEADER_VALUE,\n  doesExportedHtmlMatchBuildId,\n} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\nimport { FetchStrategy } from '../segment-cache'\nimport { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\nexport type RouteTree = {\n  cacheKey: SegmentCacheKey\n  requestKey: SegmentRequestKey\n  // TODO: Remove the `segment` field, now that it can be reconstructed\n  // from `param`.\n  segment: FlightRouterStateSegment\n  param: RouteParam | null\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n\n  // If this is a dynamic route, indicates whether there is a loading boundary\n  // somewhere in the tree. If not, we can skip the prefetch for the data,\n  // because we know it would be an empty response. (For a static/PPR route,\n  // this value is disregarded, because in that model `loading.tsx` is treated\n  // like any other Suspense boundary.)\n  hasLoadingBoundary: HasLoadingBoundary\n\n  // Indicates whether this route has a runtime prefetch that we can request.\n  // This is determined by the server; it's not purely a user configuration\n  // because the server may determine that a route is fully static and doesn't\n  // need runtime prefetching regardless of the configuration.\n  hasRuntimePrefetch: boolean\n}\n\ntype RouteCacheEntryShared = {\n  staleAt: number\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // See comment in scheduler.ts for context\n  TODO_metadataStatus: EntryStatus.Empty | EntryStatus.Fulfilled\n  TODO_isHeadDynamic: boolean\n\n  // LRU-related fields\n  keypath: null | Prefix<RouteCacheKeypath>\n  next: null | RouteCacheEntry\n  prev: null | RouteCacheEntry\n  size: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty = 0,\n  Pending = 1,\n  Fulfilled = 2,\n  Rejected = 3,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  head: HeadData | null\n  isHeadPartial: true\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  renderedSearch: null\n  tree: null\n  head: null\n  isHeadPartial: true\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  renderedSearch: NormalizedSearch\n  tree: RouteTree\n  head: HeadData\n  isHeadPartial: boolean\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\ntype SegmentCacheEntryShared = {\n  staleAt: number\n  fetchStrategy: FetchStrategy\n  revalidating: SegmentCacheEntry | null\n\n  // LRU-related fields\n  keypath: null | Prefix<SegmentCacheKeypath>\n  next: null | SegmentCacheEntry\n  prev: null | SegmentCacheEntry\n  size: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\nconst isOutputExportMode =\n  process.env.NODE_ENV === 'production' &&\n  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n\n/**\n * Ensures a minimum stale time of 30s to avoid issues where the server sends a too\n * short-lived stale time, which would prevent anything from being prefetched.\n */\nfunction getStaleTimeMs(staleTimeSeconds: number): number {\n  return Math.max(staleTimeSeconds, 30) * 1000\n}\n\n// Route cache entries vary on multiple keys: the href and the Next-Url. Each of\n// these parts needs to be included in the internal cache key. Rather than\n// concatenate the keys into a single key, we use a multi-level map, where the\n// first level is keyed by href, the second level is keyed by Next-Url, and so\n// on (if were to add more levels).\ntype RouteCacheKeypath = [NormalizedHref, NormalizedNextUrl]\nlet routeCacheMap: TupleMap<RouteCacheKeypath, RouteCacheEntry> =\n  createTupleMap()\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxRouteLruSize = 10 * 1024 * 1024 // 10 MB\nlet routeCacheLru = createLRU<RouteCacheEntry>(\n  maxRouteLruSize,\n  onRouteLRUEviction\n)\n\ntype SegmentCacheKeypath = [string, NormalizedSearch]\nlet segmentCacheMap: TupleMap<SegmentCacheKeypath, SegmentCacheEntry> =\n  createTupleMap()\n// NOTE: Segments and Route entries are managed by separate LRUs. We could\n// combine them into a single LRU, but because they are separate types, we'd\n// need to wrap each one in an extra LRU node (to maintain monomorphism, at the\n// cost of additional memory).\nconst maxSegmentLruSize = 50 * 1024 * 1024 // 50 MB\nlet segmentCacheLru = createLRU<SegmentCacheEntry>(\n  maxSegmentLruSize,\n  onSegmentLRUEviction\n)\n\n// All invalidation listeners for the whole cache are tracked in single set.\n// Since we don't yet support tag or path-based invalidation, there's no point\n// tracking them any more granularly than this. Once we add granular\n// invalidation, that may change, though generally the model is to just notify\n// the listeners and allow the caller to poll the prefetch cache with a new\n// prefetch task if desired.\nlet invalidationListeners: Set<PrefetchTask> | null = null\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  currentCacheVersion++\n\n  // Start a cooldown before re-prefetching to allow CDN cache propagation.\n  startRevalidationCooldown()\n\n  // Clearing the cache also effectively rejects any pending requests, because\n  // when the response is received, it gets written into a cache entry that is\n  // no longer reachable.\n  // TODO: There's an exception to this case that we don't currently handle\n  // correctly: background revalidations. See note in `upsertSegmentEntry`.\n  routeCacheMap = createTupleMap()\n  routeCacheLru = createLRU(maxRouteLruSize, onRouteLRUEviction)\n  segmentCacheMap = createTupleMap()\n  segmentCacheLru = createLRU(maxSegmentLruSize, onSegmentLRUEviction)\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n\n  // Similarly, notify all invalidation listeners (i.e. those passed to\n  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n  // if needed.\n  pingInvalidationListeners(nextUrl, tree)\n}\n\nfunction attachInvalidationListener(task: PrefetchTask): void {\n  // This function is called whenever a prefetch task reads a cache entry. If\n  // the task has an onInvalidate function associated with it  i.e. the one\n  // optionally passed to router.prefetch(onInvalidate)  then we attach that\n  // listener to the every cache entry that the task reads. Then, if an entry\n  // is invalidated, we call the function.\n  if (task.onInvalidate !== null) {\n    if (invalidationListeners === null) {\n      invalidationListeners = new Set([task])\n    } else {\n      invalidationListeners.add(task)\n    }\n  }\n}\n\nfunction notifyInvalidationListener(task: PrefetchTask): void {\n  const onInvalidate = task.onInvalidate\n  if (onInvalidate !== null) {\n    // Clear the callback from the task object to guarantee it's not called more\n    // than once.\n    task.onInvalidate = null\n\n    // This is a user-space function, so we must wrap in try/catch.\n    try {\n      onInvalidate()\n    } catch (error) {\n      if (typeof reportError === 'function') {\n        reportError(error)\n      } else {\n        console.error(error)\n      }\n    }\n  }\n}\n\nexport function pingInvalidationListeners(\n  nextUrl: string | null,\n  tree: FlightRouterState\n): void {\n  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  if (invalidationListeners !== null) {\n    const tasks = invalidationListeners\n    invalidationListeners = null\n    for (const task of tasks) {\n      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n        notifyInvalidationListener(task)\n      }\n    }\n  }\n}\n\nexport function readExactRouteCacheEntry(\n  now: number,\n  href: NormalizedHref,\n  nextUrl: NormalizedNextUrl | null\n): RouteCacheEntry | null {\n  const keypath: Prefix<RouteCacheKeypath> =\n    nextUrl === null ? [href] : [href, nextUrl]\n  const existingEntry = routeCacheMap.get(keypath)\n  if (existingEntry !== null) {\n    // Check if the entry is stale\n    if (existingEntry.staleAt > now) {\n      // Reuse the existing entry.\n\n      // Since this is an access, move the entry to the front of the LRU.\n      routeCacheLru.put(existingEntry)\n\n      return existingEntry\n    } else {\n      // Evict the stale entry from the cache.\n      deleteRouteFromCache(existingEntry, keypath)\n    }\n  }\n  return null\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  // First check if there's a non-intercepted entry. Most routes cannot be\n  // intercepted, so this is the common case.\n  const nonInterceptedEntry = readExactRouteCacheEntry(now, key.href, null)\n  if (nonInterceptedEntry !== null && !nonInterceptedEntry.couldBeIntercepted) {\n    // Found a match, and the route cannot be intercepted. We can reuse it.\n    return nonInterceptedEntry\n  }\n  // There was no match. Check again but include the Next-Url this time.\n  return readExactRouteCacheEntry(now, key.href, key.nextUrl)\n}\n\nexport function getSegmentKeypath(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  cacheKey: SegmentCacheKey\n): Prefix<SegmentCacheKeypath> {\n  // When a prefetch includes dynamic data, the search params are included\n  // in the result, so we must include the search string in the segment\n  // cache key. (Note that this is true even if the search string is empty.)\n  //\n  // If we're fetching using PPR, we do not need to include the search params in\n  // the cache key, because the search params are treated as dynamic data. The\n  // cache entry is valid for all possible search param values.\n  const isDynamic =\n    fetchStrategy === FetchStrategy.Full ||\n    fetchStrategy === FetchStrategy.PPRRuntime ||\n    !route.isPPREnabled\n  return isDynamic && cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)\n    ? [cacheKey, route.renderedSearch]\n    : [cacheKey]\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  cacheKey: SegmentCacheKey\n): SegmentCacheEntry | null {\n  if (!cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)) {\n    // Fast path. Search params only exist on page segments.\n    return readExactSegmentCacheEntry(now, [cacheKey])\n  }\n\n  const renderedSearch = route.renderedSearch\n  if (renderedSearch !== null) {\n    // Page segments may or may not contain search params. If they were prefetched\n    // using a dynamic request, then we will have an entry with search params.\n    // Check for that case first.\n    const entryWithSearchParams = readExactSegmentCacheEntry(now, [\n      cacheKey,\n      renderedSearch,\n    ])\n    if (entryWithSearchParams !== null) {\n      return entryWithSearchParams\n    }\n  }\n\n  // If we did not find an entry with the given search params, check for a\n  // \"fallback\" entry, where the search params are treated as dynamic data. This\n  // is the common case because PPR/static prerenders always treat search params\n  // as dynamic.\n  //\n  // See corresponding logic in `getSegmentKeypath`.\n  const entryWithoutSearchParams = readExactSegmentCacheEntry(now, [cacheKey])\n  return entryWithoutSearchParams\n}\n\nfunction readExactSegmentCacheEntry(\n  now: number,\n  keypath: Prefix<SegmentCacheKeypath>\n): SegmentCacheEntry | null {\n  const existingEntry = segmentCacheMap.get(keypath)\n  if (existingEntry !== null) {\n    // Check if the entry is stale\n    if (existingEntry.staleAt > now) {\n      // Reuse the existing entry.\n\n      // Since this is an access, move the entry to the front of the LRU.\n      segmentCacheLru.put(existingEntry)\n\n      return existingEntry\n    } else {\n      // This is a stale entry.\n      const revalidatingEntry = existingEntry.revalidating\n      if (revalidatingEntry !== null) {\n        // There's a revalidation in progress. Upsert it.\n        const upsertedEntry = upsertSegmentEntry(\n          now,\n          keypath,\n          revalidatingEntry\n        )\n        if (upsertedEntry !== null && upsertedEntry.staleAt > now) {\n          // We can use the upserted revalidation entry.\n          return upsertedEntry\n        }\n      } else {\n        // Evict the stale entry from the cache.\n        deleteSegmentFromCache(existingEntry, keypath)\n      }\n    }\n  }\n  return null\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  owner: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  const existingRevalidation = owner.revalidating\n  if (existingRevalidation !== null) {\n    if (existingRevalidation.staleAt > now) {\n      // There's already a revalidation in progress. Or a previous revalidation\n      // failed and it has not yet expired.\n      return existingRevalidation\n    } else {\n      // Clear the stale revalidation from its owner.\n      clearRevalidatingSegmentFromOwner(owner)\n    }\n  }\n  return null\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): RouteCacheEntry {\n  attachInvalidationListener(task)\n\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    head: null,\n    isHeadPartial: true,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n    renderedSearch: null,\n\n    TODO_metadataStatus: EntryStatus.Empty,\n    TODO_isHeadDynamic: false,\n\n    // LRU-related fields\n    keypath: null,\n    next: null,\n    prev: null,\n    size: 0,\n  }\n  const keypath: Prefix<RouteCacheKeypath> =\n    key.nextUrl === null ? [key.href] : [key.href, key.nextUrl]\n  routeCacheMap.set(keypath, pendingEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  pendingEntry.keypath = keypath\n  routeCacheLru.put(pendingEntry)\n  return pendingEntry\n}\n\nexport function requestOptimisticRouteCacheEntry(\n  now: number,\n  requestedUrl: URL,\n  nextUrl: string | null\n): FulfilledRouteCacheEntry | null {\n  // This function is called during a navigation when there was no matching\n  // route tree in the prefetch cache. Before de-opting to a blocking,\n  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n  // route tree by checking the cache for similar routes.\n  //\n  // Check if there's a route with the same pathname, but with different\n  // search params. We can then base our optimistic route tree on this entry.\n  //\n  // Conceptually, we are simulating what would happen if we did perform a\n  // prefetch the requested URL, under the assumption that the server will\n  // not redirect or rewrite the request in a different manner than the\n  // base route tree. This assumption might not hold, in which case we'll have\n  // to recover when we perform the dynamic navigation request. However, this\n  // is what would happen if a route were dynamically rewritten/redirected\n  // in between the prefetch and the navigation. So the logic needs to exist\n  // to handle this case regardless.\n\n  // Look for a route with the same pathname, but with an empty search string.\n  // TODO: There's nothing inherently special about the empty search string;\n  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n  // likely one to exist. But we should update this to match _any_ search\n  // string. The plan is to generalize this logic alongside other improvements\n  // related to \"fallback\" cache entries.\n  const requestedSearch = requestedUrl.search as NormalizedSearch\n  if (requestedSearch === '') {\n    // The caller would have already checked if a route with an empty search\n    // string is in the cache. So we can bail out here.\n    return null\n  }\n  const urlWithoutSearchParams = new URL(requestedUrl)\n  urlWithoutSearchParams.search = ''\n  const routeWithNoSearchParams = readRouteCacheEntry(\n    now,\n    createPrefetchRequestKey(urlWithoutSearchParams.href, nextUrl)\n  )\n\n  if (\n    routeWithNoSearchParams === null ||\n    routeWithNoSearchParams.status !== EntryStatus.Fulfilled\n  ) {\n    // Bail out of constructing an optimistic route tree. This will result in\n    // a blocking, unprefetched navigation.\n    return null\n  }\n\n  // Now we have a base route tree we can \"patch\" with our optimistic values.\n\n  const TODO_isHeadDynamic = routeWithNoSearchParams.TODO_isHeadDynamic\n  let head\n  let isHeadPartial\n  let TODO_metadataStatus: EntryStatus.Empty | EntryStatus.Fulfilled\n  if (TODO_isHeadDynamic) {\n    // If the head was fetched via dynamic request, then we don't know\n    // whether it accessed search params. So we must be conservative  we\n    // cannot reuse it. The head will stream in during the dynamic navigation.\n    // TODO: When Cache Components is enabled, we should track whether the\n    // head varied on search params.\n    // TODO: Because we're rendering a `null` viewport as the partial state, the\n    // viewport will not block the navigation; it will stream in later,\n    // alongside the metadata. Viewport is supposed to be blocking. This is\n    // a subtle bug in the old implementation that we've preserved here. It's\n    // rare enough that we're not going to fix it for apps that don't enable\n    // Cache Components; when Cache Components is enabled, though, we should\n    // use an infinite promise here to block the navigation. But only if the\n    // entry actually varies on search params.\n    head = [null, null]\n    // Setting this to `true` ensures that on navigation, the head is requested.\n    isHeadPartial = true\n    TODO_metadataStatus = EntryStatus.Empty\n  } else {\n    // The head was fetched via a static/PPR request. So it's guaranteed to\n    // not contain search params. We can reuse it.\n    head = routeWithNoSearchParams.head\n    isHeadPartial = routeWithNoSearchParams.isHeadPartial\n    TODO_metadataStatus = EntryStatus.Empty\n  }\n\n  // Optimistically assume that redirects for the requested pathname do\n  // not vary on the search string. Therefore, if the base route was\n  // redirected to a different search string, then the optimistic route\n  // should be redirected to the same search string. Otherwise, we use\n  // the requested search string.\n  const canonicalUrlForRouteWithNoSearchParams = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    requestedUrl.origin\n  )\n  const optimisticCanonicalSearch =\n    canonicalUrlForRouteWithNoSearchParams.search !== ''\n      ? // Base route was redirected. Reuse the same redirected search string.\n        canonicalUrlForRouteWithNoSearchParams.search\n      : requestedSearch\n\n  // Similarly, optimistically assume that rewrites for the requested\n  // pathname do not vary on the search string. Therefore, if the base\n  // route was rewritten to a different search string, then the optimistic\n  // route should be rewritten to the same search string. Otherwise, we use\n  // the requested search string.\n  const optimisticRenderedSearch =\n    routeWithNoSearchParams.renderedSearch !== ''\n      ? // Base route was rewritten. Reuse the same rewritten search string.\n        routeWithNoSearchParams.renderedSearch\n      : requestedSearch\n\n  const optimisticUrl = new URL(\n    routeWithNoSearchParams.canonicalUrl,\n    location.origin\n  )\n  optimisticUrl.search = optimisticCanonicalSearch\n  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n\n  // Clone the base route tree, and override the relevant fields with our\n  // optimistic values.\n  const optimisticEntry: FulfilledRouteCacheEntry = {\n    canonicalUrl: optimisticCanonicalUrl,\n\n    status: EntryStatus.Fulfilled,\n    // This isn't cloned because it's instance-specific\n    blockedTasks: null,\n    tree: routeWithNoSearchParams.tree,\n    head,\n    isHeadPartial,\n    staleAt: routeWithNoSearchParams.staleAt,\n    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n\n    // Override the rendered search with the optimistic value.\n    renderedSearch: optimisticRenderedSearch,\n\n    TODO_metadataStatus,\n    TODO_isHeadDynamic,\n\n    // LRU-related fields\n    keypath: null,\n    next: null,\n    prev: null,\n    size: 0,\n  }\n\n  // Do not insert this entry into the cache. It only exists so we can\n  // perform the current navigation. Just return it to the caller.\n  return optimisticEntry\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  cacheKey: SegmentCacheKey\n): SegmentCacheEntry {\n  const keypath = getSegmentKeypath(fetchStrategy, route, cacheKey)\n  const existingEntry = readExactSegmentCacheEntry(now, keypath)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  segmentCacheMap.set(keypath, pendingEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  pendingEntry.keypath = keypath\n  segmentCacheLru.put(pendingEntry)\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  prevEntry: SegmentCacheEntry\n): SegmentCacheEntry {\n  const existingRevalidation = readRevalidatingSegmentCacheEntry(now, prevEntry)\n  if (existingRevalidation !== null) {\n    return existingRevalidation\n  }\n  const pendingEntry = createDetachedSegmentCacheEntry(prevEntry.staleAt)\n\n  // Background revalidations are not stored directly in the cache map or LRU;\n  // they're stashed on the entry that they will (potentially) replace.\n  //\n  // Note that we don't actually ever clear this field, except when the entry\n  // expires. When the revalidation finishes, one of two things will happen:\n  //\n  //  1) the revalidation is successful, `prevEntry` is removed from the cache\n  //     and garbage collected (so there's no point clearing any of its fields)\n  //  2) the revalidation fails, and we'll use the `revalidating` field to\n  //     prevent subsequent revalidation attempts, until it expires.\n  prevEntry.revalidating = pendingEntry\n\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  keypath: Prefix<SegmentCacheKeypath>,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n  const existingEntry = readExactSegmentCacheEntry(now, keypath)\n  if (existingEntry !== null) {\n    // Don't replace a more specific segment with a less-specific one. A case where this\n    // might happen is if the existing segment was fetched via\n    // `<Link prefetch={true}>`.\n    if (\n      // We fetched the new segment using a different, less specific fetch strategy\n      // than the segment we already have in the cache, so it can't have more content.\n      (candidateEntry.fetchStrategy !== existingEntry.fetchStrategy &&\n        !canNewFetchStrategyProvideMoreContent(\n          existingEntry.fetchStrategy,\n          candidateEntry.fetchStrategy\n        )) ||\n      // The existing entry isn't partial, but the new one is.\n      // (TODO: can this be true if `candidateEntry.fetchStrategy >= existingEntry.fetchStrategy`?)\n      (!existingEntry.isPartial && candidateEntry.isPartial)\n    ) {\n      // We're going to leave the entry on the owner's `revalidating` field\n      // so that it doesn't get revalidated again unnecessarily. Downgrade the\n      // Fulfilled entry to Rejected and null out the data so it can be garbage\n      // collected. We leave `staleAt` intact to prevent subsequent revalidation\n      // attempts only until the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n\n    // Evict the existing entry from the cache.\n    deleteSegmentFromCache(existingEntry, keypath)\n  }\n  segmentCacheMap.set(keypath, candidateEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  candidateEntry.keypath = keypath\n  segmentCacheLru.put(candidateEntry)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    revalidating: null,\n    rsc: null,\n    loading: null,\n    staleAt,\n    isPartial: true,\n    promise: null,\n\n    // LRU-related fields\n    keypath: null,\n    next: null,\n    prev: null,\n    size: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n  return pendingEntry\n}\n\nfunction deleteRouteFromCache(\n  entry: RouteCacheEntry,\n  keypath: Prefix<RouteCacheKeypath>\n): void {\n  pingBlockedTasks(entry)\n  routeCacheMap.delete(keypath)\n  routeCacheLru.delete(entry)\n}\n\nfunction deleteSegmentFromCache(\n  entry: SegmentCacheEntry,\n  keypath: Prefix<SegmentCacheKeypath>\n): void {\n  cancelEntryListeners(entry)\n  segmentCacheMap.delete(keypath)\n  segmentCacheLru.delete(entry)\n  clearRevalidatingSegmentFromOwner(entry)\n}\n\nfunction clearRevalidatingSegmentFromOwner(owner: SegmentCacheEntry): void {\n  // Revalidating segments are not stored in the cache directly; they're\n  // stored as a field on the entry that they will (potentially) replace. So\n  // to dispose of an existing revalidation, we just need to null out the field\n  // on the owner.\n  const revalidatingSegment = owner.revalidating\n  if (revalidatingSegment !== null) {\n    cancelEntryListeners(revalidatingSegment)\n    owner.revalidating = null\n  }\n}\n\nexport function resetRevalidatingSegmentEntry(\n  owner: SegmentCacheEntry\n): EmptySegmentCacheEntry {\n  clearRevalidatingSegmentFromOwner(owner)\n  const emptyEntry = createDetachedSegmentCacheEntry(owner.staleAt)\n  owner.revalidating = emptyEntry\n  return emptyEntry\n}\n\nfunction onRouteLRUEviction(entry: RouteCacheEntry): void {\n  // The LRU evicted this entry. Remove it from the map.\n  const keypath = entry.keypath\n  if (keypath !== null) {\n    entry.keypath = null\n    pingBlockedTasks(entry)\n    routeCacheMap.delete(keypath)\n  }\n}\n\nfunction onSegmentLRUEviction(entry: SegmentCacheEntry): void {\n  // The LRU evicted this entry. Remove it from the map.\n  const keypath = entry.keypath\n  if (keypath !== null) {\n    entry.keypath = null\n    cancelEntryListeners(entry)\n    segmentCacheMap.delete(keypath)\n  }\n}\n\nfunction cancelEntryListeners(entry: SegmentCacheEntry): void {\n  if (entry.status === EntryStatus.Pending && entry.promise !== null) {\n    // There were listeners for this entry. Resolve them with `null` to indicate\n    // that the prefetch failed. It's up to the listener to decide how to handle\n    // this case.\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  head: HeadData,\n  isHeadPartial: boolean,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  renderedSearch: NormalizedSearch,\n  isPPREnabled: boolean,\n  isHeadDynamic: boolean\n): FulfilledRouteCacheEntry {\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.head = head\n  fulfilledEntry.isHeadPartial = isHeadPartial\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.renderedSearch = renderedSearch\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  fulfilledEntry.TODO_isHeadDynamic = isHeadDynamic\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\nfunction convertRootTreePrefetchToRouteTree(\n  rootTree: RootTreePrefetch,\n  renderedPathname: string\n) {\n  // Remove trailing and leading slashes\n  const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n  const index = 0\n  const rootSegment = ROOT_SEGMENT_CACHE_KEY\n  return convertTreePrefetchToRouteTree(\n    rootTree.tree,\n    rootSegment,\n    null,\n    ROOT_SEGMENT_REQUEST_KEY,\n    ROOT_SEGMENT_CACHE_KEY,\n    pathnameParts,\n    index\n  )\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  segment: FlightRouterStateSegment,\n  param: RouteParam | null,\n  requestKey: SegmentRequestKey,\n  cacheKey: SegmentCacheKey,\n  pathnameParts: Array<string>,\n  pathnamePartsIndex: number\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childParamName = childPrefetch.name\n      const childParamType = childPrefetch.paramType\n      const childServerSentParamKey = childPrefetch.paramKey\n\n      let childDoesAppearInURL: boolean\n      let childParam: RouteParam | null = null\n      let childSegment: FlightRouterStateSegment\n      if (childParamType !== null) {\n        // This segment is parameterized. Get the param from the pathname.\n        const childParamValue = parseDynamicParamFromURLPart(\n          childParamType,\n          pathnameParts,\n          pathnamePartsIndex\n        )\n\n        // Assign a cache key to the segment, based on the param value. In the\n        // pre-Segment Cache implementation, the server computes this and sends\n        // it in the body of the response. In the Segment Cache implementation,\n        // the server sends an empty string and we fill it in here.\n\n        // TODO: We're intentionally not adding the search param to page\n        // segments here; it's tracked separately and added back during a read.\n        // This would clearer if we waited to construct the segment until it's\n        // read from the cache, since that's effectively what we're\n        // doing anyway.\n        const renderedSearch = '' as NormalizedSearch\n        const childParamKey =\n          // The server omits this field from the prefetch response when\n          // cacheComponents is enabled.\n          childServerSentParamKey !== null\n            ? childServerSentParamKey\n            : // If no param key was sent, use the value parsed on the client.\n              getCacheKeyForDynamicParam(childParamValue, renderedSearch)\n\n        childParam = {\n          name: childParamName,\n          value: childParamValue,\n          type: childParamType,\n        }\n        childSegment = [childParamName, childParamKey, childParamType]\n        childDoesAppearInURL = true\n      } else {\n        childSegment = childParamName\n        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n      }\n\n      // Only increment the index if the segment appears in the URL. If it's a\n      // \"virtual\" segment, like a route group, it remains the same.\n      const childPathnamePartsIndex = childDoesAppearInURL\n        ? pathnamePartsIndex + 1\n        : pathnamePartsIndex\n\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      const childCacheKey = appendSegmentCacheKeyPart(\n        cacheKey,\n        parallelRouteKey,\n        createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childSegment,\n        childParam,\n        childRequestKey,\n        childCacheKey,\n        pathnameParts,\n        childPathnamePartsIndex\n      )\n    }\n  }\n\n  return {\n    cacheKey,\n    requestKey,\n    segment,\n    param,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n    // This field is only relevant to dynamic routes. For a PPR/static route,\n    // there's always some partial loading state we can fetch.\n    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n    hasRuntimePrefetch: prefetch.hasRuntimePrefetch,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_CACHE_KEY,\n    ROOT_SEGMENT_REQUEST_KEY\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  cacheKey: SegmentCacheKey,\n  requestKey: SegmentRequestKey\n): RouteTree {\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n    const childRequestKey = appendSegmentRequestKeyPart(\n      requestKey,\n      parallelRouteKey,\n      childRequestKeyPart\n    )\n    const childCacheKey = appendSegmentCacheKeyPart(\n      cacheKey,\n      parallelRouteKey,\n      createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childCacheKey,\n      childRequestKey\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n  const originalSegment = flightRouterState[0]\n\n  let segment: FlightRouterStateSegment\n  let param: RouteParam | null = null\n  if (Array.isArray(originalSegment)) {\n    const paramCacheKey = originalSegment[1]\n    const paramType = originalSegment[2]\n    const paramValue = getParamValueFromCacheKey(paramCacheKey, paramType)\n    param = {\n      name: originalSegment[0],\n      value: paramValue === undefined ? null : paramValue,\n      type: originalSegment[2] as DynamicParamTypesShort,\n    }\n    segment = originalSegment\n  } else {\n    // The navigation implementation expects the search params to be included\n    // in the segment. However, in the case of a static response, the search\n    // params are omitted. So the client needs to add them back in when reading\n    // from the Segment Cache.\n    //\n    // For consistency, we'll do this for dynamic responses, too.\n    //\n    // TODO: We should move search params out of FlightRouterState and handle\n    // them entirely on the client, similar to our plan for dynamic params.\n    segment =\n      typeof originalSegment === 'string' &&\n      originalSegment.startsWith(PAGE_SEGMENT_KEY)\n        ? PAGE_SEGMENT_KEY\n        : originalSegment\n  }\n\n  return {\n    cacheKey,\n    requestKey,\n    segment,\n    param,\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n    hasLoadingBoundary:\n      flightRouterState[5] !== undefined\n        ? flightRouterState[5]\n        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n\n    // Non-static tree responses are only used by apps that haven't adopted\n    // Cache Components. So this is always false.\n    hasRuntimePrefetch: false,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask,\n  key: RouteCacheKey\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const href = key.href\n  const nextUrl = key.nextUrl\n  const segmentPath = '/_tree' as SegmentRequestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    let response\n    let urlAfterRedirects\n    if (isOutputExportMode) {\n      // In output: \"export\" mode, we can't use headers to request a particular\n      // segment. Instead, we encode the extra request information into the URL.\n      // This is not part of the \"public\" interface of the app; it's an internal\n      // Next.js implementation detail that the app developer should not need to\n      // concern themselves with.\n      //\n      // For example, to request a segment:\n      //\n      //   Path passed to <Link>:   /path/to/page\n      //   Path passed to fetch:    /path/to/page/__next-segments/_tree\n      //\n      //   (This is not the exact protocol, just an illustration.)\n      //\n      // Before we do that, though, we need to account for redirects. Even in\n      // output: \"export\" mode, a proxy might redirect the page to a different\n      // location, but we shouldn't assume or expect that they also redirect all\n      // the segment files, too.\n      //\n      // To check whether the page is redirected, we perform a range request of\n      // the first N bytes of the HTML document. The canonical URL is determined\n      // from the response.\n      //\n      // Then we can use the canonical URL to request the route tree.\n      //\n      // NOTE: We could embed the route tree into the HTML document, to avoid\n      // a second request. We're not doing that currently because it would make\n      // the HTML document larger and affect normal page loads.\n      const url = new URL(href)\n      const htmlResponse = await fetch(href, {\n        headers: {\n          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n        },\n      })\n      const partialHtml = await htmlResponse.text()\n      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n        // The target page is not part of this app, or it belongs to a\n        // different build.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n      urlAfterRedirects = htmlResponse.redirected\n        ? new URL(htmlResponse.url)\n        : url\n      response = await fetchPrefetchResponse(\n        addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n        headers\n      )\n    } else {\n      // \"Server\" mode. We can use request headers instead of the pathname.\n      // TODO: The eventual plan is to get rid of our custom request headers and\n      // encode everything into the URL, using a similar strategy to the\n      // \"output: export\" block above.\n      const url = new URL(href)\n      response = await fetchPrefetchResponse(url, headers)\n      urlAfterRedirects =\n        response !== null && response.redirected ? new URL(response.url) : url\n    }\n\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // TODO: The canonical URL is the href without the origin. I think\n    // historically the reason for this is because the initial canonical URL\n    // gets passed as a prop to the top-level React component, which means it\n    // needs to be computed during SSR. If it were to include the origin, it\n    // would need to always be same as location.origin on the client, to prevent\n    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n    //\n    // However, since this is neither a native URL object nor a fully qualified\n    // URL string, we need to be careful about how we use it. To prevent subtle\n    // mistakes, we should create a special type for it, instead of just string.\n    // Or, we should just use a (readonly) URL object instead. The type of the\n    // prop that we pass to seed the initial state does not need to be the same\n    // type as the state itself.\n    const canonicalUrl = createHrefFromUrl(urlAfterRedirects)\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n      // In output: \"export\" mode, we can't rely on response headers. But if we\n      // receive a well-formed response, we can assume it's a static response,\n      // because all data is static in this mode.\n      isOutputExportMode\n\n    // Regardless of the type of response, we will never receive dynamic\n    // metadata as part of this prefetch request.\n    const isHeadDynamic = false\n\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          routeCacheLru.updateSize(entry, size)\n        }\n      )\n      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n        prefetchStream,\n        headers\n      )\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      // Get the params that were used to render the target page. These may\n      // be different from the params in the request URL, if the page\n      // was rewritten.\n      const renderedPathname = getRenderedPathname(response)\n      const renderedSearch = getRenderedSearch(response)\n\n      const routeTree = convertRootTreePrefetchToRouteTree(\n        serverData,\n        renderedPathname\n      )\n\n      const staleTimeMs = getStaleTimeMs(serverData.staleTime)\n      fulfillRouteCacheEntry(\n        entry,\n        routeTree,\n        serverData.head,\n        serverData.isHeadPartial,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        renderedSearch,\n        routeIsPPREnabled,\n        isHeadDynamic\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          routeCacheLru.updateSize(entry, size)\n        }\n      )\n      const serverData =\n        await createFromNextReadableStream<NavigationFlightResponse>(\n          prefetchStream,\n          headers\n        )\n      if (serverData.b !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        // TODO: We should cache the fact that this is an MPA navigation.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        task,\n        // The non-PPR response format is what we'd get if we prefetched these segments\n        // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n        FetchStrategy.LoadingBoundary,\n        response as RSCResponse<NavigationFlightResponse>,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted && nextUrl !== null) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n      //\n      // Re-key the entry. Since we're in an async task, we must first confirm\n      // that the entry hasn't been concurrently modified by a different task.\n      const currentKeypath: Prefix<RouteCacheKeypath> = [href, nextUrl]\n      const expectedEntry = routeCacheMap.get(currentKeypath)\n      if (expectedEntry === entry) {\n        routeCacheMap.delete(currentKeypath)\n        const newKeypath: Prefix<RouteCacheKeypath> = [href]\n        routeCacheMap.set(newKeypath, entry)\n        // We don't need to update the LRU because the entry is already in it.\n        // But since we changed the keypath, we do need to update that, so we\n        // know how to remove it from the map if it gets evicted from the LRU.\n        entry.keypath = newKeypath\n      } else {\n        // Something else modified this entry already. Since the re-keying is\n        // just a performance optimization, we can safely skip it.\n      }\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n\n  // Use the canonical URL to request the segment, not the original URL. These\n  // are usually the same, but the canonical URL will be different if the route\n  // tree response was redirected. To avoid an extra waterfall on every segment\n  // request, we pass the redirected URL instead of the original one.\n  const url = new URL(route.canonicalUrl, routeKey.href)\n  const nextUrl = routeKey.nextUrl\n\n  const requestKey = tree.requestKey\n  const normalizedRequestKey =\n    requestKey === ROOT_SEGMENT_REQUEST_KEY\n      ? // The root segment is a special case. To simplify the server-side\n        // handling of these requests, we encode the root segment path as\n        // `_index` instead of as an empty string. This should be treated as\n        // an implementation detail and not as a stable part of the protocol.\n        // It just needs to match the equivalent logic that happens when\n        // prerendering the responses. It should not leak outside of Next.js.\n        ('/_index' as SegmentRequestKey)\n      : requestKey\n\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const requestUrl = isOutputExportMode\n    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n    : url\n  try {\n    const response = await fetchPrefetchResponse(requestUrl, headers)\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n        // In output: \"export\" mode, we can't rely on response headers. But if\n        // we receive a well-formed response, we can assume it's a static\n        // response, because all data is static in this mode.\n        !isOutputExportMode) ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        segmentCacheLru.updateSize(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const url = new URL(route.canonicalUrl, task.key.href)\n  const nextUrl = task.key.nextUrl\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]:\n      prepareFlightRouterStateForRequest(dynamicRequestTree),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  switch (fetchStrategy) {\n    case FetchStrategy.Full: {\n      // We omit the prefetch header from a full prefetch because it's essentially\n      // just a navigation request that happens ahead of time  it should include\n      // all the same data in the response.\n      break\n    }\n    case FetchStrategy.PPRRuntime: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '2'\n      break\n    }\n    case FetchStrategy.LoadingBoundary: {\n      headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n      break\n    }\n    default: {\n      fetchStrategy satisfies never\n    }\n  }\n\n  try {\n    const response = await fetchPrefetchResponse(url, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    const renderedSearch = getRenderedSearch(response)\n    if (renderedSearch !== route.renderedSearch) {\n      // The search params that were used to render the target page are\n      // different from the search params in the request URL. This only happens\n      // when there's a dynamic rewrite in between the tree prefetch and the\n      // data prefetch.\n      // TODO: For now, since this is an edge case, we reject the prefetch, but\n      // the proper way to handle this is to evict the stale route tree entry\n      // then fill the cache with the new response.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          segmentCacheLru.updateSize(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream,\n      headers\n    ) as Promise<NavigationFlightResponse>)\n\n    const isResponsePartial =\n      fetchStrategy === FetchStrategy.PPRRuntime\n        ? // A runtime prefetch may have holes.\n          !!response.headers.get(NEXT_DID_POSTPONE_HEADER)\n        : // Full and LoadingBoundary prefetches cannot have holes.\n          // (even if we did set the prefetch header, we only use this codepath for non-PPR-enabled routes)\n          false\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      task,\n      fetchStrategy,\n      response as RSCResponse<NavigationFlightResponse>,\n      serverData,\n      isResponsePartial,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  // Get the URL that was used to render the target page. This may be different\n  // from the URL in the request URL, if the page was rewritten.\n  const renderedSearch = getRenderedSearch(response)\n\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // TODO: Extract to function\n  const staleTimeHeaderSeconds = response.headers.get(\n    NEXT_ROUTER_STALE_TIME_HEADER\n  )\n  const staleTimeMs =\n    staleTimeHeaderSeconds !== null\n      ? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))\n      : STATIC_STALETIME_MS\n\n  // If the response contains dynamic holes, then we must conservatively assume\n  // that any individual segment might contain dynamic holes, and also the\n  // head. If it did not contain dynamic holes, then we can assume every segment\n  // and the head is completely static.\n  const isResponsePartial =\n    response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n\n  // Since this is a dynamic response, we must conservatively assume that the\n  // head responded with dynamic data.\n  const isHeadDynamic = true\n\n  const fulfilledEntry = fulfillRouteCacheEntry(\n    entry,\n    convertRootFlightRouterStateToRouteTree(flightRouterState),\n    flightData.head,\n    flightData.isHeadPartial,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    renderedSearch,\n    routeIsPPREnabled,\n    isHeadDynamic\n  )\n\n  // If the server sent segment data as part of the response, we should write\n  // it into the cache to prevent a second, redundant prefetch request.\n  //\n  // TODO: When `clientSegmentCache` is enabled, the server does not include\n  // segment data when responding to a route tree prefetch request. However,\n  // when `clientSegmentCache` is set to \"client-only\", and PPR is enabled (or\n  // the page is fully static), the normal check is bypassed and the server\n  // responds with the full page. This is a temporary situation until we can\n  // remove the \"client-only\" option. Then, we can delete this function call.\n  writeDynamicRenderResponseIntoCache(\n    now,\n    task,\n    fetchStrategy,\n    response,\n    serverData,\n    isResponsePartial,\n    fulfilledEntry,\n    null\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<SegmentCacheKey, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  response: RSCResponse<NavigationFlightResponse>,\n  serverData: NavigationFlightResponse,\n  isResponsePartial: boolean,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry> | null\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    if (spawnedEntries !== null) {\n      rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    }\n    return null\n  }\n\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n\n  const staleTimeHeaderSeconds = response.headers.get(\n    NEXT_ROUTER_STALE_TIME_HEADER\n  )\n  const staleTimeMs =\n    staleTimeHeaderSeconds !== null\n      ? getStaleTimeMs(parseInt(staleTimeHeaderSeconds, 10))\n      : STATIC_STALETIME_MS\n  const staleAt = now + staleTimeMs\n\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let requestKey = ROOT_SEGMENT_REQUEST_KEY\n      let cacheKey = ROOT_SEGMENT_CACHE_KEY\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        const segment: FlightRouterStateSegment = segmentPath[i + 1]\n        const requestKeyPart = createSegmentRequestKeyPart(segment)\n        requestKey = appendSegmentRequestKeyPart(\n          requestKey,\n          parallelRouteKey,\n          requestKeyPart\n        )\n        cacheKey = appendSegmentCacheKeyPart(\n          cacheKey,\n          parallelRouteKey,\n          createSegmentCacheKeyPart(requestKeyPart, segment)\n        )\n      }\n\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        staleAt,\n        flightData.tree,\n        seedData,\n        isResponsePartial,\n        cacheKey,\n        requestKey,\n        spawnedEntries\n      )\n    }\n\n    // During a dynamic request, the server sends back new head data for the\n    // page. Overwrite the existing head with the new one. Note that we're\n    // intentionally not taking into account whether the existing head is\n    // already complete, even though the incoming head might not have finished\n    // streaming in yet. This is to prioritize consistency of the head with\n    // the segment data (though it's still not a guarantee, since some of the\n    // segment data may be reused from a previous request).\n    route.head = flightData.head\n    route.isHeadPartial = flightData.isHeadPartial\n    route.TODO_isHeadDynamic = true\n\n    // TODO: Currently the stale time of the route tree represents the\n    // stale time of both the route tree *and* all the segment data. So we\n    // can't just overwrite this field; we have to use whichever value is\n    // lower. In the future, though, the plan is to track segment lifetimes\n    // separately from the route tree lifetime.\n    if (staleAt < route.staleAt) {\n      route.staleAt = staleAt\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  if (spawnedEntries !== null) {\n    const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n      spawnedEntries,\n      now + 10 * 1000\n    )\n    return fulfilledEntries\n  }\n  return null\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  task: PrefetchTask,\n  fetchStrategy:\n    | FetchStrategy.LoadingBoundary\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.Full,\n  route: FulfilledRouteCacheEntry,\n  staleAt: number,\n  flightRouterState: FlightRouterState,\n  seedData: CacheNodeSeedData,\n  isResponsePartial: boolean,\n  cacheKey: SegmentCacheKey,\n  requestKey: SegmentRequestKey,\n  entriesOwnedByCurrentTask: Map<\n    SegmentCacheKey,\n    PendingSegmentCacheEntry\n  > | null\n) {\n  // This function is used to write the result of a dynamic server request\n  // (CacheNodeSeedData) into the prefetch cache. It's used in cases where we\n  // want to treat a dynamic response as if it were static. The two examples\n  // where this happens are <Link prefetch={true}> (which implicitly opts\n  // dynamic data into being static) and when prefetching a PPR-disabled route\n  const rsc = seedData[0]\n  const loading = seedData[2]\n  const isPartial = rsc === null || isResponsePartial\n\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry =\n    entriesOwnedByCurrentTask !== null\n      ? entriesOwnedByCurrentTask.get(cacheKey)\n      : undefined\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n      now,\n      fetchStrategy,\n      route,\n      cacheKey\n    )\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(newEntry, fetchStrategy),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        upgradeToPendingSegment(\n          createDetachedSegmentCacheEntry(staleAt),\n          fetchStrategy\n        ),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(\n        now,\n        getSegmentKeypath(fetchStrategy, route, cacheKey),\n        newEntry\n      )\n    }\n  }\n  // Recursively write the child data into the cache.\n  const flightRouterStateChildren = flightRouterState[1]\n  const seedDataChildren = seedData[1]\n  for (const parallelRouteKey in flightRouterStateChildren) {\n    const childFlightRouterState = flightRouterStateChildren[parallelRouteKey]\n    const childSeedData: CacheNodeSeedData | null | void =\n      seedDataChildren[parallelRouteKey]\n    if (childSeedData !== null && childSeedData !== undefined) {\n      const childSegment = childFlightRouterState[0]\n      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n      const childRequestKey = appendSegmentRequestKeyPart(\n        requestKey,\n        parallelRouteKey,\n        childRequestKeyPart\n      )\n      const childCacheKey = appendSegmentCacheKeyPart(\n        cacheKey,\n        parallelRouteKey,\n        createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n      )\n      writeSeedDataIntoCache(\n        now,\n        task,\n        fetchStrategy,\n        route,\n        staleAt,\n        childFlightRouterState,\n        childSeedData,\n        isResponsePartial,\n        childCacheKey,\n        childRequestKey,\n        entriesOwnedByCurrentTask\n      )\n    }\n  }\n}\n\nasync function fetchPrefetchResponse<T>(\n  url: URL,\n  headers: RequestHeaders\n): Promise<RSCResponse<T> | null> {\n  const fetchPriority = 'low'\n  // When issuing a prefetch request, don't immediately decode the response; we\n  // use the lower level `createFromResponse` API instead because we need to do\n  // some extra processing of the response stream. See\n  // `createPrefetchResponseStream` for more details.\n  const shouldImmediatelyDecode = false\n  const response = await createFetch<T>(\n    url,\n    headers,\n    fetchPriority,\n    shouldImmediatelyDecode\n  )\n  if (!response.ok) {\n    return null\n  }\n\n  // Check the content type\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we relaxed about the content type, since it's\n    // not Next.js that's serving the response. If the status is OK, assume the\n    // response is valid. If it's not a valid response, the Flight client won't\n    // be able to decode it, and we'll treat it as a miss.\n  } else {\n    const contentType = response.headers.get('content-type')\n    const isFlightResponse =\n      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n    if (!isFlightResponse) {\n      return null\n    }\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction addSegmentPathToUrlInOutputExportMode(\n  url: URL,\n  segmentPath: SegmentRequestKey\n): URL {\n  if (isOutputExportMode) {\n    // In output: \"export\" mode, we cannot use a header to encode the segment\n    // path. Instead, we append it to the end of the pathname.\n    const staticUrl = new URL(url)\n    const routeDir = staticUrl.pathname.endsWith('/')\n      ? staticUrl.pathname.slice(0, -1)\n      : staticUrl.pathname\n    const staticExportFilename =\n      convertSegmentPathToStaticExportFilename(segmentPath)\n    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n    return staticUrl\n  }\n  return url\n}\n\n/**\n * Checks whether the new fetch strategy is likely to provide more content than the old one.\n *\n * Generally, when an app uses dynamic data, a \"more specific\" fetch strategy is expected to provide more content:\n * - `LoadingBoundary` only provides static layouts\n * - `PPR` can provide shells for each segment (even for segments that use dynamic data)\n * - `PPRRuntime` can additionally include content that uses searchParams, params, or cookies\n * - `Full` includes all the content, even if it uses dynamic data\n *\n * However, it's possible that a more specific fetch strategy *won't* give us more content if:\n * - a segment is fully static\n *   (then, `PPR`/`PPRRuntime`/`Full` will all yield equivalent results)\n * - providing searchParams/params/cookies doesn't reveal any more content, e.g. because of an `await connection()`\n *   (then, `PPR` and `PPRRuntime` will yield equivalent results, only `Full` will give us more)\n * Because of this, when comparing two segments, we should also check if the existing segment is partial.\n * If it's not partial, then there's no need to prefetch it again, even using a \"more specific\" strategy.\n * There's currently no way to know if `PPRRuntime` will yield more data that `PPR`, so we have to assume it will.\n *\n * Also note that, in practice, we don't expect to be comparing `LoadingBoundary` to `PPR`/`PPRRuntime`,\n * because a non-PPR-enabled route wouldn't ever use the latter strategies. It might however use `Full`.\n */\nexport function canNewFetchStrategyProvideMoreContent(\n  currentStrategy: FetchStrategy,\n  newStrategy: FetchStrategy\n): boolean {\n  return currentStrategy < newStrategy\n}\n","import type {\n  FlightRouterState,\n  Segment as FlightRouterStateSegment,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport { HasLoadingBoundary } from '../../../shared/lib/app-router-types'\nimport { matchSegment } from '../match-segments'\nimport {\n  readOrCreateRouteCacheEntry,\n  readOrCreateSegmentCacheEntry,\n  fetchRouteOnCacheMiss,\n  fetchSegmentOnCacheMiss,\n  EntryStatus,\n  type FulfilledRouteCacheEntry,\n  type RouteCacheEntry,\n  type SegmentCacheEntry,\n  type RouteTree,\n  fetchSegmentPrefetchesUsingDynamicRequest,\n  type PendingSegmentCacheEntry,\n  convertRouteTreeToFlightRouterState,\n  readOrCreateRevalidatingSegmentEntry,\n  upsertSegmentEntry,\n  type FulfilledSegmentCacheEntry,\n  upgradeToPendingSegment,\n  waitForSegmentCacheEntry,\n  resetRevalidatingSegmentEntry,\n  getSegmentKeypath,\n  canNewFetchStrategyProvideMoreContent,\n} from './cache'\nimport type { RouteCacheKey } from './cache-key'\nimport { createCacheKey } from './cache-key'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n  getCurrentCacheVersion,\n  PrefetchPriority,\n} from '../segment-cache'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { SegmentCacheKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n\nconst scheduleMicrotask =\n  typeof queueMicrotask === 'function'\n    ? queueMicrotask\n    : (fn: () => unknown) =>\n        Promise.resolve()\n          .then(fn)\n          .catch((error) =>\n            setTimeout(() => {\n              throw error\n            })\n          )\n\nexport type PrefetchTask = {\n  key: RouteCacheKey\n\n  /**\n   * The FlightRouterState at the time the task was initiated. This is needed\n   * when falling back to the non-PPR behavior, which only prefetches up to\n   * the first loading boundary.\n   */\n  treeAtTimeOfPrefetch: FlightRouterState\n\n  /**\n   * The cache version at the time the task was initiated. This is used to\n   * determine if the cache was invalidated since the task was initiated.\n   */\n  cacheVersion: number\n\n  /**\n   * Whether to prefetch dynamic data, in addition to static data. This is\n   * used by `<Link prefetch={true}>`.\n   *\n   * Note that a task with `FetchStrategy.PPR` might need to use\n   * `FetchStrategy.LoadingBoundary` instead if we find out that a route\n   * does not support PPR after doing the initial route prefetch.\n   */\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  /**\n   * sortId is an incrementing counter\n   *\n   * Newer prefetches are prioritized over older ones, so that as new links\n   * enter the viewport, they are not starved by older links that are no\n   * longer relevant. In the future, we can add additional prioritization\n   * heuristics, like removing prefetches once a link leaves the viewport.\n   *\n   * The sortId is assigned when the prefetch is initiated, and reassigned if\n   * the same task is prefetched again (effectively bumping it to the top of\n   * the queue).\n   *\n   * TODO: We can add additional fields here to indicate what kind of prefetch\n   * it is. For example, was it initiated by a link? Or was it an imperative\n   * call? If it was initiated by a link, we can remove it from the queue when\n   * the link leaves the viewport, but if it was an imperative call, then we\n   * should keep it in the queue until it's fulfilled.\n   *\n   * We can also add priority levels. For example, hovering over a link could\n   * increase the priority of its prefetch.\n   */\n  sortId: number\n\n  /**\n   * The priority of the task. Like sortId, this affects the task's position in\n   * the queue, so it must never be updated without resifting the heap.\n   */\n  priority: PrefetchPriority\n\n  /**\n   * The phase of the task. Tasks are split into multiple phases so that their\n   * priority can be adjusted based on what kind of work they're doing.\n   * Concretely, prefetching the route tree is higher priority than prefetching\n   * segment data.\n   */\n  phase: PrefetchPhase\n\n  /**\n   * These fields are temporary state for tracking the currently running task.\n   * They are reset after each iteration of the task queue.\n   */\n  hasBackgroundWork: boolean\n  spawnedRuntimePrefetches: Set<SegmentCacheKey> | null\n\n  /**\n   * True if the prefetch was cancelled.\n   */\n  isCanceled: boolean\n\n  /**\n   * The callback passed to `router.prefetch`, if given.\n   */\n  onInvalidate: null | (() => void)\n\n  /**\n   * The index of the task in the heap's backing array. Used to efficiently\n   * change the priority of a task by re-sifting it, which requires knowing\n   * where it is in the array. This is only used internally by the heap\n   * algorithm. The naive alternative is indexOf every time a task is queued,\n   * which has O(n) complexity.\n   *\n   * We also use this field to check whether a task is currently in the queue.\n   */\n  _heapIndex: number\n}\n\nconst enum PrefetchTaskExitStatus {\n  /**\n   * The task yielded because there are too many requests in progress.\n   */\n  InProgress,\n\n  /**\n   * The task is blocked. It needs more data before it can proceed.\n   *\n   * Currently the only reason this happens is we're still waiting to receive a\n   * route tree from the server, because we can't start prefetching the segments\n   * until we know what to prefetch.\n   */\n  Blocked,\n\n  /**\n   * There's nothing left to prefetch.\n   */\n  Done,\n}\n\n/**\n * Prefetch tasks are processed in two phases: first the route tree is fetched,\n * then the segments. We use this to priortize tasks that have not yet fetched\n * the route tree.\n */\nconst enum PrefetchPhase {\n  RouteTree = 1,\n  Segments = 0,\n}\n\nexport type PrefetchSubtaskResult<T> = {\n  /**\n   * A promise that resolves when the network connection is closed.\n   */\n  closed: Promise<void>\n  value: T\n}\n\nconst taskHeap: Array<PrefetchTask> = []\n\nlet inProgressRequests = 0\n\nlet sortIdCounter = 0\nlet didScheduleMicrotask = false\n\n// The most recently hovered (or touched, etc) link, i.e. the most recent task\n// scheduled at Intent priority. There's only ever a single task at Intent\n// priority at a time. We reserve special network bandwidth for this task only.\nlet mostRecentlyHoveredLink: PrefetchTask | null = null\n\n// CDN cache propagation delay after revalidation (in milliseconds)\nconst REVALIDATION_COOLDOWN_MS = 300\n\n// Timeout handle for the revalidation cooldown. When non-null, prefetch\n// requests are blocked to allow CDN cache propagation.\nlet revalidationCooldownTimeoutHandle: ReturnType<typeof setTimeout> | null =\n  null\n\n/**\n * Called by the cache when revalidation occurs. Starts a cooldown period\n * during which prefetch requests are blocked to allow CDN cache propagation.\n */\nexport function startRevalidationCooldown(): void {\n  // Clear any existing timeout in case multiple revalidations happen\n  // in quick succession.\n  if (revalidationCooldownTimeoutHandle !== null) {\n    clearTimeout(revalidationCooldownTimeoutHandle)\n  }\n\n  // Schedule the cooldown to expire after the delay.\n  revalidationCooldownTimeoutHandle = setTimeout(() => {\n    revalidationCooldownTimeoutHandle = null\n    // Retry the prefetch queue now that the cooldown has expired.\n    ensureWorkIsScheduled()\n  }, REVALIDATION_COOLDOWN_MS)\n}\n\nexport type IncludeDynamicData = null | 'full' | 'dynamic'\n\n/**\n * Initiates a prefetch task for the given URL. If a prefetch for the same URL\n * is already in progress, this will bump it to the top of the queue.\n *\n * This is not a user-facing function. By the time this is called, the href is\n * expected to be validated and normalized.\n *\n * @param key The RouteCacheKey to prefetch.\n * @param treeAtTimeOfPrefetch The app's current FlightRouterState\n * @param fetchStrategy Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n */\nexport function schedulePrefetchTask(\n  key: RouteCacheKey,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority,\n  onInvalidate: null | (() => void)\n): PrefetchTask {\n  // Spawn a new prefetch task\n  const task: PrefetchTask = {\n    key,\n    treeAtTimeOfPrefetch,\n    cacheVersion: getCurrentCacheVersion(),\n    priority,\n    phase: PrefetchPhase.RouteTree,\n    hasBackgroundWork: false,\n    spawnedRuntimePrefetches: null,\n    fetchStrategy,\n    sortId: sortIdCounter++,\n    isCanceled: false,\n    onInvalidate,\n    _heapIndex: -1,\n  }\n\n  trackMostRecentlyHoveredLink(task)\n\n  heapPush(taskHeap, task)\n\n  // Schedule an async task to process the queue.\n  //\n  // The main reason we process the queue in an async task is for batching.\n  // It's common for a single JS task/event to trigger multiple prefetches.\n  // By deferring to a microtask, we only process the queue once per JS task.\n  // If they have different priorities, it also ensures they are processed in\n  // the optimal order.\n  ensureWorkIsScheduled()\n\n  return task\n}\n\nexport function cancelPrefetchTask(task: PrefetchTask): void {\n  // Remove the prefetch task from the queue. If the task already completed,\n  // then this is a no-op.\n  //\n  // We must also explicitly mark the task as canceled so that a blocked task\n  // does not get added back to the queue when it's pinged by the network.\n  task.isCanceled = true\n  heapDelete(taskHeap, task)\n}\n\nexport function reschedulePrefetchTask(\n  task: PrefetchTask,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  priority: PrefetchPriority\n): void {\n  // Bump the prefetch task to the top of the queue, as if it were a fresh\n  // task. This is essentially the same as canceling the task and scheduling\n  // a new one, except it reuses the original object.\n  //\n  // The primary use case is to increase the priority of a Link-initated\n  // prefetch on hover.\n\n  // Un-cancel the task, in case it was previously canceled.\n  task.isCanceled = false\n  task.phase = PrefetchPhase.RouteTree\n\n  // Assign a new sort ID to move it ahead of all other tasks at the same\n  // priority level. (Higher sort IDs are processed first.)\n  task.sortId = sortIdCounter++\n  task.priority =\n    // If this task is the most recently hovered link, maintain its\n    // Intent priority, even if the rescheduled priority is lower.\n    task === mostRecentlyHoveredLink ? PrefetchPriority.Intent : priority\n\n  task.treeAtTimeOfPrefetch = treeAtTimeOfPrefetch\n  task.fetchStrategy = fetchStrategy\n\n  trackMostRecentlyHoveredLink(task)\n\n  if (task._heapIndex !== -1) {\n    // The task is already in the queue.\n    heapResift(taskHeap, task)\n  } else {\n    heapPush(taskHeap, task)\n  }\n  ensureWorkIsScheduled()\n}\n\nexport function isPrefetchTaskDirty(\n  task: PrefetchTask,\n  nextUrl: string | null,\n  tree: FlightRouterState\n): boolean {\n  // This is used to quickly bail out of a prefetch task if the result is\n  // guaranteed to not have changed since the task was initiated. This is\n  // strictly an optimization  theoretically, if it always returned true, no\n  // behavior should change because a full prefetch task will effectively\n  // perform the same checks.\n  const currentCacheVersion = getCurrentCacheVersion()\n  return (\n    task.cacheVersion !== currentCacheVersion ||\n    task.treeAtTimeOfPrefetch !== tree ||\n    task.key.nextUrl !== nextUrl\n  )\n}\n\nfunction trackMostRecentlyHoveredLink(task: PrefetchTask) {\n  // Track the mostly recently hovered link, i.e. the most recently scheduled\n  // task at Intent priority. There must only be one such task at a time.\n  if (\n    task.priority === PrefetchPriority.Intent &&\n    task !== mostRecentlyHoveredLink\n  ) {\n    if (mostRecentlyHoveredLink !== null) {\n      // Bump the previously hovered link's priority down to Default.\n      if (mostRecentlyHoveredLink.priority !== PrefetchPriority.Background) {\n        mostRecentlyHoveredLink.priority = PrefetchPriority.Default\n        heapResift(taskHeap, mostRecentlyHoveredLink)\n      }\n    }\n    mostRecentlyHoveredLink = task\n  }\n}\n\nfunction ensureWorkIsScheduled() {\n  if (didScheduleMicrotask) {\n    // Already scheduled a task to process the queue\n    return\n  }\n  didScheduleMicrotask = true\n  scheduleMicrotask(processQueueInMicrotask)\n}\n\n/**\n * Checks if we've exceeded the maximum number of concurrent prefetch requests,\n * to avoid saturating the browser's internal network queue. This is a\n * cooperative limit  prefetch tasks should check this before issuing\n * new requests.\n *\n * Also checks if we're within the revalidation cooldown window, during which\n * prefetch requests are delayed to allow CDN cache propagation.\n */\nfunction hasNetworkBandwidth(task: PrefetchTask): boolean {\n  // Check if we're within the revalidation cooldown window\n  if (revalidationCooldownTimeoutHandle !== null) {\n    // We're within the cooldown window. Return false to prevent prefetching.\n    // When the cooldown expires, the timeout will call ensureWorkIsScheduled()\n    // to retry the queue.\n    return false\n  }\n\n  // TODO: Also check if there's an in-progress navigation. We should never\n  // add prefetch requests to the network queue if an actual navigation is\n  // taking place, to ensure there's sufficient bandwidth for render-blocking\n  // data and resources.\n\n  // TODO: Consider reserving some amount of bandwidth for static prefetches.\n\n  if (task.priority === PrefetchPriority.Intent) {\n    // The most recently hovered link is allowed to exceed the default limit.\n    //\n    // The goal is to always have enough bandwidth to start a new prefetch\n    // request when hovering over a link.\n    //\n    // However, because we don't abort in-progress requests, it's still possible\n    // we'll run out of bandwidth. When links are hovered in quick succession,\n    // there could be multiple hover requests running simultaneously.\n    return inProgressRequests < 12\n  }\n\n  // The default limit is lower than the limit for a hovered link.\n  return inProgressRequests < 4\n}\n\nfunction spawnPrefetchSubtask<T>(\n  prefetchSubtask: Promise<PrefetchSubtaskResult<T> | null>\n): Promise<T | null> {\n  // When the scheduler spawns an async task, we don't await its result.\n  // Instead, the async task writes its result directly into the cache, then\n  // pings the scheduler to continue.\n  //\n  // We process server responses streamingly, so the prefetch subtask will\n  // likely resolve before we're finished receiving all the data. The subtask\n  // result includes a promise that resolves once the network connection is\n  // closed. The scheduler uses this to control network bandwidth by tracking\n  // and limiting the number of concurrent requests.\n  inProgressRequests++\n  return prefetchSubtask.then((result) => {\n    if (result === null) {\n      // The prefetch task errored before it could start processing the\n      // network stream. Assume the connection is closed.\n      onPrefetchConnectionClosed()\n      return null\n    }\n    // Wait for the connection to close before freeing up more bandwidth.\n    result.closed.then(onPrefetchConnectionClosed)\n    return result.value\n  })\n}\n\nfunction onPrefetchConnectionClosed(): void {\n  inProgressRequests--\n\n  // Notify the scheduler that we have more bandwidth, and can continue\n  // processing tasks.\n  ensureWorkIsScheduled()\n}\n\n/**\n * Notify the scheduler that we've received new data for an in-progress\n * prefetch. The corresponding task will be added back to the queue (unless the\n * task has been canceled in the meantime).\n */\nexport function pingPrefetchTask(task: PrefetchTask) {\n  // \"Ping\" a prefetch that's already in progress to notify it of new data.\n  if (\n    // Check if prefetch was canceled.\n    task.isCanceled ||\n    // Check if prefetch is already queued.\n    task._heapIndex !== -1\n  ) {\n    return\n  }\n  // Add the task back to the queue.\n  heapPush(taskHeap, task)\n  ensureWorkIsScheduled()\n}\n\nfunction processQueueInMicrotask() {\n  didScheduleMicrotask = false\n\n  // We aim to minimize how often we read the current time. Since nearly all\n  // functions in the prefetch scheduler are synchronous, we can read the time\n  // once and pass it as an argument wherever it's needed.\n  const now = Date.now()\n\n  // Process the task queue until we run out of network bandwidth.\n  let task = heapPeek(taskHeap)\n  while (task !== null && hasNetworkBandwidth(task)) {\n    task.cacheVersion = getCurrentCacheVersion()\n\n    const exitStatus = pingRoute(now, task)\n\n    // These fields are only valid for a single attempt. Reset them after each\n    // iteration of the task queue.\n    const hasBackgroundWork = task.hasBackgroundWork\n    task.hasBackgroundWork = false\n    task.spawnedRuntimePrefetches = null\n\n    switch (exitStatus) {\n      case PrefetchTaskExitStatus.InProgress:\n        // The task yielded because there are too many requests in progress.\n        // Stop processing tasks until we have more bandwidth.\n        return\n      case PrefetchTaskExitStatus.Blocked:\n        // The task is blocked. It needs more data before it can proceed.\n        // Keep the task out of the queue until the server responds.\n        heapPop(taskHeap)\n        // Continue to the next task\n        task = heapPeek(taskHeap)\n        continue\n      case PrefetchTaskExitStatus.Done:\n        if (task.phase === PrefetchPhase.RouteTree) {\n          // Finished prefetching the route tree. Proceed to prefetching\n          // the segments.\n          task.phase = PrefetchPhase.Segments\n          heapResift(taskHeap, task)\n        } else if (hasBackgroundWork) {\n          // The task spawned additional background work. Reschedule the task\n          // at background priority.\n          task.priority = PrefetchPriority.Background\n          heapResift(taskHeap, task)\n        } else {\n          // The prefetch is complete. Continue to the next task.\n          heapPop(taskHeap)\n        }\n        task = heapPeek(taskHeap)\n        continue\n      default:\n        exitStatus satisfies never\n    }\n  }\n}\n\n/**\n * Check this during a prefetch task to determine if background work can be\n * performed. If so, it evaluates to `true`. Otherwise, it returns `false`,\n * while also scheduling a background task to run later. Usage:\n *\n * @example\n * if (background(task)) {\n *   // Perform background-pri work\n * }\n */\nfunction background(task: PrefetchTask): boolean {\n  if (task.priority === PrefetchPriority.Background) {\n    return true\n  }\n  task.hasBackgroundWork = true\n  return false\n}\n\nfunction pingRoute(now: number, task: PrefetchTask): PrefetchTaskExitStatus {\n  const key = task.key\n  const route = readOrCreateRouteCacheEntry(now, task, key)\n  const exitStatus = pingRootRouteTree(now, task, route)\n\n  if (exitStatus !== PrefetchTaskExitStatus.InProgress && key.search !== '') {\n    // If the URL has a non-empty search string, also prefetch the pathname\n    // without the search string. We use the searchless route tree as a base for\n    // optimistic routing; see requestOptimisticRouteCacheEntry for details.\n    //\n    // Note that we don't need to prefetch any of the segment data. Just the\n    // route tree.\n    //\n    // TODO: This is a temporary solution; the plan is to replace this by adding\n    // a wildcard lookup method to the TupleMap implementation. This is\n    // non-trivial to implement because it needs to account for things like\n    // fallback route entries, hence this temporary workaround.\n    const url = new URL(key.href)\n    url.search = ''\n    const keyWithoutSearch = createCacheKey(url.href, key.nextUrl)\n    const routeWithoutSearch = readOrCreateRouteCacheEntry(\n      now,\n      task,\n      keyWithoutSearch\n    )\n    switch (routeWithoutSearch.status) {\n      case EntryStatus.Empty: {\n        if (background(task)) {\n          routeWithoutSearch.status = EntryStatus.Pending\n          spawnPrefetchSubtask(\n            fetchRouteOnCacheMiss(routeWithoutSearch, task, keyWithoutSearch)\n          )\n        }\n        break\n      }\n      case EntryStatus.Pending:\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected: {\n        // Either the route tree is already cached, or there's already a\n        // request in progress. Since we don't need to fetch any segment data\n        // for this route, there's nothing left to do.\n        break\n      }\n      default:\n        routeWithoutSearch satisfies never\n    }\n  }\n\n  return exitStatus\n}\n\nfunction pingRootRouteTree(\n  now: number,\n  task: PrefetchTask,\n  route: RouteCacheEntry\n): PrefetchTaskExitStatus {\n  switch (route.status) {\n    case EntryStatus.Empty: {\n      // Route is not yet cached, and there's no request already in progress.\n      // Spawn a task to request the route, load it into the cache, and ping\n      // the task to continue.\n\n      // TODO: There are multiple strategies in the <Link> API for prefetching\n      // a route. Currently we've only implemented the main one: per-segment,\n      // static-data only.\n      //\n      // There's also `<Link prefetch={true}>`\n      // which prefetch both static *and* dynamic data.\n      // Similarly, we need to fallback to the old, per-page\n      // behavior if PPR is disabled for a route (via the incremental opt-in).\n      //\n      // Those cases will be handled here.\n      spawnPrefetchSubtask(fetchRouteOnCacheMiss(route, task, task.key))\n\n      // If the request takes longer than a minute, a subsequent request should\n      // retry instead of waiting for this one. When the response is received,\n      // this value will be replaced by a new value based on the stale time sent\n      // from the server.\n      // TODO: We should probably also manually abort the fetch task, to reclaim\n      // server bandwidth.\n      route.staleAt = now + 60 * 1000\n\n      // Upgrade to Pending so we know there's already a request in progress\n      route.status = EntryStatus.Pending\n\n      // Intentional fallthrough to the Pending branch\n    }\n    case EntryStatus.Pending: {\n      // Still pending. We can't start prefetching the segments until the route\n      // tree has loaded. Add the task to the set of blocked tasks so that it\n      // is notified when the route tree is ready.\n      const blockedTasks = route.blockedTasks\n      if (blockedTasks === null) {\n        route.blockedTasks = new Set([task])\n      } else {\n        blockedTasks.add(task)\n      }\n      return PrefetchTaskExitStatus.Blocked\n    }\n    case EntryStatus.Rejected: {\n      // Route tree failed to load. Treat as a 404.\n      return PrefetchTaskExitStatus.Done\n    }\n    case EntryStatus.Fulfilled: {\n      if (task.phase !== PrefetchPhase.Segments) {\n        // Do not prefetch segment data until we've entered the segment phase.\n        return PrefetchTaskExitStatus.Done\n      }\n      // Recursively fill in the segment tree.\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const tree = route.tree\n\n      // A task's fetch strategy gets set to `PPR` for any \"auto\" prefetch.\n      // If it turned out that the route isn't PPR-enabled, we need to use `LoadingBoundary` instead.\n      // We don't need to do this for runtime prefetches, because those are only available in\n      // `cacheComponents`, where every route is PPR.\n      const fetchStrategy =\n        task.fetchStrategy === FetchStrategy.PPR\n          ? route.isPPREnabled\n            ? FetchStrategy.PPR\n            : FetchStrategy.LoadingBoundary\n          : task.fetchStrategy\n\n      switch (fetchStrategy) {\n        case FetchStrategy.PPR: {\n          // For Cache Components pages, each segment may be prefetched\n          // statically or using a runtime request, based on various\n          // configurations and heuristics. We'll do this in two passes: first\n          // traverse the tree and perform all the static prefetches.\n          //\n          // Then, if there are any segments that need a runtime request,\n          // do another pass to perform a runtime prefetch.\n          const exitStatus = pingSharedPartOfCacheComponentsTree(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree\n          )\n          if (exitStatus === PrefetchTaskExitStatus.InProgress) {\n            // Child yielded without finishing.\n            return PrefetchTaskExitStatus.InProgress\n          }\n          const spawnedRuntimePrefetches = task.spawnedRuntimePrefetches\n          if (spawnedRuntimePrefetches !== null) {\n            // During the first pass, we discovered segments that require a\n            // runtime prefetch. Do a second pass to construct a request tree.\n            const spawnedEntries = new Map<\n              SegmentCacheKey,\n              PendingSegmentCacheEntry\n            >()\n            const requestTree = pingRuntimePrefetches(\n              now,\n              task,\n              route,\n              tree,\n              spawnedRuntimePrefetches,\n              spawnedEntries\n            )\n            let needsDynamicRequest = spawnedEntries.size > 0\n            if (needsDynamicRequest) {\n              // Perform a dynamic prefetch request and populate the cache with\n              // the result.\n              spawnPrefetchSubtask(\n                fetchSegmentPrefetchesUsingDynamicRequest(\n                  task,\n                  route,\n                  FetchStrategy.PPRRuntime,\n                  requestTree,\n                  spawnedEntries\n                )\n              )\n            }\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        case FetchStrategy.Full:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.LoadingBoundary: {\n          // Prefetch multiple segments using a single dynamic request.\n          // TODO: We can consolidate this branch with previous one by modeling\n          // it as if the first segment in the new tree has runtime prefetching\n          // enabled. Will do this as a follow-up refactor. Might want to remove\n          // the special metatdata case below first. In the meantime, it's not\n          // really that much duplication, just would be nice to remove one of\n          // these codepaths.\n          const spawnedEntries = new Map<\n            SegmentCacheKey,\n            PendingSegmentCacheEntry\n          >()\n          const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n            now,\n            task,\n            route,\n            task.treeAtTimeOfPrefetch,\n            tree,\n            spawnedEntries,\n            fetchStrategy\n          )\n\n          let needsDynamicRequest = spawnedEntries.size > 0\n\n          if (\n            !needsDynamicRequest &&\n            route.isHeadPartial &&\n            route.TODO_metadataStatus === EntryStatus.Empty\n          ) {\n            // All the segment data is already cached, however, we need to issue\n            // a request anyway so we can prefetch the head. Update the status\n            // field to prevent additional requests from being spawned while\n            // this one is in progress.\n            // TODO: This is a temporary, targeted solution to fix a regression\n            // we found. It exists to prevent the scheduler from sending a\n            // redundant request if there's already one in progress.\n            // Essentially, it will attempt once at most, then give up until the\n            // route entry expires or is evicted by other means. But because\n            // this doesn't have its own stale time separate from the route\n            // itself, there will be edge cases where the metadata fails to be\n            // fully prefetched. Consider caching metadata using a separate\n            // entry type so we can model this more cleanly. The circumstances\n            // that lead to this branch running in the first place are\n            // relatively rare, so it's not critical.\n            route.TODO_metadataStatus = EntryStatus.Fulfilled\n            needsDynamicRequest = true\n            // This instructs the server to only send the metadata.\n            dynamicRequestTree[3] = 'metadata-only'\n            // We can null out the children to reduce the request size, since\n            // they won't be needed.\n            dynamicRequestTree[1] = {}\n          }\n\n          if (needsDynamicRequest) {\n            // Perform a dynamic prefetch request and populate the cache with\n            // the result\n            spawnPrefetchSubtask(\n              fetchSegmentPrefetchesUsingDynamicRequest(\n                task,\n                route,\n                fetchStrategy,\n                dynamicRequestTree,\n                spawnedEntries\n              )\n            )\n          }\n          return PrefetchTaskExitStatus.Done\n        }\n        default:\n          fetchStrategy satisfies never\n      }\n      break\n    }\n    default: {\n      route satisfies never\n    }\n  }\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingSharedPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree\n): PrefetchTaskExitStatus {\n  // When Cache Components is enabled (or PPR, or a fully static route when PPR\n  // is disabled; those cases are treated equivalently to Cache Components), we\n  // start by prefetching each segment individually. Once we reach the \"new\"\n  // part of the tree  the part that doesn't exist on the current page  we\n  // may choose to switch to a runtime prefetch instead, based on the\n  // information sent by the server in the route tree.\n  //\n  // The traversal starts in the \"shared\" part of the tree. Once we reach the\n  // \"new\" part of the tree, we switch to a different traversal,\n  // pingNewPartOfCacheComponentsTree.\n\n  // Prefetch this segment's static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    newTree.cacheKey\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, newTree)\n\n  // Recursively ping the children.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      if (!hasNetworkBandwidth(task)) {\n        // Stop prefetching segments until there's more bandwidth.\n        return PrefetchTaskExitStatus.InProgress\n      }\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      let childExitStatus\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // We're still in the \"shared\" part of the tree.\n        childExitStatus = pingSharedPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild\n        )\n      } else {\n        // We've entered the \"new\" part of the tree. Switch\n        // traversal functions.\n        childExitStatus = pingNewPartOfCacheComponentsTree(\n          now,\n          task,\n          route,\n          newTreeChild\n        )\n      }\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction pingNewPartOfCacheComponentsTree(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n  // We're now prefetching in the \"new\" part of the tree, the part that doesn't\n  // exist on the current page. (In other words, we're deeper than the\n  // shared layouts.) Segments in here default to being prefetched statically.\n  // However, if the server instructs us to, we may switch to a runtime\n  // prefetch instead. Traverse the tree and check at each segment.\n  if (tree.hasRuntimePrefetch) {\n    // This route has a runtime prefetch response. Since we're below the shared\n    // layout, everything from this point should be prefetched using a single,\n    // combined runtime request, rather than using per-segment static requests.\n    // This is true even if some of the child segments are known to be fully\n    // static  once we've decided to perform a runtime prefetch, we might as\n    // well respond with the static segments in the same roundtrip. (That's how\n    // regular navigations work, too.) We'll still skip over segments that are\n    // already cached, though.\n    //\n    // It's the server's responsibility to set a reasonable value of\n    // `hasRuntimePrefetch`. Currently it's user-defined, but eventually, the\n    // server may send a value of `false` even if the user opts in, if it\n    // determines during build that the route is always fully static. There are\n    // more optimizations we can do once we implement fallback param\n    // tracking, too.\n    //\n    // Use the task object to collect the segments that need a runtime prefetch.\n    // This will signal to the outer task queue that a second traversal is\n    // required to construct a request tree.\n    if (task.spawnedRuntimePrefetches === null) {\n      task.spawnedRuntimePrefetches = new Set([tree.cacheKey])\n    } else {\n      task.spawnedRuntimePrefetches.add(tree.cacheKey)\n    }\n    // Then exit the traversal without prefetching anything further.\n    return PrefetchTaskExitStatus.Done\n  }\n\n  // This segment should not be runtime prefetched. Prefetch its static data.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree.cacheKey\n  )\n  pingStaticSegmentData(now, task, route, segment, task.key, tree)\n  if (tree.slots !== null) {\n    if (!hasNetworkBandwidth(task)) {\n      // Stop prefetching segments until there's more bandwidth.\n      return PrefetchTaskExitStatus.InProgress\n    }\n    // Recursively ping the children.\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      const childExitStatus = pingNewPartOfCacheComponentsTree(\n        now,\n        task,\n        route,\n        childTree\n      )\n      if (childExitStatus === PrefetchTaskExitStatus.InProgress) {\n        // Child yielded without finishing.\n        return PrefetchTaskExitStatus.InProgress\n      }\n    }\n  }\n  // This segment and all its children have finished prefetching.\n  return PrefetchTaskExitStatus.Done\n}\n\nfunction diffRouteTreeAgainstCurrent(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  oldTree: FlightRouterState,\n  newTree: RouteTree,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n  fetchStrategy:\n    | FetchStrategy.Full\n    | FetchStrategy.PPRRuntime\n    | FetchStrategy.LoadingBoundary\n): FlightRouterState {\n  // This is a single recursive traversal that does multiple things:\n  // - Finds the parts of the target route (newTree) that are not part of\n  //   of the current page (oldTree) by diffing them, using the same algorithm\n  //   as a real navigation.\n  // - Constructs a request tree (FlightRouterState) that describes which\n  //   segments need to be prefetched and which ones are already cached.\n  // - Creates a set of pending cache entries for the segments that need to\n  //   be prefetched, so that a subsequent prefetch task does not request the\n  //   same segments again.\n  const oldTreeChildren = oldTree[1]\n  const newTreeChildren = newTree.slots\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (newTreeChildren !== null) {\n    for (const parallelRouteKey in newTreeChildren) {\n      const newTreeChild = newTreeChildren[parallelRouteKey]\n      const newTreeChildSegment = newTreeChild.segment\n      const oldTreeChild: FlightRouterState | void =\n        oldTreeChildren[parallelRouteKey]\n      const oldTreeChildSegment: FlightRouterStateSegment | void =\n        oldTreeChild?.[0]\n      if (\n        oldTreeChildSegment !== undefined &&\n        doesCurrentSegmentMatchCachedSegment(\n          route,\n          newTreeChildSegment,\n          oldTreeChildSegment\n        )\n      ) {\n        // This segment is already part of the current route. Keep traversing.\n        const requestTreeChild = diffRouteTreeAgainstCurrent(\n          now,\n          task,\n          route,\n          oldTreeChild,\n          newTreeChild,\n          spawnedEntries,\n          fetchStrategy\n        )\n        requestTreeChildren[parallelRouteKey] = requestTreeChild\n      } else {\n        // This segment is not part of the current route. We're entering a\n        // part of the tree that we need to prefetch (unless everything is\n        // already cached).\n        switch (fetchStrategy) {\n          case FetchStrategy.LoadingBoundary: {\n            // When PPR is disabled, we can't prefetch per segment. We must\n            // fallback to the old prefetch behavior and send a dynamic request.\n            // Only routes that include a loading boundary can be prefetched in\n            // this way.\n            //\n            // This is simlar to a \"full\" prefetch, but we're much more\n            // conservative about which segments to include in the request.\n            //\n            // The server will only render up to the first loading boundary\n            // inside new part of the tree. If there's no loading boundary\n            // anywhere in the tree, the server will never return any data, so\n            // we can skip the request.\n            const subtreeHasLoadingBoundary =\n              newTreeChild.hasLoadingBoundary !==\n              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n            const requestTreeChild = subtreeHasLoadingBoundary\n              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                  now,\n                  task,\n                  route,\n                  newTreeChild,\n                  null,\n                  spawnedEntries\n                )\n              : // There's no loading boundary within this tree. Bail out.\n                convertRouteTreeToFlightRouterState(newTreeChild)\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.PPRRuntime: {\n            // This is a runtime prefetch. Fetch all cacheable data in the tree,\n            // not just the static PPR shell.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          case FetchStrategy.Full: {\n            // This is a \"full\" prefetch. Fetch all the data in the tree, both\n            // static and dynamic. We issue roughly the same request that we\n            // would during a real navigation. The goal is that once the\n            // navigation occurs, the router should not have to fetch any\n            // additional data.\n            //\n            // Although the response will include dynamic data, opting into a\n            // Full prefetch  via <Link prefetch={true}>  implicitly\n            // instructs the cache to treat the response as \"static\", or non-\n            // dynamic, since the whole point is to cache it for\n            // future navigations.\n            //\n            // Construct a tree (currently a FlightRouterState) that represents\n            // which segments need to be prefetched and which ones are already\n            // cached. If the tree is empty, then we can exit. Otherwise, we'll\n            // send the request tree to the server and use the response to\n            // populate the segment cache.\n            const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n              now,\n              task,\n              route,\n              newTreeChild,\n              false,\n              spawnedEntries,\n              fetchStrategy\n            )\n            requestTreeChildren[parallelRouteKey] = requestTreeChild\n            break\n          }\n          default:\n            fetchStrategy satisfies never\n        }\n      }\n    }\n  }\n  const requestTree: FlightRouterState = [\n    newTree.segment,\n    requestTreeChildren,\n    null,\n    null,\n    newTree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingPPRDisabledRouteTreeUpToLoadingBoundary(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // This function is similar to pingRouteTreeAndIncludeDynamicData, except the\n  // server is only going to return a minimal loading state  it will stop\n  // rendering at the first loading boundary. Whereas a Full prefetch is\n  // intentionally aggressive and tries to pretfetch all the data that will be\n  // needed for a navigation, a LoadingBoundary prefetch is much more\n  // conservative. For example, it will omit from the request tree any segment\n  // that is already cached, regardles of whether it's partial or full. By\n  // contrast, a Full prefetch will refetch partial segments.\n\n  // \"inside-shared-layout\" tells the server where to start looking for a\n  // loading boundary.\n  let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n    refetchMarkerContext === null ? 'inside-shared-layout' : null\n\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    task.fetchStrategy,\n    route,\n    tree.cacheKey\n  )\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Add a refetch marker so the server knows\n      // to start rendering here.\n      // TODO: Instead of a \"refetch\" marker, we could just omit this subtree's\n      // FlightRouterState from the request tree. I think this would probably\n      // already work even without any updates to the server. For consistency,\n      // though, I'll send the full tree and we'll look into this later as part\n      // of a larger redesign of the request protocol.\n\n      // Add the pending cache entry to the result map.\n      spawnedEntries.set(\n        tree.cacheKey,\n        upgradeToPendingSegment(\n          segment,\n          // Set the fetch strategy to LoadingBoundary to indicate that the server\n          // might not include it in the pending response. If another route is able\n          // to issue a per-segment request, we'll do that in the background.\n          FetchStrategy.LoadingBoundary\n        )\n      )\n      if (refetchMarkerContext !== 'refetch') {\n        refetchMarker = refetchMarkerContext = 'refetch'\n      } else {\n        // There's already a parent with a refetch marker, so we don't need\n        // to add another one.\n      }\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      const segmentHasLoadingBoundary =\n        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n      if (segmentHasLoadingBoundary) {\n        // This segment has a loading boundary, which means the server won't\n        // render its children. So there's nothing left to prefetch along this\n        // path. We can bail out.\n        return convertRouteTreeToFlightRouterState(tree)\n      }\n      // NOTE: If the cached segment were fetched using PPR, then it might be\n      // partial. We could get a more complete version of the segment by\n      // including it in this non-PPR request.\n      //\n      // We're intentionally choosing not to, though, because it's generally\n      // better to avoid doing a full prefetch whenever possible.\n      break\n    }\n    case EntryStatus.Pending: {\n      // There's another prefetch currently in progress. Don't add the refetch\n      // marker yet, so the server knows it can skip rendering this segment.\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The segment failed to load. We shouldn't issue another request until\n      // the stale time has elapsed.\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingPPRDisabledRouteTreeUpToLoadingBoundary(\n          now,\n          task,\n          route,\n          childTree,\n          refetchMarkerContext,\n          spawnedEntries\n        )\n    }\n  }\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRouteTreeAndIncludeDynamicData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  isInsideRefetchingParent: boolean,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): FlightRouterState {\n  // The tree we're constructing is the same shape as the tree we're navigating\n  // to. But even though this is a \"new\" tree, some of the individual segments\n  // may be cached as a result of other route prefetches.\n  //\n  // So we need to find the first uncached segment along each path add an\n  // explicit \"refetch\" marker so the server knows where to start rendering.\n  // Once the server starts rendering along a path, it keeps rendering the\n  // entire subtree.\n  const segment = readOrCreateSegmentCacheEntry(\n    now,\n    // Note that `fetchStrategy` might be different from `task.fetchStrategy`,\n    // and we have to use the former here.\n    // We can have a task with `FetchStrategy.PPR` where some of its segments are configured to\n    // always use runtime prefetching (via `export const prefetch`), and those should check for\n    // entries that include search params.\n    fetchStrategy,\n    route,\n    tree.cacheKey\n  )\n\n  let spawnedSegment: PendingSegmentCacheEntry | null = null\n\n  switch (segment.status) {\n    case EntryStatus.Empty: {\n      // This segment is not cached. Include it in the request.\n      spawnedSegment = upgradeToPendingSegment(segment, fetchStrategy)\n      break\n    }\n    case EntryStatus.Fulfilled: {\n      // The segment is already cached.\n      if (\n        segment.isPartial &&\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        // The cached segment contains dynamic holes, and was prefetched using a less specific strategy than the current one.\n        // This means we're in one of these cases:\n        //   - we have a static prefetch, and we're doing a runtime prefetch\n        //   - we have a static or runtime prefetch, and we're doing a Full prefetch (or a navigation).\n        // In either case, we need to include it in the request to get a more specific (or full) version.\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          segment,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    case EntryStatus.Pending:\n    case EntryStatus.Rejected: {\n      // There's either another prefetch currently in progress, or the previous\n      // attempt failed. If the new strategy can provide more content, fetch it again.\n      if (\n        canNewFetchStrategyProvideMoreContent(\n          segment.fetchStrategy,\n          fetchStrategy\n        )\n      ) {\n        spawnedSegment = pingFullSegmentRevalidation(\n          now,\n          route,\n          segment,\n          tree,\n          fetchStrategy\n        )\n      }\n      break\n    }\n    default:\n      segment satisfies never\n  }\n  const requestTreeChildren: Record<string, FlightRouterState> = {}\n  if (tree.slots !== null) {\n    for (const parallelRouteKey in tree.slots) {\n      const childTree = tree.slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] =\n        pingRouteTreeAndIncludeDynamicData(\n          now,\n          task,\n          route,\n          childTree,\n          isInsideRefetchingParent || spawnedSegment !== null,\n          spawnedEntries,\n          fetchStrategy\n        )\n    }\n  }\n\n  if (spawnedSegment !== null) {\n    // Add the pending entry to the result map.\n    spawnedEntries.set(tree.cacheKey, spawnedSegment)\n  }\n\n  // Don't bother to add a refetch marker if one is already present in a parent.\n  const refetchMarker =\n    !isInsideRefetchingParent && spawnedSegment !== null ? 'refetch' : null\n\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    refetchMarker,\n    tree.isRootLayout,\n  ]\n  return requestTree\n}\n\nfunction pingRuntimePrefetches(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree,\n  spawnedRuntimePrefetches: Set<SegmentCacheKey>,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n): FlightRouterState {\n  // Construct a request tree (FlightRouterState) for a runtime prefetch. If\n  // a segment is part of the runtime prefetch, the tree is constructed by\n  // diffing against what's already in the prefetch cache. Otherwise, we send\n  // a regular FlightRouterState with no special markers.\n  //\n  // See pingRouteTreeAndIncludeDynamicData for details.\n  if (spawnedRuntimePrefetches.has(tree.cacheKey)) {\n    // This segment needs a runtime prefetch.\n    return pingRouteTreeAndIncludeDynamicData(\n      now,\n      task,\n      route,\n      tree,\n      false,\n      spawnedEntries,\n      FetchStrategy.PPRRuntime\n    )\n  }\n  let requestTreeChildren: Record<string, FlightRouterState> = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      requestTreeChildren[parallelRouteKey] = pingRuntimePrefetches(\n        now,\n        task,\n        route,\n        childTree,\n        spawnedRuntimePrefetches,\n        spawnedEntries\n      )\n    }\n  }\n\n  // This segment is not part of the runtime prefetch. Clone the base tree.\n  const requestTree: FlightRouterState = [\n    tree.segment,\n    requestTreeChildren,\n    null,\n    null,\n  ]\n  return requestTree\n}\n\nfunction pingStaticSegmentData(\n  now: number,\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  segment: SegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  switch (segment.status) {\n    case EntryStatus.Empty:\n      // Upgrade to Pending so we know there's already a request in progress\n      spawnPrefetchSubtask(\n        fetchSegmentOnCacheMiss(\n          route,\n          upgradeToPendingSegment(segment, FetchStrategy.PPR),\n          routeKey,\n          tree\n        )\n      )\n      break\n    case EntryStatus.Pending: {\n      // There's already a request in progress. Depending on what kind of\n      // request it is, we may want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // There's already a request in progress. Don't do anything.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a pending request, but because it's using the old\n          // prefetching strategy, we can't be sure if it will be fulfilled by\n          // the response  it might be inside the loading boundary. Perform\n          // a revalidation, but because it's speculative, wait to do it at\n          // background priority.\n          if (background(task)) {\n            // TODO: Instead of speculatively revalidating, consider including\n            // `hasLoading` in the route tree prefetch response.\n            pingPPRSegmentRevalidation(\n              now,\n              task,\n              segment,\n              route,\n              routeKey,\n              tree\n            )\n          }\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Rejected: {\n      // The existing entry in the cache was rejected. Depending on how it\n      // was originally fetched, we may or may not want to revalidate it.\n      switch (segment.fetchStrategy) {\n        case FetchStrategy.PPR:\n        case FetchStrategy.PPRRuntime:\n        case FetchStrategy.Full:\n          // The previous attempt to fetch this entry failed. Don't attempt to\n          // fetch it again until the entry expires.\n          break\n        case FetchStrategy.LoadingBoundary:\n          // There's a rejected entry, but it was fetched using the loading\n          // boundary strategy. So the reason it wasn't returned by the server\n          // might just be because it was inside a loading boundary. Or because\n          // there was a dynamic rewrite. Revalidate it using the per-\n          // segment strategy.\n          //\n          // Because a rejected segment will definitely prevent the segment (and\n          // all of its children) from rendering, we perform this revalidation\n          // immediately instead of deferring it to a background task.\n          pingPPRSegmentRevalidation(now, task, segment, route, routeKey, tree)\n          break\n        default:\n          segment.fetchStrategy satisfies never\n      }\n      break\n    }\n    case EntryStatus.Fulfilled:\n      // Segment is already cached. There's nothing left to prefetch.\n      break\n    default:\n      segment satisfies never\n  }\n\n  // Segments do not have dependent tasks, so once the prefetch is initiated,\n  // there's nothing else for us to do (except write the server data into the\n  // entry, which is handled by `fetchSegmentOnCacheMiss`).\n}\n\nfunction pingPPRSegmentRevalidation(\n  now: number,\n  task: PrefetchTask,\n  currentSegment: SegmentCacheEntry,\n  route: FulfilledRouteCacheEntry,\n  routeKey: RouteCacheKey,\n  tree: RouteTree\n): void {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    currentSegment\n  )\n  switch (revalidatingSegment.status) {\n    case EntryStatus.Empty:\n      // Spawn a prefetch request and upsert the segment into the cache\n      // upon completion.\n      upsertSegmentOnCompletion(\n        task.fetchStrategy,\n        route,\n        tree.cacheKey,\n        spawnPrefetchSubtask(\n          fetchSegmentOnCacheMiss(\n            route,\n            upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n            routeKey,\n            tree\n          )\n        )\n      )\n      break\n    case EntryStatus.Pending:\n      // There's already a revalidation in progress.\n      break\n    case EntryStatus.Fulfilled:\n    case EntryStatus.Rejected:\n      // A previous revalidation attempt finished, but we chose not to replace\n      // the existing entry in the cache. Don't try again until or unless the\n      // revalidation entry expires.\n      break\n    default:\n      revalidatingSegment satisfies never\n  }\n}\n\nfunction pingFullSegmentRevalidation(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  currentSegment: SegmentCacheEntry,\n  tree: RouteTree,\n  fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n): PendingSegmentCacheEntry | null {\n  const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n    now,\n    currentSegment\n  )\n  if (revalidatingSegment.status === EntryStatus.Empty) {\n    // During a Full/PPRRuntime prefetch, a single dynamic request is made for all the\n    // segments that we need. So we don't initiate a request here directly. By\n    // returning a pending entry from this function, it signals to the caller\n    // that this segment should be included in the request that's sent to\n    // the server.\n    const pendingSegment = upgradeToPendingSegment(\n      revalidatingSegment,\n      fetchStrategy\n    )\n    upsertSegmentOnCompletion(\n      fetchStrategy,\n      route,\n      tree.cacheKey,\n      waitForSegmentCacheEntry(pendingSegment)\n    )\n    return pendingSegment\n  } else {\n    // There's already a revalidation in progress.\n    const nonEmptyRevalidatingSegment = revalidatingSegment\n    if (\n      canNewFetchStrategyProvideMoreContent(\n        nonEmptyRevalidatingSegment.fetchStrategy,\n        fetchStrategy\n      )\n    ) {\n      // The existing revalidation was fetched using a less specific strategy.\n      // Reset it and start a new revalidation.\n      const emptySegment = resetRevalidatingSegmentEntry(\n        nonEmptyRevalidatingSegment\n      )\n      const pendingSegment = upgradeToPendingSegment(\n        emptySegment,\n        fetchStrategy\n      )\n      upsertSegmentOnCompletion(\n        fetchStrategy,\n        route,\n        tree.cacheKey,\n        waitForSegmentCacheEntry(pendingSegment)\n      )\n      return pendingSegment\n    }\n    switch (nonEmptyRevalidatingSegment.status) {\n      case EntryStatus.Pending:\n        // There's already an in-progress prefetch that includes this segment.\n        return null\n      case EntryStatus.Fulfilled:\n      case EntryStatus.Rejected:\n        // A previous revalidation attempt finished, but we chose not to replace\n        // the existing entry in the cache. Don't try again until or unless the\n        // revalidation entry expires.\n        return null\n      default:\n        nonEmptyRevalidatingSegment satisfies never\n        return null\n    }\n  }\n}\n\nconst noop = () => {}\n\nfunction upsertSegmentOnCompletion(\n  fetchStrategy: FetchStrategy,\n  route: FulfilledRouteCacheEntry,\n  cacheKey: SegmentCacheKey,\n  promise: Promise<FulfilledSegmentCacheEntry | null>\n) {\n  // Wait for a segment to finish loading, then upsert it into the cache\n  promise.then((fulfilled) => {\n    if (fulfilled !== null) {\n      // Received new data. Attempt to replace the existing entry in the cache.\n      const keypath = getSegmentKeypath(fetchStrategy, route, cacheKey)\n      upsertSegmentEntry(Date.now(), keypath, fulfilled)\n    }\n  }, noop)\n}\n\nfunction doesCurrentSegmentMatchCachedSegment(\n  route: FulfilledRouteCacheEntry,\n  currentSegment: Segment,\n  cachedSegment: Segment\n): boolean {\n  if (cachedSegment === PAGE_SEGMENT_KEY) {\n    // In the FlightRouterState stored by the router, the page segment has the\n    // rendered search params appended to the name of the segment. In the\n    // prefetch cache, however, this is stored separately. So, when comparing\n    // the router's current FlightRouterState to the cached FlightRouterState,\n    // we need to make sure we compare both parts of the segment.\n    // TODO: This is not modeled clearly. We use the same type,\n    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n    // _and_ the server response format, when conceptually those are three\n    // different things and treated in different ways. We should encode more of\n    // this information into the type design so mistakes are less likely.\n    return (\n      currentSegment ===\n      addSearchParamsIfPageSegment(\n        PAGE_SEGMENT_KEY,\n        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n      )\n    )\n  }\n  // Non-page segments are compared using the same function as the server\n  return matchSegment(cachedSegment, currentSegment)\n}\n\n// -----------------------------------------------------------------------------\n// The remainder of the module is a MinHeap implementation. Try not to put any\n// logic below here unless it's related to the heap algorithm. We can extract\n// this to a separate module if/when we need multiple kinds of heaps.\n// -----------------------------------------------------------------------------\n\nfunction compareQueuePriority(a: PrefetchTask, b: PrefetchTask) {\n  // Since the queue is a MinHeap, this should return a positive number if b is\n  // higher priority than a, and a negative number if a is higher priority\n  // than b.\n\n  // `priority` is an integer, where higher numbers are higher priority.\n  const priorityDiff = b.priority - a.priority\n  if (priorityDiff !== 0) {\n    return priorityDiff\n  }\n\n  // If the priority is the same, check which phase the prefetch is in  is it\n  // prefetching the route tree, or the segments? Route trees are prioritized.\n  const phaseDiff = b.phase - a.phase\n  if (phaseDiff !== 0) {\n    return phaseDiff\n  }\n\n  // Finally, check the insertion order. `sortId` is an incrementing counter\n  // assigned to prefetches. We want to process the newest prefetches first.\n  return b.sortId - a.sortId\n}\n\nfunction heapPush(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = heap.length\n  heap.push(node)\n  node._heapIndex = index\n  heapSiftUp(heap, node, index)\n}\n\nfunction heapPeek(heap: Array<PrefetchTask>): PrefetchTask | null {\n  return heap.length === 0 ? null : heap[0]\n}\n\nfunction heapPop(heap: Array<PrefetchTask>): PrefetchTask | null {\n  if (heap.length === 0) {\n    return null\n  }\n  const first = heap[0]\n  first._heapIndex = -1\n  const last = heap.pop() as PrefetchTask\n  if (last !== first) {\n    heap[0] = last\n    last._heapIndex = 0\n    heapSiftDown(heap, last, 0)\n  }\n  return first\n}\n\nfunction heapDelete(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    node._heapIndex = -1\n    if (heap.length !== 0) {\n      const last = heap.pop() as PrefetchTask\n      if (last !== node) {\n        heap[index] = last\n        last._heapIndex = index\n        heapSiftDown(heap, last, index)\n      }\n    }\n  }\n}\n\nfunction heapResift(heap: Array<PrefetchTask>, node: PrefetchTask): void {\n  const index = node._heapIndex\n  if (index !== -1) {\n    if (index === 0) {\n      heapSiftDown(heap, node, 0)\n    } else {\n      const parentIndex = (index - 1) >>> 1\n      const parent = heap[parentIndex]\n      if (compareQueuePriority(parent, node) > 0) {\n        // The parent is larger. Sift up.\n        heapSiftUp(heap, node, index)\n      } else {\n        // The parent is smaller (or equal). Sift down.\n        heapSiftDown(heap, node, index)\n      }\n    }\n  }\n}\n\nfunction heapSiftUp(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  while (index > 0) {\n    const parentIndex = (index - 1) >>> 1\n    const parent = heap[parentIndex]\n    if (compareQueuePriority(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node\n      node._heapIndex = parentIndex\n      heap[index] = parent\n      parent._heapIndex = index\n\n      index = parentIndex\n    } else {\n      // The parent is smaller. Exit.\n      return\n    }\n  }\n}\n\nfunction heapSiftDown(\n  heap: Array<PrefetchTask>,\n  node: PrefetchTask,\n  i: number\n): void {\n  let index = i\n  const length = heap.length\n  const halfLength = length >>> 1\n  while (index < halfLength) {\n    const leftIndex = (index + 1) * 2 - 1\n    const left = heap[leftIndex]\n    const rightIndex = leftIndex + 1\n    const right = heap[rightIndex]\n\n    // If the left or right node is smaller, swap with the smaller of those.\n    if (compareQueuePriority(left, node) < 0) {\n      if (rightIndex < length && compareQueuePriority(right, left) < 0) {\n        heap[index] = right\n        right._heapIndex = index\n        heap[rightIndex] = node\n        node._heapIndex = rightIndex\n\n        index = rightIndex\n      } else {\n        heap[index] = left\n        left._heapIndex = index\n        heap[leftIndex] = node\n        node._heapIndex = leftIndex\n\n        index = leftIndex\n      }\n    } else if (rightIndex < length && compareQueuePriority(right, node) < 0) {\n      heap[index] = right\n      right._heapIndex = index\n      heap[rightIndex] = node\n      node._heapIndex = rightIndex\n\n      index = rightIndex\n    } else {\n      // Neither child is smaller. Exit.\n      return\n    }\n  }\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\nimport { createPrefetchURL } from '../app-router-utils'\nimport { createCacheKey } from './cache-key'\nimport { schedulePrefetchTask } from './scheduler'\nimport {\n  PrefetchPriority,\n  type PrefetchTaskFetchStrategy,\n} from '../segment-cache'\n\n/**\n * Entrypoint for prefetching a URL into the Segment Cache.\n * @param href - The URL to prefetch. Typically this will come from a <Link>,\n * or router.prefetch. It must be validated before we attempt to prefetch it.\n * @param nextUrl - A special header used by the server for interception routes.\n * Roughly corresponds to the current URL.\n * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n * was requested. This is only used when PPR is disabled.\n * @param fetchStrategy - Whether to prefetch dynamic data, in addition to\n * static data. This is used by `<Link prefetch={true}>`.\n * @param onInvalidate - A callback that will be called when the prefetch cache\n * When called, it signals to the listener that the data associated with the\n * prefetch may have been invalidated from the cache. This is not a live\n * subscription  it's called at most once per `prefetch` call. The only\n * supported use case is to trigger a new prefetch inside the listener, if\n * desired. It also may be called even in cases where the associated data is\n * still cached. Prefetching is a poll-based (pull) operation, not an event-\n * based (push) one. Rather than subscribe to specific cache entries, you\n * occasionally poll the prefetch cache to check if anything is missing.\n */\nexport function prefetch(\n  href: string,\n  nextUrl: string | null,\n  treeAtTimeOfPrefetch: FlightRouterState,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  onInvalidate: null | (() => void)\n) {\n  const url = createPrefetchURL(href)\n  if (url === null) {\n    // This href should not be prefetched.\n    return\n  }\n  const cacheKey = createCacheKey(url.href, nextUrl)\n  schedulePrefetchTask(\n    cacheKey,\n    treeAtTimeOfPrefetch,\n    fetchStrategy,\n    PrefetchPriority.Default,\n    onInvalidate\n  )\n}\n","import type { Segment } from '../../../shared/lib/app-router-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { FlightRouterState } from '../../../shared/lib/app-router-types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldUrl,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldUrl: URL,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment  a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation  but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = reuseActiveSegmentInDefaultSlot(oldUrl, oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldUrl,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[0]\n    loading = prefetchData[2]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[3]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction reuseActiveSegmentInDefaultSlot(\n  oldUrl: URL,\n  oldRouterState: FlightRouterState\n): Task {\n  // This is a \"default\" segment. These are never sent by the server during a\n  // soft navigation; instead, the client reuses whatever segment was already\n  // active in that slot on the previous route. This means if we later need to\n  // refresh the segment, it will have to be refetched from the previous route's\n  // URL. We store it in the Flight Router State.\n  //\n  // TODO: We also mark the segment with a \"refresh\" marker but I think we can\n  // get rid of that eventually by making sure we only add URLs to page segments\n  // that are reused. Then the presence of the URL alone is enough.\n  let reusedRouterState\n\n  const oldRefreshMarker = oldRouterState[3]\n  if (oldRefreshMarker === 'refresh') {\n    // This segment was already reused from an even older route. Keep its\n    // existing URL and refresh marker.\n    reusedRouterState = oldRouterState\n  } else {\n    // This segment was not previously reused, and it's not on the new route.\n    // So it must have been delivered in the old route.\n    reusedRouterState = patchRouterStateWithNewChildren(\n      oldRouterState,\n      oldRouterState[1]\n    )\n    reusedRouterState[2] = createHrefFromUrl(oldUrl)\n    reusedRouterState[3] = 'refresh'\n  }\n\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (result: FetchServerResponseResult) => {\n      if (typeof result === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      const { flightData, debugInfo } = result\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead,\n          debugInfo\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null, debugInfo)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error, null)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead,\n    debugInfo\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead,\n        debugInfo\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead,\n          debugInfo\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading:\n      prefetchData !== null\n        ? (prefetchData[2] ?? null)\n        : // If we don't have a prefetch, then we don't know if there's a loading component.\n          // We'll fulfill it based on the dynamic response, just like `rsc` and `head`.\n          createDeferredRsc<LoadingModuleData>(),\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData,\n  debugInfo: Array<any> | null\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead,\n            debugInfo\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[0]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData, debugInfo)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // If we navigated without a prefetch, then `loading` will be a deferred promise too.\n  // Fulfill it using the dynamic response so that we can display the loading boundary.\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    const dynamicLoading = dynamicData[2]\n    loading.resolve(dynamicLoading, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead, debugInfo)\n  }\n}\n\nexport function abortTask(\n  task: SPANavigationTask,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error, debugInfo)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any,\n  debugInfo: Array<any> | null\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null, debugInfo)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error, debugInfo)\n    }\n  }\n\n  const loading = cacheNode.loading\n  if (isDeferredRsc(loading)) {\n    loading.resolve(null, debugInfo)\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null, debugInfo)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc<T> = Promise<T> & {\n  status: 'pending'\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype FulfilledDeferredRsc<T> = Promise<T> & {\n  status: 'fulfilled'\n  value: T\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype RejectedDeferredRsc<T> = Promise<T> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: T, debugInfo: Array<any> | null) => void\n  reject: (error: any, debugInfo: Array<any> | null) => void\n  tag: Symbol\n  _debugInfo: Array<any>\n}\n\ntype DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n  | PendingDeferredRsc<T>\n  | FulfilledDeferredRsc<T>\n  | RejectedDeferredRsc<T>\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && typeof value === 'object' && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc<\n  T extends React.ReactNode = React.ReactNode,\n>(): PendingDeferredRsc<T> {\n  // Create an unresolved promise that represents data derived from a Flight\n  // response. The promise will be resolved later as soon as we start receiving\n  // data from the server, i.e. as soon as the Flight client decodes and returns\n  // the top-level response object.\n\n  // The `_debugInfo` field contains profiling information. Promises that are\n  // created by Flight already have this info added by React; for any derived\n  // promise created by the router, we need to transfer the Flight debug info\n  // onto the derived promise.\n  //\n  // The debug info represents the latency between the start of the navigation\n  // and the start of rendering. (It does not represent the time it takes for\n  // whole stream to finish.)\n  const debugInfo: Array<any> = []\n\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc<T>\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      if (responseDebugInfo !== null) {\n        // Transfer the debug info to the derived promise.\n        debugInfo.push.apply(debugInfo, responseDebugInfo)\n      }\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  pendingRsc._debugInfo = debugInfo\n\n  return pendingRsc\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../shared/lib/app-router-types'\nimport type { CacheNode } from '../../../shared/lib/app-router-types'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { fetchServerResponse } from '../router-reducer/fetch-server-response'\nimport {\n  startPPRNavigation,\n  listenForDynamicRequest,\n  type Task as PPRNavigationTask,\n} from '../router-reducer/ppr-navigations'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport {\n  EntryStatus,\n  readRouteCacheEntry,\n  readSegmentCacheEntry,\n  waitForSegmentCacheEntry,\n  requestOptimisticRouteCacheEntry,\n  type RouteTree,\n  type FulfilledRouteCacheEntry,\n} from './cache'\nimport { createCacheKey } from './cache-key'\nimport { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\nimport { NavigationResultTag } from '../segment-cache'\n\ntype MPANavigationResult = {\n  tag: NavigationResultTag.MPA\n  data: string\n}\n\ntype NoOpNavigationResult = {\n  tag: NavigationResultTag.NoOp\n  data: {\n    canonicalUrl: string\n    shouldScroll: boolean\n  }\n}\n\ntype SuccessfulNavigationResult = {\n  tag: NavigationResultTag.Success\n  data: {\n    flightRouterState: FlightRouterState\n    cacheNode: CacheNode\n    canonicalUrl: string\n    renderedSearch: string\n    scrollableSegments: Array<FlightSegmentPath>\n    shouldScroll: boolean\n    hash: string\n  }\n}\n\ntype AsyncNavigationResult = {\n  tag: NavigationResultTag.Async\n  data: Promise<\n    MPANavigationResult | NoOpNavigationResult | SuccessfulNavigationResult\n  >\n}\n\nexport type NavigationResult =\n  | MPANavigationResult\n  | SuccessfulNavigationResult\n  | NoOpNavigationResult\n  | AsyncNavigationResult\n\n/**\n * Navigate to a new URL, using the Segment Cache to construct a response.\n *\n * To allow for synchronous navigations whenever possible, this is not an async\n * function. It returns a promise only if there's no matching prefetch in\n * the cache. Otherwise it returns an immediate result and uses Suspense/RSC to\n * stream in any missing data.\n */\nexport function navigate(\n  url: URL,\n  currentUrl: URL,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  shouldScroll: boolean,\n  accumulation: { collectedDebugInfo?: Array<unknown> }\n): NavigationResult {\n  const now = Date.now()\n  const href = url.href\n\n  // We special case navigations to the exact same URL as the current location.\n  // It's a common UI pattern for apps to refresh when you click a link to the\n  // current page. So when this happens, we refresh the dynamic data in the page\n  // segments.\n  //\n  // Note that this does not apply if the any part of the hash or search query\n  // has changed. This might feel a bit weird but it makes more sense when you\n  // consider that the way to trigger this behavior is to click the same link\n  // multiple times.\n  //\n  // TODO: We should probably refresh the *entire* route when this case occurs,\n  // not just the page segments. Essentially treating it the same as a refresh()\n  // triggered by an action, which is the more explicit way of modeling the UI\n  // pattern described above.\n  //\n  // Also note that this only refreshes the dynamic data, not static/ cached\n  // data. If the page segment is fully static and prefetched, the request is\n  // skipped. (This is also how refresh() works.)\n  const isSamePageNavigation =\n    // TODO: This is not the only place we read from the location, but we should\n    // consider storing the current URL in the router state instead of reading\n    // from the location object. In practice I don't think this matters much\n    // since we keep them in sync anyway, but having two sources of truth can\n    // lead to subtle bugs and race conditions.\n    href === window.location.href\n\n  const cacheKey = createCacheKey(href, nextUrl)\n  const route = readRouteCacheEntry(now, cacheKey)\n  if (route !== null && route.status === EntryStatus.Fulfilled) {\n    // We have a matching prefetch.\n    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n    const prefetchFlightRouterState = snapshot.flightRouterState\n    const prefetchSeedData = snapshot.seedData\n    const prefetchHead = route.head\n    const isPrefetchHeadPartial = route.isHeadPartial\n    const newCanonicalUrl = route.canonicalUrl\n    const renderedSearch = route.renderedSearch\n    return navigateUsingPrefetchedRouteTree(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      prefetchFlightRouterState,\n      prefetchSeedData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      newCanonicalUrl,\n      renderedSearch,\n      shouldScroll,\n      url.hash\n    )\n  }\n\n  // There was no matching route tree in the cache. Let's see if we can\n  // construct an \"optimistic\" route tree.\n  //\n  // Do not construct an optimistic route tree if there was a cache hit, but\n  // the entry has a rejected status, since it may have been rejected due to a\n  // rewrite or redirect based on the search params.\n  //\n  // TODO: There are multiple reasons a prefetch might be rejected; we should\n  // track them explicitly and choose what to do here based on that.\n  if (route === null || route.status !== EntryStatus.Rejected) {\n    const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n    if (optimisticRoute !== null) {\n      // We have an optimistic route tree. Proceed with the normal flow.\n      const snapshot = readRenderSnapshotFromCache(\n        now,\n        optimisticRoute,\n        optimisticRoute.tree\n      )\n      const prefetchFlightRouterState = snapshot.flightRouterState\n      const prefetchSeedData = snapshot.seedData\n      const prefetchHead = optimisticRoute.head\n      const isPrefetchHeadPartial = optimisticRoute.isHeadPartial\n      const newCanonicalUrl = optimisticRoute.canonicalUrl\n      const newRenderedSearch = optimisticRoute.renderedSearch\n      return navigateUsingPrefetchedRouteTree(\n        now,\n        url,\n        currentUrl,\n        nextUrl,\n        isSamePageNavigation,\n        currentCacheNode,\n        currentFlightRouterState,\n        prefetchFlightRouterState,\n        prefetchSeedData,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newCanonicalUrl,\n        newRenderedSearch,\n        shouldScroll,\n        url.hash\n      )\n    }\n  }\n\n  // There's no matching prefetch for this route in the cache.\n  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n  if (accumulation.collectedDebugInfo === undefined) {\n    collectedDebugInfo = accumulation.collectedDebugInfo = []\n  }\n  return {\n    tag: NavigationResultTag.Async,\n    data: navigateDynamicallyWithNoPrefetch(\n      now,\n      url,\n      currentUrl,\n      nextUrl,\n      isSamePageNavigation,\n      currentCacheNode,\n      currentFlightRouterState,\n      shouldScroll,\n      url.hash,\n      collectedDebugInfo\n    ),\n  }\n}\n\nfunction navigateUsingPrefetchedRouteTree(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  prefetchFlightRouterState: FlightRouterState,\n  prefetchSeedData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  canonicalUrl: string,\n  renderedSearch: string,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n  // Recursively construct a prefetch tree by reading from the Segment Cache. To\n  // maintain compatibility, we output the same data structures as the old\n  // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n  // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n  // read from the Segment Cache directly. It's only structured this way for now\n  // so we can share code with the old prefetching implementation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    const dynamicRequestTree = task.dynamicRequestTree\n    if (dynamicRequestTree !== null) {\n      const promiseForDynamicServerResponse = fetchServerResponse(\n        new URL(canonicalUrl, url.origin),\n        {\n          flightRouterState: dynamicRequestTree,\n          nextUrl,\n        }\n      )\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes  it's\n      // fully static. We can skip the dynamic request.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl,\n      shouldScroll,\n    },\n  }\n}\n\nfunction navigationTaskToResult(\n  task: PPRNavigationTask,\n  currentCacheNode: CacheNode,\n  canonicalUrl: string,\n  renderedSearch: string,\n  scrollableSegments: Array<FlightSegmentPath>,\n  shouldScroll: boolean,\n  hash: string\n): SuccessfulNavigationResult | MPANavigationResult {\n  const flightRouterState = task.route\n  if (flightRouterState === null) {\n    // When no router state is provided, it signals that we should perform an\n    // MPA navigation.\n    return {\n      tag: NavigationResultTag.MPA,\n      data: canonicalUrl,\n    }\n  }\n  const newCacheNode = task.node\n  return {\n    tag: NavigationResultTag.Success,\n    data: {\n      flightRouterState,\n      cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n      canonicalUrl,\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash,\n    },\n  }\n}\n\nfunction readRenderSnapshotFromCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  tree: RouteTree\n): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n  let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n  let childSeedDatas: {\n    [parallelRouteKey: string]: CacheNodeSeedData | null\n  } = {}\n  const slots = tree.slots\n  if (slots !== null) {\n    for (const parallelRouteKey in slots) {\n      const childTree = slots[parallelRouteKey]\n      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n      childRouterStates[parallelRouteKey] = childResult.flightRouterState\n      childSeedDatas[parallelRouteKey] = childResult.seedData\n    }\n  }\n\n  let rsc: React.ReactNode | null = null\n  let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n  let isPartial: boolean = true\n\n  const segmentEntry = readSegmentCacheEntry(now, route, tree.cacheKey)\n  if (segmentEntry !== null) {\n    switch (segmentEntry.status) {\n      case EntryStatus.Fulfilled: {\n        // Happy path: a cache hit\n        rsc = segmentEntry.rsc\n        loading = segmentEntry.loading\n        isPartial = segmentEntry.isPartial\n        break\n      }\n      case EntryStatus.Pending: {\n        // We haven't received data for this segment yet, but there's already\n        // an in-progress request. Since it's extremely likely to arrive\n        // before the dynamic data response, we might as well use it.\n        const promiseForFulfilledEntry = waitForSegmentCacheEntry(segmentEntry)\n        rsc = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.rsc : null\n        )\n        loading = promiseForFulfilledEntry.then((entry) =>\n          entry !== null ? entry.loading : null\n        )\n        // Since we don't know yet whether the segment is partial or fully\n        // static, we must assume it's partial; we can't skip the\n        // dynamic request.\n        isPartial = true\n        break\n      }\n      case EntryStatus.Empty:\n      case EntryStatus.Rejected:\n        break\n      default:\n        segmentEntry satisfies never\n    }\n  }\n\n  // The navigation implementation expects the search params to be\n  // included in the segment. However, the Segment Cache tracks search\n  // params separately from the rest of the segment key. So we need to\n  // add them back here.\n  //\n  // See corresponding comment in convertFlightRouterStateToTree.\n  //\n  // TODO: What we should do instead is update the navigation diffing\n  // logic to compare search params explicitly. This is a temporary\n  // solution until more of the Segment Cache implementation has settled.\n  const segment = addSearchParamsIfPageSegment(\n    tree.segment,\n    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n  )\n\n  // We don't need this information in a render snapshot, so this can just be a placeholder.\n  const hasRuntimePrefetch = false\n\n  return {\n    flightRouterState: [\n      segment,\n      childRouterStates,\n      null,\n      null,\n      tree.isRootLayout,\n    ],\n    seedData: [rsc, childSeedDatas, loading, isPartial, hasRuntimePrefetch],\n  }\n}\n\nasync function navigateDynamicallyWithNoPrefetch(\n  now: number,\n  url: URL,\n  currentUrl: URL,\n  nextUrl: string | null,\n  isSamePageNavigation: boolean,\n  currentCacheNode: CacheNode,\n  currentFlightRouterState: FlightRouterState,\n  shouldScroll: boolean,\n  hash: string,\n  collectedDebugInfo: Array<unknown>\n): Promise<\n  MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n> {\n  // Runs when a navigation happens but there's no cached prefetch we can use.\n  // Don't bother to wait for a prefetch response; go straight to a full\n  // navigation that contains both static and dynamic data in a single stream.\n  // (This is unlike the old navigation implementation, which instead blocks\n  // the dynamic request until a prefetch request is received.)\n  //\n  // To avoid duplication of logic, we're going to pretend that the tree\n  // returned by the dynamic request is, in fact, a prefetch tree. Then we can\n  // use the same server response to write the actual data into the CacheNode\n  // tree. So it's the same flow as the \"happy path\" (prefetch, then\n  // navigation), except we use a single server response for both stages.\n\n  const promiseForDynamicServerResponse = fetchServerResponse(url, {\n    flightRouterState: currentFlightRouterState,\n    nextUrl,\n  })\n  const result = await promiseForDynamicServerResponse\n  if (typeof result === 'string') {\n    // This is an MPA navigation.\n    const newUrl = result\n    return {\n      tag: NavigationResultTag.MPA,\n      data: newUrl,\n    }\n  }\n\n  const {\n    flightData,\n    canonicalUrl,\n    renderedSearch,\n    debugInfo: debugInfoFromResponse,\n  } = result\n  if (debugInfoFromResponse !== null) {\n    collectedDebugInfo.push(...debugInfoFromResponse)\n  }\n\n  // Since the response format of dynamic requests and prefetches is slightly\n  // different, we'll need to massage the data a bit. Create FlightRouterState\n  // tree that simulates what we'd receive as the result of a prefetch.\n  const prefetchFlightRouterState = simulatePrefetchTreeUsingDynamicTreePatch(\n    currentFlightRouterState,\n    flightData\n  )\n\n  // In our simulated prefetch payload, we pretend that there's no seed data\n  // nor a prefetch head.\n  const prefetchSeedData = null\n  const prefetchHead = null\n  const isPrefetchHeadPartial = true\n\n  // Now we proceed exactly as we would for normal navigation.\n  const scrollableSegments: Array<FlightSegmentPath> = []\n  const task = startPPRNavigation(\n    now,\n    currentUrl,\n    currentCacheNode,\n    currentFlightRouterState,\n    prefetchFlightRouterState,\n    prefetchSeedData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    scrollableSegments\n  )\n  if (task !== null) {\n    // In this case, we've already sent the dynamic request, so we don't\n    // actually use the request tree created by `startPPRNavigation`,\n    // except to check if it contains dynamic holes.\n    //\n    // This is almost always true, but it could be false if all the segment data\n    // was present in the cache, but the route tree was not. E.g. navigating\n    // to a URL that was not prefetched but rewrites to a different URL\n    // that was.\n    const hasDynamicHoles = task.dynamicRequestTree !== null\n    if (hasDynamicHoles) {\n      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n    } else {\n      // The prefetched tree does not contain dynamic holes  it's\n      // fully static. We don't need to process the server response further.\n    }\n    return navigationTaskToResult(\n      task,\n      currentCacheNode,\n      createHrefFromUrl(canonicalUrl),\n      renderedSearch,\n      scrollableSegments,\n      shouldScroll,\n      hash\n    )\n  }\n  // The server sent back an empty tree patch. There's nothing to update, except\n  // possibly the URL.\n  return {\n    tag: NavigationResultTag.NoOp,\n    data: {\n      canonicalUrl: createHrefFromUrl(canonicalUrl),\n      shouldScroll,\n    },\n  }\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatch(\n  currentTree: FlightRouterState,\n  flightData: Array<NormalizedFlightData>\n): FlightRouterState {\n  // Takes the current FlightRouterState and applies the router state patch\n  // received from the server, to create a full FlightRouterState tree that we\n  // can pretend was returned by a prefetch.\n  //\n  // (It sounds similar to what applyRouterStatePatch does, but it doesn't need\n  // to handle stuff like interception routes or diffing since that will be\n  // handled later.)\n  let baseTree = currentTree\n  for (const { segmentPath, tree: treePatch } of flightData) {\n    // If the server sends us multiple tree patches, we only need to clone the\n    // base tree when applying the first patch. After the first patch, we can\n    // apply the remaining patches in place without copying.\n    const canMutateInPlace = baseTree !== currentTree\n    baseTree = simulatePrefetchTreeUsingDynamicTreePatchImpl(\n      baseTree,\n      treePatch,\n      segmentPath,\n      canMutateInPlace,\n      0\n    )\n  }\n\n  return baseTree\n}\n\nfunction simulatePrefetchTreeUsingDynamicTreePatchImpl(\n  baseRouterState: FlightRouterState,\n  patch: FlightRouterState,\n  segmentPath: FlightSegmentPath,\n  canMutateInPlace: boolean,\n  index: number\n) {\n  if (index === segmentPath.length) {\n    // We reached the part of the tree that we need to patch.\n    return patch\n  }\n\n  // segmentPath represents the parent path of subtree. It's a repeating\n  // pattern of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // This path tells us which part of the base tree to apply the tree patch.\n  //\n  // NOTE: In the case of a fully dynamic request with no prefetch, we receive\n  // the FlightRouterState patch in the same request as the dynamic data.\n  // Therefore we don't need to worry about diffing the segment values; we can\n  // assume the server sent us a correct result.\n  const updatedParallelRouteKey: string = segmentPath[index]\n  // const segment: Segment = segmentPath[index + 1] <-- Not used, see note above\n\n  const baseChildren = baseRouterState[1]\n  const newChildren: { [parallelRouteKey: string]: FlightRouterState } = {}\n  for (const parallelRouteKey in baseChildren) {\n    if (parallelRouteKey === updatedParallelRouteKey) {\n      const childBaseRouterState = baseChildren[parallelRouteKey]\n      newChildren[parallelRouteKey] =\n        simulatePrefetchTreeUsingDynamicTreePatchImpl(\n          childBaseRouterState,\n          patch,\n          segmentPath,\n          canMutateInPlace,\n          // Advance the index by two and keep cloning until we reach\n          // the end of the segment path.\n          index + 2\n        )\n    } else {\n      // This child is not being patched. Copy it over as-is.\n      newChildren[parallelRouteKey] = baseChildren[parallelRouteKey]\n    }\n  }\n\n  if (canMutateInPlace) {\n    // We can mutate the base tree in place, because the base tree is already\n    // a clone.\n    baseRouterState[1] = newChildren\n    return baseRouterState\n  }\n\n  // Clone all the fields except the children.\n  //\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n","/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment  if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */\n\nexport type { NavigationResult } from './segment-cache-impl/navigation'\nexport type { PrefetchTask } from './segment-cache-impl/scheduler'\nexport type { NormalizedSearch } from './segment-cache-impl/cache-key'\n\nconst notEnabled: any = () => {\n  throw new Error(\n    'Segment Cache experiment is not enabled. This is a bug in Next.js.'\n  )\n}\n\nexport const prefetch: typeof import('./segment-cache-impl/prefetch').prefetch =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/prefetch') as typeof import('./segment-cache-impl/prefetch')\n        ).prefetch(...args)\n      }\n    : notEnabled\n\nexport const navigate: typeof import('./segment-cache-impl/navigation').navigate =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/navigation') as typeof import('./segment-cache-impl/navigation')\n        ).navigate(...args)\n      }\n    : notEnabled\n\nexport const revalidateEntireCache: typeof import('./segment-cache-impl/cache').revalidateEntireCache =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')\n        ).revalidateEntireCache(...args)\n      }\n    : notEnabled\n\nexport const getCurrentCacheVersion: typeof import('./segment-cache-impl/cache').getCurrentCacheVersion =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')\n        ).getCurrentCacheVersion(...args)\n      }\n    : notEnabled\n\nexport const schedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').schedulePrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).schedulePrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const cancelPrefetchTask: typeof import('./segment-cache-impl/scheduler').cancelPrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).cancelPrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const reschedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').reschedulePrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).reschedulePrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const isPrefetchTaskDirty: typeof import('./segment-cache-impl/scheduler').isPrefetchTaskDirty =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).isPrefetchTaskDirty(...args)\n      }\n    : notEnabled\n\nexport const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache-key') as typeof import('./segment-cache-impl/cache-key')\n        ).createCacheKey(...args)\n      }\n    : notEnabled\n\n/**\n * Below are public constants. They're small enough that we don't need to\n * DCE them.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","import type { FlightRouterState } from '../../shared/lib/app-router-types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport {\n  FetchStrategy,\n  isPrefetchTaskDirty,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache'\nimport { createCacheKey } from './segment-cache'\nimport {\n  type PrefetchTask,\n  PrefetchPriority,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n} from './segment-cache'\nimport { startTransition } from 'react'\nimport { PrefetchKind } from './router-reducer/router-reducer-types'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  if (typeof window !== 'undefined') {\n    const { createPrefetchURL } =\n      require('./app-router-utils') as typeof import('./app-router-utils')\n\n    try {\n      return createPrefetchURL(href)\n    } catch {\n      // createPrefetchURL sometimes throws an error if an invalid URL is\n      // provided, though I'm not sure if it's actually necessary.\n      // TODO: Consider removing the throw from the inner function, or change it\n      // to reportError. Or maybe the error isn't even necessary for automatic\n      // prefetches, just navigations.\n      const reportErrorFn =\n        typeof reportError === 'function' ? reportError : console.error\n      reportErrorFn(\n        `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n      )\n      return null\n    }\n  } else {\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  // Ensures that app-router-instance is not compiled in the server bundle\n  if (typeof window !== 'undefined') {\n    const existingPrefetchTask = instance.prefetchTask\n\n    if (!instance.isVisible) {\n      // Cancel any in-progress prefetch task. (If it already finished then this\n      // is a no-op.)\n      if (existingPrefetchTask !== null) {\n        cancelPrefetchTask(existingPrefetchTask)\n      }\n      // We don't need to reset the prefetchTask to null upon cancellation; an\n      // old task object can be rescheduled with reschedulePrefetchTask. This is a\n      // micro-optimization but also makes the code simpler (don't need to\n      // worry about whether an old task object is stale).\n      return\n    }\n\n    if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n      // The old prefetch implementation does not have different priority levels.\n      // Just schedule a new prefetch task.\n      prefetchWithOldCacheImplementation(instance)\n      return\n    }\n\n    const { getCurrentAppRouterState } =\n      require('./app-router-instance') as typeof import('./app-router-instance')\n\n    const appRouterState = getCurrentAppRouterState()\n    if (appRouterState !== null) {\n      const treeAtTimeOfPrefetch = appRouterState.tree\n      if (existingPrefetchTask === null) {\n        // Initiate a prefetch task.\n        const nextUrl = appRouterState.nextUrl\n        const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n        instance.prefetchTask = scheduleSegmentPrefetchTask(\n          cacheKey,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority,\n          null\n        )\n      } else {\n        // We already have an old task object that we can reschedule. This is\n        // effectively the same as canceling the old task and creating a new one.\n        reschedulePrefetchTask(\n          existingPrefetchTask,\n          treeAtTimeOfPrefetch,\n          instance.fetchStrategy,\n          priority\n        )\n      }\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n\nfunction prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {\n  // This is the path used when the Segment Cache is not enabled.\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  const doPrefetch = async () => {\n    // note that `appRouter.prefetch()` is currently sync,\n    // so we have to wrap this call in an async function to be able to catch() errors below.\n\n    let prefetchKind: PrefetchKind\n    switch (instance.fetchStrategy) {\n      case FetchStrategy.PPR: {\n        prefetchKind = PrefetchKind.AUTO\n        break\n      }\n      case FetchStrategy.Full: {\n        prefetchKind = PrefetchKind.FULL\n        break\n      }\n      case FetchStrategy.PPRRuntime: {\n        // We can only get here if Client Segment Cache is off, and in that case\n        // it shouldn't be possible for a link to request a runtime prefetch.\n        throw new InvariantError(\n          'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'\n        )\n      }\n      default: {\n        instance.fetchStrategy satisfies never\n        // Unreachable, but otherwise typescript will consider the variable unassigned\n        prefetchKind = undefined!\n      }\n    }\n\n    return instance.router.prefetch(instance.prefetchHref, {\n      kind: prefetchKind,\n    })\n  }\n\n  // Prefetch the page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n  doPrefetch().catch((err) => {\n    if (process.env.NODE_ENV !== 'production') {\n      // rethrow to show invalid URL errors\n      throw err\n    }\n  })\n}\n","import { parsePath } from './parse-path'\n\n/**\n * Checks if a given path starts with a given prefix. It ensures it matches\n * exactly without containing extra chars. e.g. prefix /docs should replace\n * for /docs, /docs/, /docs/a but not /docsss\n * @param path The path to check.\n * @param prefix The prefix to check against.\n */\nexport function pathHasPrefix(path: string, prefix: string) {\n  if (typeof path !== 'string') {\n    return false\n  }\n\n  const { pathname } = parsePath(path)\n  return pathname === prefix || pathname.startsWith(prefix + '/')\n}\n","import { pathHasPrefix } from '../shared/lib/router/utils/path-has-prefix'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function hasBasePath(path: string): boolean {\n  return pathHasPrefix(path, basePath)\n}\n","import { isAbsoluteUrl, getLocationOrigin } from '../../utils'\nimport { hasBasePath } from '../../../../client/has-base-path'\n\n/**\n * Detects whether a given url is routable by the Next.js router (browser only).\n */\nexport function isLocalURL(url: string): boolean {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (!isAbsoluteUrl(url)) return true\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = getLocationOrigin()\n    const resolved = new URL(url, locationOrigin)\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname)\n  } catch (_) {\n    return false\n  }\n}\n","let errorOnce = (_: string) => {}\nif (process.env.NODE_ENV !== 'production') {\n  const errors = new Set<string>()\n  errorOnce = (msg: string) => {\n    if (!errors.has(msg)) {\n      console.error(msg)\n    }\n    errors.add(msg)\n  }\n}\n\nexport { errorOnce }\n","'use client'\n\nimport React, { createContext, useContext, useOptimistic, useRef } from 'react'\nimport type { UrlObject } from 'url'\nimport { formatUrl } from '../../shared/lib/router/utils/format-url'\nimport { AppRouterContext } from '../../shared/lib/app-router-context.shared-runtime'\nimport { useMergedRef } from '../use-merged-ref'\nimport { isAbsoluteUrl } from '../../shared/lib/utils'\nimport { addBasePath } from '../add-base-path'\nimport { warnOnce } from '../../shared/lib/utils/warn-once'\nimport type { PENDING_LINK_STATUS } from '../components/links'\nimport {\n  IDLE_LINK_STATUS,\n  mountLinkInstance,\n  onNavigationIntent,\n  unmountLinkForCurrentNavigation,\n  unmountPrefetchableInstance,\n  type LinkInstance,\n} from '../components/links'\nimport { isLocalURL } from '../../shared/lib/router/utils/is-local-url'\nimport {\n  FetchStrategy,\n  type PrefetchTaskFetchStrategy,\n} from '../components/segment-cache'\nimport { errorOnce } from '../../shared/lib/utils/error-once'\n\ntype Url = string | UrlObject\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K\n}[keyof T]\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never\n}[keyof T]\n\ntype OnNavigateEventHandler = (event: { preventDefault: () => void }) => void\n\ntype InternalLinkProps = {\n  /**\n   * **Required**. The path or URL to navigate to. It can also be an object (similar to `URL`).\n   *\n   * @example\n   * ```tsx\n   * // Navigate to /dashboard:\n   * <Link href=\"/dashboard\">Dashboard</Link>\n   *\n   * // Navigate to /about?name=test:\n   * <Link href={{ pathname: '/about', query: { name: 'test' } }}>\n   *   About\n   * </Link>\n   * ```\n   *\n   * @remarks\n   * - For external URLs, use a fully qualified URL such as `https://...`.\n   * - In the App Router, dynamic routes must not include bracketed segments in `href`.\n   */\n  href: Url\n\n  /**\n   * @deprecated v10.0.0: `href` props pointing to a dynamic route are\n   * automatically resolved and no longer require the `as` prop.\n   */\n  as?: Url\n\n  /**\n   * Replace the current `history` state instead of adding a new URL into the stack.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/about\" replace>\n   *   About (replaces the history state)\n   * </Link>\n   * ```\n   */\n  replace?: boolean\n\n  /**\n   * Whether to override the default scroll behavior. If `true`, Next.js attempts to maintain\n   * the scroll position if the newly navigated page is still visible. If not, it scrolls to the top.\n   *\n   * If `false`, Next.js will not modify the scroll behavior at all.\n   *\n   * @defaultValue `true`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" scroll={false}>\n   *   No auto scroll\n   * </Link>\n   * ```\n   */\n  scroll?: boolean\n\n  /**\n   * Update the path of the current page without rerunning data fetching methods\n   * like `getStaticProps`, `getServerSideProps`, or `getInitialProps`.\n   *\n   * @remarks\n   * `shallow` only applies to the Pages Router. For the App Router, see the\n   * [following documentation](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#using-the-native-history-api).\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/blog\" shallow>\n   *   Shallow navigation\n   * </Link>\n   * ```\n   */\n  shallow?: boolean\n\n  /**\n   * Forces `Link` to pass its `href` to the child component. Useful if the child is a custom\n   * component that wraps an `<a>` tag, or if you're using certain styling libraries.\n   *\n   * @defaultValue `false`\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" passHref legacyBehavior>\n   *   <MyStyledAnchor>Dashboard</MyStyledAnchor>\n   * </Link>\n   * ```\n   */\n  passHref?: boolean\n\n  /**\n   * Prefetch the page in the background.\n   * Any `<Link />` that is in the viewport (initially or through scroll) will be prefetched.\n   * Prefetch can be disabled by passing `prefetch={false}`.\n   *\n   * @remarks\n   * Prefetching is only enabled in production.\n   *\n   * - In the **App Router**:\n   *   - `\"auto\"`, `null`, `undefined` (default): Prefetch behavior depends on static vs dynamic routes:\n   *     - Static routes: fully prefetched\n   *     - Dynamic routes: partial prefetch to the nearest segment with a `loading.js`\n   *   - `true`: Always prefetch the full route and data.\n   *   - `false`: Disable prefetching on both viewport and hover.\n   * - In the **Pages Router**:\n   *   - `true` (default): Prefetches the route and data in the background on viewport or hover.\n   *   - `false`: Prefetch only on hover, not on viewport.\n   *\n   * @defaultValue `true` (Pages Router) or `null` (App Router)\n   *\n   * @example\n   * ```tsx\n   * <Link href=\"/dashboard\" prefetch={false}>\n   *   Dashboard\n   * </Link>\n   * ```\n   */\n  prefetch?: boolean | 'auto' | null | 'unstable_forceStale'\n\n  /**\n   * (unstable) Switch to a full prefetch on hover. Effectively the same as\n   * updating the prefetch prop to `true` in a mouse event.\n   */\n  unstable_dynamicOnHover?: boolean\n\n  /**\n   * The active locale is automatically prepended in the Pages Router. `locale` allows for providing\n   * a different locale, or can be set to `false` to opt out of automatic locale behavior.\n   *\n   * @remarks\n   * Note: locale only applies in the Pages Router and is ignored in the App Router.\n   *\n   * @example\n   * ```tsx\n   * // Use the 'fr' locale:\n   * <Link href=\"/about\" locale=\"fr\">\n   *   About (French)\n   * </Link>\n   *\n   * // Disable locale prefix:\n   * <Link href=\"/about\" locale={false}>\n   *   About (no locale prefix)\n   * </Link>\n   * ```\n   */\n  locale?: string | false\n\n  /**\n   * Enable legacy link behavior.\n   *\n   * @deprecated This will be removed in a future version\n   * @defaultValue `false`\n   * @see https://github.com/vercel/next.js/commit/489e65ed98544e69b0afd7e0cfc3f9f6c2b803b7\n   */\n  legacyBehavior?: boolean\n\n  /**\n   * Optional event handler for when the mouse pointer is moved onto the `<Link>`.\n   */\n  onMouseEnter?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is touched.\n   */\n  onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is clicked.\n   */\n  onClick?: React.MouseEventHandler<HTMLAnchorElement>\n\n  /**\n   * Optional event handler for when the `<Link>` is navigated.\n   */\n  onNavigate?: OnNavigateEventHandler\n}\n\n// TODO-APP: Include the full set of Anchor props\n// adding this to the publicly exported type currently breaks existing apps\n\n// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n// isn't generated yet. It will be replaced when type generation runs.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport type LinkProps<RouteInferType = any> = InternalLinkProps\ntype LinkPropsRequired = RequiredKeys<LinkProps>\ntype LinkPropsOptional = OptionalKeys<Omit<InternalLinkProps, 'locale'>>\n\nfunction isModifiedEvent(event: React.MouseEvent): boolean {\n  const eventTarget = event.currentTarget as HTMLAnchorElement | SVGAElement\n  const target = eventTarget.getAttribute('target')\n  return (\n    (target && target !== '_self') ||\n    event.metaKey ||\n    event.ctrlKey ||\n    event.shiftKey ||\n    event.altKey || // triggers resource download\n    (event.nativeEvent && event.nativeEvent.which === 2)\n  )\n}\n\nfunction linkClicked(\n  e: React.MouseEvent,\n  href: string,\n  as: string,\n  linkInstanceRef: React.RefObject<LinkInstance | null>,\n  replace?: boolean,\n  scroll?: boolean,\n  onNavigate?: OnNavigateEventHandler\n): void {\n  if (typeof window !== 'undefined') {\n    const { nodeName } = e.currentTarget\n\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === 'A'\n    if (\n      (isAnchorNodeName && isModifiedEvent(e)) ||\n      e.currentTarget.hasAttribute('download')\n    ) {\n      // ignore click for browsers default behavior\n      return\n    }\n\n    if (!isLocalURL(href)) {\n      if (replace) {\n        // browser default behavior does not replace the history state\n        // so we need to do it manually\n        e.preventDefault()\n        location.replace(href)\n      }\n\n      // ignore click for browsers default behavior\n      return\n    }\n\n    e.preventDefault()\n\n    if (onNavigate) {\n      let isDefaultPrevented = false\n\n      onNavigate({\n        preventDefault: () => {\n          isDefaultPrevented = true\n        },\n      })\n\n      if (isDefaultPrevented) {\n        return\n      }\n    }\n\n    const { dispatchNavigateAction } =\n      require('../components/app-router-instance') as typeof import('../components/app-router-instance')\n\n    React.startTransition(() => {\n      dispatchNavigateAction(\n        as || href,\n        replace ? 'replace' : 'push',\n        scroll ?? true,\n        linkInstanceRef.current\n      )\n    })\n  }\n}\n\nfunction formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n  if (typeof urlObjOrString === 'string') {\n    return urlObjOrString\n  }\n\n  return formatUrl(urlObjOrString)\n}\n\n/**\n * A React component that extends the HTML `<a>` element to provide\n * [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation. This is the primary way to navigate between routes in Next.js.\n *\n * @remarks\n * - Prefetching is only enabled in production.\n *\n * @see https://nextjs.org/docs/app/api-reference/components/link\n */\nexport default function LinkComponent(\n  props: LinkProps & {\n    children: React.ReactNode\n    ref: React.Ref<HTMLAnchorElement>\n  }\n) {\n  const [linkStatus, setOptimisticLinkStatus] = useOptimistic(IDLE_LINK_STATUS)\n\n  let children: React.ReactNode\n\n  const linkInstanceRef = useRef<LinkInstance | null>(null)\n\n  const {\n    href: hrefProp,\n    as: asProp,\n    children: childrenProp,\n    prefetch: prefetchProp = null,\n    passHref,\n    replace,\n    shallow,\n    scroll,\n    onClick,\n    onMouseEnter: onMouseEnterProp,\n    onTouchStart: onTouchStartProp,\n    legacyBehavior = false,\n    onNavigate,\n    ref: forwardedRef,\n    unstable_dynamicOnHover,\n    ...restProps\n  } = props\n\n  children = childrenProp\n\n  if (\n    legacyBehavior &&\n    (typeof children === 'string' || typeof children === 'number')\n  ) {\n    children = <a>{children}</a>\n  }\n\n  const router = React.useContext(AppRouterContext)\n\n  const prefetchEnabled = prefetchProp !== false\n\n  const fetchStrategy =\n    prefetchProp !== false\n      ? getFetchStrategyFromPrefetchProp(prefetchProp)\n      : // TODO: it makes no sense to assign a fetchStrategy when prefetching is disabled.\n        FetchStrategy.PPR\n\n  if (process.env.NODE_ENV !== 'production') {\n    function createPropError(args: {\n      key: string\n      expected: string\n      actual: string\n    }) {\n      return new Error(\n        `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n          (typeof window !== 'undefined'\n            ? \"\\nOpen your browser's console to view the Component stack trace.\"\n            : '')\n      )\n    }\n\n    // TypeScript trick for type-guarding:\n    const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n      href: true,\n    } as const\n    const requiredProps: LinkPropsRequired[] = Object.keys(\n      requiredPropsGuard\n    ) as LinkPropsRequired[]\n    requiredProps.forEach((key: LinkPropsRequired) => {\n      if (key === 'href') {\n        if (\n          props[key] == null ||\n          (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n        ) {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key],\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n\n    // TypeScript trick for type-guarding:\n    const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      unstable_dynamicOnHover: true,\n      onClick: true,\n      onMouseEnter: true,\n      onTouchStart: true,\n      legacyBehavior: true,\n      onNavigate: true,\n    } as const\n    const optionalProps: LinkPropsOptional[] = Object.keys(\n      optionalPropsGuard\n    ) as LinkPropsOptional[]\n    optionalProps.forEach((key: LinkPropsOptional) => {\n      const valType = typeof props[key]\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'onClick' ||\n        key === 'onMouseEnter' ||\n        key === 'onTouchStart' ||\n        key === 'onNavigate'\n      ) {\n        if (props[key] && valType !== 'function') {\n          throw createPropError({\n            key,\n            expected: '`function`',\n            actual: valType,\n          })\n        }\n      } else if (\n        key === 'replace' ||\n        key === 'scroll' ||\n        key === 'shallow' ||\n        key === 'passHref' ||\n        key === 'legacyBehavior' ||\n        key === 'unstable_dynamicOnHover'\n      ) {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: valType,\n          })\n        }\n      } else if (key === 'prefetch') {\n        if (\n          props[key] != null &&\n          valType !== 'boolean' &&\n          props[key] !== 'auto' &&\n          props[key] !== 'unstable_forceStale'\n        ) {\n          throw createPropError({\n            key,\n            expected: '`boolean | \"auto\" | \"unstable_forceStale\"`',\n            actual: valType,\n          })\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        const _: never = key\n      }\n    })\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (props.locale) {\n      warnOnce(\n        'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n      )\n    }\n    if (!asProp) {\n      let href: string | undefined\n      if (typeof hrefProp === 'string') {\n        href = hrefProp\n      } else if (\n        typeof hrefProp === 'object' &&\n        typeof hrefProp.pathname === 'string'\n      ) {\n        href = hrefProp.pathname\n      }\n\n      if (href) {\n        const hasDynamicSegment = href\n          .split('/')\n          .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n\n        if (hasDynamicSegment) {\n          throw new Error(\n            `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n          )\n        }\n      }\n    }\n  }\n\n  const { href, as } = React.useMemo(() => {\n    const resolvedHref = formatStringOrUrl(hrefProp)\n    return {\n      href: resolvedHref,\n      as: asProp ? formatStringOrUrl(asProp) : resolvedHref,\n    }\n  }, [hrefProp, asProp])\n\n  // This will return the first child, if multiple are provided it will throw an error\n  let child: any\n  if (legacyBehavior) {\n    if ((children as any)?.$$typeof === Symbol.for('react.lazy')) {\n      throw new Error(\n        `\\`<Link legacyBehavior>\\` received a direct child that is either a Server Component, or JSX that was loaded with React.lazy(). This is not supported. Either remove legacyBehavior, or make the direct child a Client Component that renders the Link's \\`<a>\\` tag.`\n      )\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      if (onClick) {\n        console.warn(\n          `\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n        )\n      }\n      if (onMouseEnterProp) {\n        console.warn(\n          `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n        )\n      }\n      try {\n        child = React.Children.only(children)\n      } catch (err) {\n        if (!children) {\n          throw new Error(\n            `No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n          )\n        }\n        throw new Error(\n          `Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n            (typeof window !== 'undefined'\n              ? \" \\nOpen your browser's console to view the Component stack trace.\"\n              : '')\n        )\n      }\n    } else {\n      child = React.Children.only(children)\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if ((children as any)?.type === 'a') {\n        throw new Error(\n          'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n        )\n      }\n    }\n  }\n\n  const childRef: any = legacyBehavior\n    ? child && typeof child === 'object' && child.ref\n    : forwardedRef\n\n  // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n  // mount. In the future we will also use this to keep track of all the\n  // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n  // a revalidation or refresh.\n  const observeLinkVisibilityOnMount = React.useCallback(\n    (element: HTMLAnchorElement | SVGAElement) => {\n      if (router !== null) {\n        linkInstanceRef.current = mountLinkInstance(\n          element,\n          href,\n          router,\n          fetchStrategy,\n          prefetchEnabled,\n          setOptimisticLinkStatus\n        )\n      }\n\n      return () => {\n        if (linkInstanceRef.current) {\n          unmountLinkForCurrentNavigation(linkInstanceRef.current)\n          linkInstanceRef.current = null\n        }\n        unmountPrefetchableInstance(element)\n      }\n    },\n    [prefetchEnabled, href, router, fetchStrategy, setOptimisticLinkStatus]\n  )\n\n  const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n\n  const childProps: {\n    onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n    onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n    onClick: React.MouseEventHandler<HTMLAnchorElement>\n    href?: string\n    ref?: any\n  } = {\n    ref: mergedRef,\n    onClick(e) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (!e) {\n          throw new Error(\n            `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n          )\n        }\n      }\n\n      if (!legacyBehavior && typeof onClick === 'function') {\n        onClick(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onClick === 'function'\n      ) {\n        child.props.onClick(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (e.defaultPrevented) {\n        return\n      }\n      linkClicked(e, href, as, linkInstanceRef, replace, scroll, onNavigate)\n    },\n    onMouseEnter(e) {\n      if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n        onMouseEnterProp(e)\n      }\n\n      if (\n        legacyBehavior &&\n        child.props &&\n        typeof child.props.onMouseEnter === 'function'\n      ) {\n        child.props.onMouseEnter(e)\n      }\n\n      if (!router) {\n        return\n      }\n      if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n        return\n      }\n\n      const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n      onNavigationIntent(\n        e.currentTarget as HTMLAnchorElement | SVGAElement,\n        upgradeToDynamicPrefetch\n      )\n    },\n    onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n      ? undefined\n      : function onTouchStart(e) {\n          if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n            onTouchStartProp(e)\n          }\n\n          if (\n            legacyBehavior &&\n            child.props &&\n            typeof child.props.onTouchStart === 'function'\n          ) {\n            child.props.onTouchStart(e)\n          }\n\n          if (!router) {\n            return\n          }\n          if (!prefetchEnabled) {\n            return\n          }\n\n          const upgradeToDynamicPrefetch = unstable_dynamicOnHover === true\n          onNavigationIntent(\n            e.currentTarget as HTMLAnchorElement | SVGAElement,\n            upgradeToDynamicPrefetch\n          )\n        },\n  }\n\n  // If the url is absolute, we can bypass the logic to prepend the basePath.\n  if (isAbsoluteUrl(as)) {\n    childProps.href = as\n  } else if (\n    !legacyBehavior ||\n    passHref ||\n    (child.type === 'a' && !('href' in child.props))\n  ) {\n    childProps.href = addBasePath(as)\n  }\n\n  let link: React.ReactNode\n\n  if (legacyBehavior) {\n    if (process.env.NODE_ENV === 'development') {\n      errorOnce(\n        '`legacyBehavior` is deprecated and will be removed in a future ' +\n          'release. A codemod is available to upgrade your components:\\n\\n' +\n          'npx @next/codemod@latest new-link .\\n\\n' +\n          'Learn more: https://nextjs.org/docs/app/building-your-application/upgrading/codemods#remove-a-tags-from-link-components'\n      )\n    }\n    link = React.cloneElement(child, childProps)\n  } else {\n    link = (\n      <a {...restProps} {...childProps}>\n        {children}\n      </a>\n    )\n  }\n\n  return (\n    <LinkStatusContext.Provider value={linkStatus}>\n      {link}\n    </LinkStatusContext.Provider>\n  )\n}\n\nconst LinkStatusContext = createContext<\n  typeof PENDING_LINK_STATUS | typeof IDLE_LINK_STATUS\n>(IDLE_LINK_STATUS)\n\nexport const useLinkStatus = () => {\n  return useContext(LinkStatusContext)\n}\n\nfunction getFetchStrategyFromPrefetchProp(\n  prefetchProp: Exclude<LinkProps['prefetch'], undefined | false>\n): PrefetchTaskFetchStrategy {\n  if (\n    process.env.__NEXT_CACHE_COMPONENTS &&\n    process.env.__NEXT_CLIENT_SEGMENT_CACHE\n  ) {\n    // In the new implementation:\n    // - `prefetch={true}` is a runtime prefetch\n    //   (includes cached IO + params + cookies, with dynamic holes for uncached IO).\n    // - `unstable_forceStale` is a \"full\" prefetch\n    //   (forces inclusion of all dynamic data, i.e. the old behavior of `prefetch={true}`)\n    if (prefetchProp === true) {\n      return FetchStrategy.PPRRuntime\n    }\n    if (prefetchProp === 'unstable_forceStale') {\n      return FetchStrategy.Full\n    }\n\n    // `null` or `\"auto\"`: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport.\n    // This will also include invalid prop values that don't match the types specified here.\n    // (although those should've been filtered out by prop validation in dev)\n    prefetchProp satisfies null | 'auto'\n    // In `clientSegmentCache`, we default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n    // If we're not using `clientSegmentCache`, this will be converted into a `PrefetchKind.AUTO`.\n    return FetchStrategy.PPR\n  } else {\n    return prefetchProp === null || prefetchProp === 'auto'\n      ? // In `clientSegmentCache`, we default to PPR, and we'll discover whether or not the route supports it with the initial prefetch.\n        // If we're not using `clientSegmentCache`, this will be converted into a `PrefetchKind.AUTO`.\n        FetchStrategy.PPR\n      : // In the old implementation without runtime prefetches, `prefetch={true}` forces all dynamic data to be prefetched.\n        // To preserve backwards-compatibility, anything other than `false`, `null`, or `\"auto\"` results in a full prefetch.\n        // (although invalid values should've been filtered out by prop validation in dev)\n        FetchStrategy.Full\n  }\n}\n","import{useRouter as e,usePathname as t}from\"next/navigation\";import{useMemo as r}from\"react\";import{useLocale as o}from\"use-intl\";import n from\"../shared/createSharedNavigationFns.js\";import a from\"../shared/syncLocaleCookie.js\";import{getRoute as s}from\"../shared/utils.js\";import i from\"./useBasePathname.js\";function c(c){const{Link:u,config:m,getPathname:f,...h}=n(o,c);return{...h,Link:u,usePathname:function(){const e=i(m),t=o();return r((()=>e&&m.pathnames?s(t,e,m.pathnames):e),[t,e])},useRouter:function(){const n=e(),s=o(),i=t();return r((()=>{function e(e){return function(t,r){const{locale:o,...n}=r||{},c=[f({href:t,locale:o||s,forcePrefix:null!=o||void 0})];Object.keys(n).length>0&&c.push(n),a(m.localeCookie,i,s,o),e(...c)}}return{...n,push:e(n.push),replace:e(n.replace),prefetch:e(n.prefetch)}}),[s,i,n])},getPathname:f}}export{c as default};\n","function e(e){return{...e,localePrefix:(a=e.localePrefix,\"object\"==typeof a?a:{mode:a||\"always\"}),localeCookie:(o=e.localeCookie,!!(o??1)&&{name:\"NEXT_LOCALE\",sameSite:\"lax\",...\"object\"==typeof o&&o}),localeDetection:e.localeDetection??!0,alternateLinks:e.alternateLinks??!0};var o,a}export{e as receiveRoutingConfig};\n","import*as r from\"react\";var a=r[\"use\".trim()];export{a as default};\n","function n(n){return function(n){return\"object\"==typeof n?null==n.host&&null==n.hostname:!/^[a-z]+:/i.test(n)}(n)&&!function(n){const t=\"object\"==typeof n?n.pathname:n;return null!=t&&!t.startsWith(\"/\")}(n)}function t(n,t){return n.replace(new RegExp(`^${t}`),\"\")||\"/\"}function e(n,t){let e=n;return/^\\/(\\?.*)?$/.test(t)&&(t=t.slice(1)),e+=t,e}function r(n,t){return t===n||t.startsWith(`${n}/`)}function u(n,t,e){return\"string\"==typeof n?n:n[t]||e}function i(n){const t=function(){try{return\"true\"===process.env._next_intl_trailing_slash}catch{return!1}}(),[e,...r]=n.split(\"#\"),u=r.join(\"#\");let i=e;if(\"/\"!==i){const n=i.endsWith(\"/\");t&&!n?i+=\"/\":!t&&n&&(i=i.slice(0,-1))}return u&&(i+=\"#\"+u),i}function c(n,t){const e=i(n),r=i(t);return s(e).test(r)}function o(n,t){return\"never\"!==t.mode&&t.prefixes?.[n]||f(n)}function f(n){return\"/\"+n}function s(n){const t=n.replace(/\\[\\[(\\.\\.\\.[^\\]]+)\\]\\]/g,\"?(.*)\").replace(/\\[(\\.\\.\\.[^\\]]+)\\]/g,\"(.+)\").replace(/\\[([^\\]]+)\\]/g,\"([^/]+)\");return new RegExp(`^${t}$`)}function l(n){return n.includes(\"[[...\")}function p(n){return n.includes(\"[...\")}function a(n){return n.includes(\"[\")}function h(n,t){const e=n.split(\"/\"),r=t.split(\"/\"),u=Math.max(e.length,r.length);for(let n=0;n<u;n++){const t=e[n],u=r[n];if(!t&&u)return-1;if(t&&!u)return 1;if(t||u){if(!a(t)&&a(u))return-1;if(a(t)&&!a(u))return 1;if(!p(t)&&p(u))return-1;if(p(t)&&!p(u))return 1;if(!l(t)&&l(u))return-1;if(l(t)&&!l(u))return 1}}return 0}function g(n){return n.sort(h)}function x(n){return\"function\"==typeof n.then}export{f as getLocaleAsPrefix,o as getLocalePrefix,u as getLocalizedTemplate,g as getSortedPathnames,r as hasPathnamePrefixed,n as isLocalizableHref,x as isPromise,c as matchesPathname,i as normalizeTrailingSlash,e as prefixPathname,s as templateToRegex,t as unprefixPathname};\n","\"use client\";\nimport o from\"next/link\";import{usePathname as r}from\"next/navigation\";import{forwardRef as e}from\"react\";import{useLocale as t}from\"use-intl\";import i from\"./syncLocaleCookie.js\";import{jsx as n}from\"react/jsx-runtime\";function f({href:e,locale:f,localeCookie:c,onClick:m,prefetch:l,...a},p){const s=t(),u=null!=f&&f!==s,h=r();u&&(l=!1);return n(o,{ref:p,href:e,hrefLang:u?f:void 0,onClick:function(o){i(c,h,s,f),m&&m(o)},prefetch:l,...a})}var c=e(f);export{c as default};\n","import{getSortedPathnames as e,matchesPathname as n,isLocalizableHref as t,prefixPathname as r,normalizeTrailingSlash as o,getLocalizedTemplate as a,getLocalePrefix as i}from\"../../shared/utils.js\";function c(e){return\"string\"==typeof e?{pathname:e}:e}function s(e){function n(e){return String(e)}const t=new URLSearchParams;for(const[r,o]of Object.entries(e))Array.isArray(o)?o.forEach((e=>{t.append(r,n(e))})):t.set(r,n(o));return\"?\"+t.toString()}function f({pathname:e,locale:n,params:t,pathnames:r,query:i}){function c(e){const c=r[e];let f;if(c){const r=a(c,n,e);f=r,t&&Object.entries(t).forEach((([e,n])=>{let t,r;Array.isArray(n)?(t=`(\\\\[)?\\\\[...${e}\\\\](\\\\])?`,r=n.map((e=>String(e))).join(\"/\")):(t=`\\\\[${e}\\\\]`,r=String(n)),f=f.replace(new RegExp(t,\"g\"),r)})),f=f.replace(/\\[\\[\\.\\.\\..+\\]\\]/g,\"\"),f=function(e){return new URL(e,\"http://l\").pathname}(f)}else f=e;return f=o(f),i&&(f+=s(i)),f}if(\"string\"==typeof e)return c(e);{const{pathname:n,...t}=e;return{...t,pathname:c(n)}}}function u(t,r,o){const i=e(Object.keys(o)),c=decodeURI(r);for(const e of i){const r=o[e];if(\"string\"==typeof r){if(n(r,c))return e}else if(n(a(r,t,e),c))return e}return r}function l(e,n=window.location.pathname){return\"/\"===e?n:n.replace(e,\"\")}function p(e,n,o,a){const{mode:c}=o.localePrefix;let s;return void 0!==a?s=a:t(e)&&(\"always\"===c?s=!0:\"as-needed\"===c&&(s=o.domains?!o.domains.some((e=>e.defaultLocale===n)):n!==o.defaultLocale)),s?r(i(n,o.localePrefix),e):e}export{p as applyPathnamePrefix,f as compileLocalizedPathname,l as getBasePath,u as getRoute,c as normalizeNameOrNameWithParams,s as serializeSearchParams};\n","import{getBasePath as t}from\"./utils.js\";function e(e,o,n,a){if(!e||!(a!==n&&null!=a)||!o)return;const f=t(o),r=\"\"!==f?f:\"/\",{name:c,...i}=e;i.path||(i.path=r);let l=`${c}=${a};`;for(const[t,e]of Object.entries(i)){l+=`${\"maxAge\"===t?\"max-age\":t}`,\"boolean\"!=typeof e&&(l+=\"=\"+e),l+=\";\"}document.cookie=l}export{e as default};\n","import{redirect as e,permanentRedirect as t}from\"next/navigation\";import{forwardRef as o}from\"react\";import{receiveRoutingConfig as r}from\"../../routing/config.js\";import n from\"../../shared/use.js\";import{isLocalizableHref as a,isPromise as i}from\"../../shared/utils.js\";import c from\"./BaseLink.js\";import{serializeSearchParams as f,compileLocalizedPathname as m,applyPathnamePrefix as l,normalizeNameOrNameWithParams as s}from\"./utils.js\";import{jsx as p}from\"react/jsx-runtime\";function u(u,h){const j=r(h||{}),d=j.pathnames;function g({href:e,locale:t,...o},r){let f,m;\"object\"==typeof e?(f=e.pathname,m=e.params):f=e;const l=a(e),s=u(),h=i(s)?n(s):s,g=l?y({locale:t||h,href:null==d?f:{pathname:f,params:m},forcePrefix:null!=t||void 0}):f;return p(c,{ref:r,href:\"object\"==typeof e?{...e,pathname:g}:g,locale:t,localeCookie:j.localeCookie,...o})}const x=o(g);function y(e){const{forcePrefix:t,href:o,locale:r}=e;let n;return null==d?\"object\"==typeof o?(n=o.pathname,o.query&&(n+=f(o.query))):n=o:n=m({locale:r,...s(o),pathnames:j.pathnames}),l(n,r,j,t)}function k(e){return function(t,...o){return e(y(t),...o)}}const b=k(e),P=k(t);return{config:j,Link:x,redirect:b,permanentRedirect:P,getPathname:y}}export{u as default};\n","import{usePathname as e}from\"next/navigation\";import{useMemo as r}from\"react\";import{useLocale as o}from\"use-intl\";import{hasPathnamePrefixed as t,unprefixPathname as i,getLocalePrefix as f,getLocaleAsPrefix as l}from\"../../shared/utils.js\";function n(n){const s=e(),a=o();return r((()=>{if(!s)return s;let e=s;const r=f(a,n.localePrefix);if(t(r,s))e=i(s,r);else if(\"never\"!==n.localePrefix.mode&&n.localePrefix.prefixes){const r=l(a);t(r,s)&&(e=i(s,r))}return e}),[n.localePrefix,a,s])}export{n as default};\n","function t(t){return t}export{t as default};\n","import { defineRouting } from 'next-intl/routing'\n\n/**\n * i18n \n * Feature Sliced Design  shared/config \n */\nexport const routing = defineRouting({\n  // \n  locales: ['en', 'ja'],\n\n  // \n  defaultLocale: 'en',\n})\n\n// TypeScript \nexport type Locale = (typeof routing.locales)[number]\n","import { createNavigation } from 'next-intl/navigation'\nimport { routing } from '@/shared/config/i18n'\n\n/**\n *  API\n * Feature Sliced Design  shared/lib \n *\n * Next.js  API \n * \n */\nexport const { Link, redirect, usePathname, useRouter, getPathname } =\n  createNavigation(routing)\n","'use client'\n\nimport { Link } from '@/shared/lib/i18n'\n\n/**\n * Client Component\n * Client Component\n */\nexport function LanguageSwitcher() {\n  return (\n    <div className=\"flex gap-4\">\n      <Link\n        href=\"/\"\n        locale=\"en\"\n        className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors\"\n      >\n        English\n      </Link>\n      <Link\n        href=\"/\"\n        locale=\"ja\"\n        className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors\"\n      >\n        \n      </Link>\n    </div>\n  )\n}\n"],"names":["getImageBlurSvg","widthInt","heightInt","blurWidth","blurHeight","blurDataURL","objectFit","std","svgWidth","svgHeight","viewBox","preserveAspectRatio","VALID_LOADERS","imageConfigDefault","deviceSizes","imageSizes","path","loader","loaderFile","domains","disableStaticImages","minimumCacheTTL","formats","maximumRedirects","dangerouslyAllowLocalIP","dangerouslyAllowSVG","contentSecurityPolicy","contentDispositionType","localPatterns","undefined","remotePatterns","qualities","unoptimized","getImgProps","VALID_LOADING_VALUES","INVALID_BACKGROUND_SIZE_VALUES","isStaticRequire","src","default","isStaticImageData","isStaticImport","allImgs","Map","perfObserver","getInt","x","Number","isFinite","NaN","test","parseInt","getWidths","allSizes","width","sizes","viewportWidthRe","percentSizes","match","exec","push","length","smallestRatio","Math","min","widths","filter","s","kind","Set","map","w","find","p","generateImgAttrs","config","quality","srcSet","last","i","join","priority","preload","loading","className","height","fill","style","overrideSrc","onLoad","onLoadingComplete","placeholder","fetchPriority","decoding","layout","objectPosition","lazyBoundary","lazyRoot","rest","_state","imgConf","showAltText","blurComplete","defaultLoader","c","sort","a","b","Error","isDefaultLoader","customImageLoader","obj","_","opts","layoutToStyle","intrinsic","maxWidth","responsive","layoutToSizes","layoutStyle","layoutSizes","staticSrc","staticImageData","JSON","stringify","ratio","round","isLazy","startsWith","split","endsWith","qualityInt","process","env","NODE_ENV","output","position","isNaN","includes","String","warnOnce","VALID_BLUR_EXT","urlStr","url","URL","err","pathname","search","legacyKey","legacyValue","Object","entries","window","PerformanceObserver","entryList","entry","getEntries","imgSrc","element","lcpImage","get","observe","type","buffered","console","error","imgStyle","assign","left","top","right","bottom","color","backgroundImage","backgroundSize","placeholderStyle","backgroundPosition","backgroundRepeat","imgAttributes","loadingFinal","fullUrl","e","location","href","set","props","meta","module","exports","require","vendored","ImageConfigContext","RouterContext","findClosestQuality","q","reduce","prev","cur","abs","missingValues","NEXT_RUNTIME","hasLocalMatch","parsedSrc","hasRemoteMatch","hostname","encodeURIComponent","NEXT_DEPLOYMENT_ID","__next_img_default","useMergedRef","refA","refB","cleanupA","useRef","cleanupB","useCallback","current","cleanupFnA","cleanupFnB","applyRef","cleanup","Image","configEnv","__NEXT_IMAGE_OPTS","globalThis","__NEXT_IMAGE_IMPORTED","handleLoading","img","onLoadRef","onLoadingCompleteRef","setBlurComplete","sizesInput","decode","Promise","resolve","catch","then","parentElement","isConnected","event","Event","defineProperty","writable","value","prevented","stopped","nativeEvent","currentTarget","target","isDefaultPrevented","isPropagationStopped","persist","preventDefault","stopPropagation","origSrc","searchParams","getAttribute","widthViewportRatio","getBoundingClientRect","innerWidth","getComputedStyle","valid","heightModified","toString","widthModified","getDynamicProps","Boolean","use","fetchpriority","ImageElement","forwardRef","setShowAltText","onError","forwardedRef","ownRef","complete","ref","data-nimg","ImagePreload","isAppRouter","as","imageSrcSet","crossOrigin","referrerPolicy","ReactDOM","Head","link","rel","pagesRouter","useContext","configContext","useMemo","useEffect","useState","imgMeta","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","computeSelectedLayoutSegment","getSegmentValue","getSelectedLayoutSegmentPath","isGroupSegment","isParallelRouteSegment","segment","Array","isArray","isPageSegment","stringifiedQuery","segments","parallelRouteKey","rawSegment","tree","first","segmentPath","node","parallelRoutes","children","values","segmentValue","ReadonlyURLSearchParams","ReadonlyURLSearchParamsError","constructor","URLSearchParams","append","delete","UnrecognizedActionError","unstable_isUnrecognizedActionError","args","name","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","digest","errorCode","destination","slice","status","at","statusCode","getRedirectError","getRedirectStatusCodeFromError","getRedirectTypeFromError","getURLFromRedirectError","permanentRedirect","redirect","actionAsyncStorage","TemporaryRedirect","getStore","isAction","replace","PermanentRedirect","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","prefix","httpStatus","has","notFound","DIGEST","forbidden","__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS","unauthorized","isHangingPromiseRejectionError","makeDevtoolsIOAwarePromise","makeHangingPromise","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","route","expression","abortListenersBySignal","WeakMap","signal","aborted","reject","hangingPromise","boundRejection","bind","currentListeners","listeners","addEventListener","once","ignoreReject","underlying","requestStore","stage","stagedRendering","delayUntilStage","setTimeout","isPostpone","REACT_POSTPONE_TYPE","Symbol","for","$$typeof","BailoutToCSRError","isBailoutToCSRError","BAILOUT_TO_CSR","reason","isNextRouterError","DynamicServerError","isDynamicServerError","DYNAMIC_ERROR_CODE","description","StaticGenBailoutError","isStaticGenBailoutError","NEXT_STATIC_GEN_BAILOUT","code","METADATA_BOUNDARY_NAME","OUTLET_BOUNDARY_NAME","ROOT_LAYOUT_BOUNDARY_NAME","VIEWPORT_BOUNDARY_NAME","atLeastOneTask","scheduleImmediate","scheduleOnNextTick","waitAtLeastOneReactRenderTask","cb","nextTick","setImmediate","r","InvariantError","message","options","createPromiseWithResolvers","promise","res","rej","RenderStage","StagedRenderingController","abortSignal","currentStage","runtimeStagePromise","dynamicStagePromise","advanceStage","getStagePromise","waitForStage","displayName","resolvedValue","ioTriggerPromise","makeDevtoolsIOPromiseFromIOTrigger","ioTrigger","Postpone","PreludeState","abortAndThrowOnSynchronousRequestDataAccess","abortOnSynchronousPlatformIOAccess","accessedDynamicData","annotateDynamicAccess","consumeDynamicAccess","createDynamicTrackingState","createDynamicValidationState","createHangingInputAbortSignal","createRenderInBrowserAbortSignal","delayUntilRuntimeStage","formatDynamicAPIAccesses","getFirstDynamicReason","isDynamicPostpone","isPrerenderInterruptedError","logDisallowedDynamicError","markCurrentScopeAsDynamic","postponeWithTracking","throwIfDisallowedDynamic","throwToInterruptStaticGeneration","trackAllowedDynamicAccess","trackDynamicDataInDynamicRender","trackSynchronousPlatformIOAccessInDev","useDynamicRouteParams","useDynamicSearchParams","hasPostpone","React","unstable_postpone","isDebugDynamicAccesses","dynamicAccesses","syncDynamicErrorWithStack","hasSuspenseAboveBody","hasDynamicMetadata","hasDynamicViewport","hasAllowedDynamic","dynamicErrors","trackingState","store","workUnitStore","forceDynamic","forceStatic","dynamicShouldError","dynamicTracking","revalidate","dynamicUsageDescription","dynamicUsageStack","stack","usedDynamic","prerenderStore","abortOnSynchronousDynamicDataAccess","createPrerenderInterruptedError","controller","abort","errorWithStack","Dynamic","prerenderSignal","workUnitAsyncStorage","assertPostpone","createPostponeReason","isDynamicPostponeReason","NEXT_PRERENDER_INTERRUPTED","serverDynamic","clientDynamic","access","line","AbortController","cacheSignal","inputReady","getRuntimeStagePromise","workStore","workAsyncStorage","fallbackParams","fallbackRouteParams","size","renderSignal","throwForMissingRequestStore","hasSuspenseRegex","bodyAndImplicitTags","hasSuspenseBeforeRootLayoutWithoutBodyOrImplicitBodyRegex","RegExp","hasMetadataRegex","hasViewportRegex","hasOutletRegex","componentStack","dynamicValidation","createErrorWithComponentOrOwnerStack","ownerStack","captureOwnerStack","dev","hasReadableErrorStacks","prelude","result","unstable_rethrow","cause","ServerInsertedHTMLContext","useParams","usePathname","useRouter","useSearchParams","useSelectedLayoutSegment","useSelectedLayoutSegments","useServerInsertedHTML","SearchParamsContext","readonlySearchParams","navigationPromises","NavigationPromisesContext","PathnameContext","router","AppRouterContext","params","PathParamsContext","context","LayoutRouterContext","selectedLayoutSegmentsPromises","parentTree","selectedLayoutSegments","selectedLayoutSegmentPromises","searchParamsToUrlQuery","urlQueryToSearchParams","query","key","existing","stringifyUrlQueryParam","param","item","searchParamsList","keys","formatUrl","formatWithValidation","urlObjectKeys","slashedProtocols","urlObj","auth","protocol","hash","host","indexOf","port","querystring","slashes","forEach","warn","DecodeError","MiddlewareNotFoundError","MissingStaticPage","NormalizeError","PageNotFoundError","SP","ST","WEB_VITALS","execOnce","getDisplayName","getLocationOrigin","getURL","isAbsoluteUrl","isResSent","loadGetInitialProps","normalizeRepeatedSlashes","stringifyError","fn","used","ABSOLUTE_URL_REGEX","origin","substring","Component","finished","headersSent","urlParts","urlNoQuery","App","ctx","prototype","getInitialProps","pageProps","performance","every","method","page","parsePath","hashIndex","queryIndex","hasQuery","addPathPrefix","removeTrailingSlash","normalizePathTrailingSlash","__NEXT_MANUAL_TRAILING_SLASH","__NEXT_TRAILING_SLASH","addBasePath","basePath","__NEXT_ROUTER_BASEPATH","required","__NEXT_MANUAL_CLIENT_BASE_PATH","HTML_LIMITED_BOT_UA_RE","HTML_LIMITED_BOT_UA_RE_STRING","getBotType","isBot","HEADLESS_BROWSER_BOT_UA_RE","source","isDomBotUA","userAgent","isHtmlLimitedBotUA","createPrefetchURL","isExternalURL","navigator","createCacheKey","originalHref","nextUrl","originalUrl","cacheKey","HasLoadingBoundary","matchSegment","existingSegment","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_HTML_REQUEST_ID_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REQUEST_ID_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","PrefetchKind","isThenable","dispatchAppRouterAction","useActionQueue","dispatch","action","actionQueue","state","setState","useAppDevRenderingIndicator","appDevRenderingIndicator","stateWithDebugInfo","debugInfo","promiseWithDebugInfo","asyncState","_debugInfo","callServer","actionId","actionArgs","startTransition","findSourceMapURL","filename","document","ROOT_SEGMENT_CACHE_KEY","ROOT_SEGMENT_REQUEST_KEY","appendSegmentCacheKeyPart","appendSegmentRequestKeyPart","convertSegmentPathToStaticExportFilename","createSegmentCacheKeyPart","createSegmentRequestKeyPart","safeName","encodeToFilesystemAndURLSafeString","paramType","encodedName","parentRequestKey","childRequestKeyPart","slotKey","requestKeyPart","paramValue","safeValue","parentSegmentKey","childCacheKeyPart","simpleParamValueRegex","base64url","btoa","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlSearchParamsToParsedUrlQuery","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","rewrittenPath","pathnameParts","partIndex","renderedSearch","pageSegmentWithSearchParams","fromEntries","urlWithoutFlightParameters","__NEXT_CONFIG_OUTPUT","paramCacheKey","isCatchAll","createHrefFromUrl","includeHash","createInitialRSCPayloadFromFallbackPrerender","getFlightDataPartsFromPath","getNextFlightSegmentPath","normalizeFlightData","prepareFlightRouterStateForRequest","flightDataPath","flightDataPathLength","seedData","head","isHeadPartial","pathToSegment","isRootRender","fallbackInitialRSCPayload","renderedPathname","canonicalUrl","originalFlightDataPath","f","originalFlightRouterState","fillInFallbackFlightRouterState","m","G","S","flightRouterState","index","fillInFallbackFlightRouterStateImpl","pathnamePartsIndex","originalSegment","newSegment","doesAppearInURL","paramName","childPathnamePartsIndex","newChildren","childFlightRouterState","newState","flightSegmentPath","flightData","isHmrRefresh","stripClientOnlyDataFromFlightRouterState","_url","refreshMarker","isRootLayout","hasLoadingBoundary","cleanedSegment","stripSearchParamsFromPageSegment","cleanedParallelRoutes","childState","shouldPreserveRefreshMarker","getAppBuildId","setAppBuildId","globalBuildId","buildId","djb2Hash","hexHash","str","char","charCodeAt","computeCacheBustingSearchParam","prefetchHeader","segmentPrefetchHeader","stateTreeHeader","nextUrlHeader","setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","uniqueCacheKey","existingSearch","rawQuery","pairs","pair","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","createFromFetch","createFromFetchBrowser","createDebugChannel","__NEXT_REACT_DEBUG_CHANNEL","doMpaNavigation","abortController","prefetchKind","AUTO","TEMPORARY","isLegacyPPR","__NEXT_PPR","__NEXT_CACHE_COMPONENTS","shouldImmediatelyDecode","responseUrl","redirected","contentType","interception","postponed","staleTimeHeaderSeconds","staleTime","isFlightResponse","ok","body","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightResponsePromise","flightResponse","flightStream","createUnclosingPrefetchStream","normalizedFlightData","couldBeIntercepted","prerendered","__NEXT_TEST_MODE","self","__next_r","crypto","getRandomValues","Uint32Array","fetchOptions","credentials","fetchUrl","fetchPromise","fetch","createFromNextFetch","browserResponse","__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS","MAX_REDIRECTS","n","rscResponse","requestHeaders","debugChannel","promiseForResponse","originalFlightStream","reader","getReader","ReadableStream","pull","done","read","enqueue","createTupleMap","rootEntry","parent","hasValue","lastAccessedEntry","lastAccessedKeys","getOrCreateEntry","existingEntry","newEntry","getEntryIfExists","deleteEntry","deletedEntry","parentMap","createLRU","maxLruSize","onEviction","didScheduleCleanup","lruSize","put","next","ensureCleanupIsScheduled","tail","updateSize","newNodeSize","prevNodeSize","deleteNode","deleted","requestCleanupCallback","ninetyPercentMax","requestIdleCallback","ensureLeadingSlash","normalizeAppPath","normalizeRscURL","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","interceptingRoute","marker","interceptedRoute","concat","splitInterceptingRoute","computeChangedPath","extractPathFromFlightRouterState","getSelectedParams","removeLeadingSlash","segmentToPathname","normalizeSegments","acc","some","childrenPath","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","currentTree","parallelRoute","isDynamicParameter","handleMutable","isNotUndefined","mutable","shouldScroll","previousNextUrl","patchedTree","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","segmentPaths","cache","collectedDebugInfo","DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","generateSegmentsFromPatch","handleExternalUrl","navigateReducer","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","flightRouterPatch","childSegment","handleNavigationResult","tag","NavigationResultTag","MPA","newUrl","data","NoOp","newCanonicalUrl","oldUrl","Success","cacheNode","Async","asyncResult","isExternalUrl","navigateType","getElementById","currentUrl","navigateUsingSegmentCache","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","truncated","originalHtml","partialHtmlDocument","EntryStatus","canNewFetchStrategyProvideMoreContent","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","getSegmentKeypath","pingInvalidationListeners","readExactRouteCacheEntry","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","requestOptimisticRouteCacheEntry","resetRevalidatingSegmentEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","isOutputExportMode","getStaleTimeMs","staleTimeSeconds","max","routeCacheMap","maxRouteLruSize","routeCacheLru","onRouteLRUEviction","segmentCacheMap","maxSegmentLruSize","segmentCacheLru","onSegmentLRUEviction","invalidationListeners","currentCacheVersion","startRevalidationCooldown","pingVisibleLinks","attachInvalidationListener","task","onInvalidate","add","notifyInvalidationListener","reportError","tasks","isPrefetchTaskDirty","now","keypath","staleAt","deleteRouteFromCache","nonInterceptedEntry","fetchStrategy","isDynamic","FetchStrategy","Full","PPRRuntime","isPPREnabled","readExactSegmentCacheEntry","entryWithSearchParams","entryWithoutSearchParams","revalidatingEntry","revalidating","upsertedEntry","deleteSegmentFromCache","readRevalidatingSegmentCacheEntry","owner","existingRevalidation","clearRevalidatingSegmentFromOwner","pendingEntry","promiseWithResolvers","blockedTasks","Infinity","TODO_metadataStatus","TODO_isHeadDynamic","requestedUrl","requestedSearch","urlWithoutSearchParams","routeWithNoSearchParams","createPrefetchRequestKey","canonicalUrlForRouteWithNoSearchParams","optimisticCanonicalSearch","optimisticRenderedSearch","optimisticUrl","optimisticCanonicalUrl","optimisticEntry","prevEntry","candidateEntry","isPartial","rejectedEntry","rsc","emptyEntry","PPR","pingBlockedTasks","cancelEntryListeners","revalidatingSegment","pingPrefetchTask","fulfillRouteCacheEntry","isHeadDynamic","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","rootSegment","convertTreePrefetchToRouteTree","prefetch","requestKey","slots","prefetchSlots","childPrefetch","childParamName","childParamType","childServerSentParamKey","paramKey","childDoesAppearInURL","childParam","childParamValue","childParamKey","childRequestKey","childCacheKey","SegmentHasLoadingBoundary","hasRuntimePrefetch","convertRootFlightRouterStateToRouteTree","convertFlightRouterStateToRouteTree","childRouterState","childTree","SubtreeHasNoLoadingBoundary","routeTree","urlAfterRedirects","htmlResponse","Range","partialHtml","text","Date","fetchPrefetchResponse","addSegmentPathToUrlInOutputExportMode","varyHeader","closed","routeIsPPREnabled","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","serverData","staleTimeMs","writeDynamicTreeResponseIntoCache","LoadingBoundary","currentKeypath","expectedEntry","newKeypath","routeKey","normalizedRequestKey","requestUrl","dynamicRequestTree","spawnedEntries","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","isResponsePartial","writeDynamicRenderResponseIntoCache","normalizedFlightDataResult","flightDatas","writeSeedDataIntoCache","entriesOwnedByCurrentTask","ownedEntry","possiblyNewEntry","flightRouterStateChildren","seedDataChildren","childSeedData","onStreamClose","totalByteLength","byteLength","staticUrl","routeDir","staticExportFilename","currentStrategy","newStrategy","cancelPrefetchTask","reschedulePrefetchTask","schedulePrefetchTask","scheduleMicrotask","queueMicrotask","taskHeap","inProgressRequests","sortIdCounter","didScheduleMicrotask","mostRecentlyHoveredLink","REVALIDATION_COOLDOWN_MS","revalidationCooldownTimeoutHandle","clearTimeout","ensureWorkIsScheduled","treeAtTimeOfPrefetch","cacheVersion","phase","hasBackgroundWork","spawnedRuntimePrefetches","sortId","isCanceled","_heapIndex","trackMostRecentlyHoveredLink","heapPush","heapDelete","PrefetchPriority","Intent","heapResift","Background","Default","processQueueInMicrotask","hasNetworkBandwidth","spawnPrefetchSubtask","prefetchSubtask","onPrefetchConnectionClosed","heapPeek","exitStatus","pingRoute","heapPop","background","pingRootRouteTree","keyWithoutSearch","routeWithoutSearch","Empty","Pending","Fulfilled","Rejected","pingSharedPartOfCacheComponentsTree","requestTree","pingRuntimePrefetches","needsDynamicRequest","diffRouteTreeAgainstCurrent","oldTree","newTree","pingStaticSegmentData","oldTreeChildren","newTreeChildren","newTreeChild","newTreeChildSegment","oldTreeChild","oldTreeChildSegment","childExitStatus","doesCurrentSegmentMatchCachedSegment","pingNewPartOfCacheComponentsTree","requestTreeChildren","requestTreeChild","subtreeHasLoadingBoundary","pingPPRDisabledRouteTreeUpToLoadingBoundary","pingRouteTreeAndIncludeDynamicData","refetchMarkerContext","refetchMarker","segmentHasLoadingBoundary","isInsideRefetchingParent","spawnedSegment","pingFullSegmentRevalidation","pingPPRSegmentRevalidation","currentSegment","upsertSegmentOnCompletion","pendingSegment","nonEmptyRevalidatingSegment","emptySegment","noop","fulfilled","cachedSegment","compareQueuePriority","priorityDiff","phaseDiff","heap","heapSiftUp","pop","heapSiftDown","parentIndex","halfLength","leftIndex","rightIndex","createRouterCacheKey","withoutSearchParameters","isNavigatingToNewRootLayout","nextTree","currentTreeSegment","nextTreeSegment","currentTreeChild","nextTreeChild","abortTask","listenForDynamicRequest","startPPRNavigation","updateCacheNodeOnPopstateRestoration","MPA_NAVIGATION_TASK","navigatedAt","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","prefetchParallelRoutes","patchedRouterStateChildren","taskChildren","dynamicRequestTreeChildren","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","prefetchDataChild","newSegmentChild","newSegmentPathChild","newSegmentKeyChild","oldSegmentChild","oldCacheNodeChild","taskChild","reuseActiveSegmentInDefaultSlot","beginRenderingNewRouteTree","newCacheNodeChild","newSegmentMapChild","taskChildRoute","dynamicRequestTreeChild","newCacheNode","lazyData","prefetchRsc","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","createCacheNodeOnNavigation","routerState","routerStateChildren","isLeafSegment","cacheNodeNavigatedAt","isPrefetchRscPartial","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","routerStateChild","existingSegmentMapChild","segmentChild","segmentPathChild","segmentKeyChild","existingCacheNodeChild","baseRouterState","clone","newTask","createPendingCacheNode","reusedRouterState","oldRefreshMarker","responsePromise","serverRouterState","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","rootTask","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","maybePrefetchRsc","createDeferredRsc","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","dynamicLoading","newParallelRoutes","shouldUsePrefetch","DEFERRED","pendingRsc","responseDebugInfo","fulfilledRsc","rejectedRsc","navigate","currentCacheNode","currentFlightRouterState","accumulation","snapshot","readRenderSnapshotFromCache","prefetchFlightRouterState","prefetchSeedData","navigateUsingPrefetchedRouteTree","optimisticRoute","newRenderedSearch","navigateDynamicallyWithNoPrefetch","promiseForDynamicServerResponse","navigationTaskToResult","childRouterStates","childSeedDatas","childResult","segmentEntry","promiseForFulfilledEntry","debugInfoFromResponse","simulatePrefetchTreeUsingDynamicTreePatch","hasDynamicHoles","baseTree","treePatch","canMutateInPlace","simulatePrefetchTreeUsingDynamicTreePatchImpl","patch","updatedParallelRouteKey","baseChildren","childBaseRouterState","notEnabled","__NEXT_CLIENT_SEGMENT_CACHE","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","setOptimisticLinkStatus","prefetchable","prefetchableAndVisible","observer","IntersectionObserver","handleIntersect","rootMargin","observeVisibility","instance","existingInstance","coercePrefetchableUrl","reportErrorFn","prefetchEnabled","prefetchURL","isVisible","prefetchTask","prefetchHref","unobserve","intersectionRatio","rescheduleLinkPrefetch","unstable_upgradeToDynamicPrefetch","__NEXT_DYNAMIC_ON_HOVER","existingPrefetchTask","prefetchWithOldCacheImplementation","getCurrentAppRouterState","appRouterState","scheduleSegmentPrefetchTask","doPrefetch","FULL","pathHasPrefix","hasBasePath","isLocalURL","locationOrigin","resolved","errorOnce","errors","msg","LinkComponent","useLinkStatus","isModifiedEvent","eventTarget","metaKey","ctrlKey","shiftKey","altKey","which","linkClicked","linkInstanceRef","scroll","onNavigate","nodeName","isAnchorNodeName","toUpperCase","hasAttribute","dispatchNavigateAction","formatStringOrUrl","urlObjOrString","linkStatus","useOptimistic","hrefProp","asProp","childrenProp","prefetchProp","passHref","shallow","onClick","onMouseEnter","onMouseEnterProp","onTouchStart","onTouchStartProp","legacyBehavior","unstable_dynamicOnHover","restProps","getFetchStrategyFromPrefetchProp","createPropError","expected","actual","requiredPropsGuard","requiredProps","optionalPropsGuard","optionalProps","valType","locale","hasDynamicSegment","resolvedHref","child","Children","only","childRef","observeLinkVisibilityOnMount","mergedRef","childProps","defaultPrevented","upgradeToDynamicPrefetch","__NEXT_LINK_NO_TOUCH_START","cloneElement","LinkStatusContext","Provider","createContext"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97]}