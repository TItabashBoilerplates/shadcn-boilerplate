# Supabase Realtime 認証

Realtime の Broadcast / Presence に対するアクセス制御。

---

## Private Channel の使用

本番環境では `private: true` を設定してRLSで保護：

```typescript
const channel = supabase.channel('room:123:messages', {
  config: { private: true }  // RLS を有効化
})

channel
  .on('broadcast', { event: 'message' }, (payload) => {
    console.log('New message:', payload)
  })
  .subscribe((status, err) => {
    if (status === 'SUBSCRIBED') {
      console.log('Connected!')
    } else {
      console.error(err)
    }
  })
```

### 注意

- `private: true` を設定しないとチャンネルは公開される
- Dashboard で「Allow public access」を無効にする必要あり

---

## realtime.messages テーブルへの RLS

`realtime.messages` テーブルにRLSポリシーを設定してアクセス制御：

### ヘルパー関数

| 関数 | 説明 |
|-----|------|
| `realtime.topic()` | ユーザーが接続しようとしているチャンネルトピックを返す |

### extension 値

| 値 | 機能 |
|---|------|
| `broadcast` | Broadcast メッセージ |
| `presence` | Presence メッセージ |

---

## RLS ポリシーパターン

### 前提: リレーションテーブル

```sql
-- ルーム
create table public.rooms (
  id bigint generated by default as identity primary key,
  topic text not null unique
);
alter table public.rooms enable row level security;

-- ルーム参加者
create table public.rooms_users (
  user_id uuid references auth.users (id),
  room_topic text references public.rooms (topic),
  created_at timestamptz default current_timestamp,
  primary key (user_id, room_topic)
);
alter table public.rooms_users enable row level security;
```

### Broadcast 受信許可

```sql
create policy "Users can receive broadcast"
on realtime.messages
for select
to authenticated
using (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast')
  )
);
```

### Broadcast 送信許可

```sql
create policy "Users can send broadcast"
on realtime.messages
for insert
to authenticated
with check (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast')
  )
);
```

### Presence 受信許可

```sql
create policy "Users can listen to presence"
on realtime.messages
for select
to authenticated
using (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('presence')
  )
);
```

### Presence 送信（track）許可

```sql
create policy "Users can track presence"
on realtime.messages
for insert
to authenticated
with check (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('presence')
  )
);
```

### Broadcast + Presence 両方許可

```sql
-- 受信
create policy "Users can listen to broadcast and presence"
on realtime.messages
for select
to authenticated
using (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast', 'presence')
  )
);

-- 送信
create policy "Users can send broadcast and presence"
on realtime.messages
for insert
to authenticated
with check (
  exists (
    select 1 from public.rooms_users
    where user_id = (select auth.uid())
      and room_topic = (select realtime.topic())
      and realtime.messages.extension in ('broadcast', 'presence')
  )
);
```

---

## トピック命名規則

チャンネルトピックには明確な命名規則を使用：

```
{scope}:{id}:{entity}
```

### 例

| トピック | 用途 |
|---------|------|
| `room:123:messages` | ルーム123のメッセージ |
| `game:456:moves` | ゲーム456の手 |
| `user:789:notifications` | ユーザー789の通知 |
| `project:abc:updates` | プロジェクトabcの更新 |

### RLS での活用

```sql
-- トピックからルームIDを抽出
create policy "Room members only"
on realtime.messages for select
to authenticated
using (
  exists (
    select 1 from public.rooms_users ru
    join public.rooms r on ru.room_topic = r.topic
    where ru.user_id = (select auth.uid())
      and r.topic = (select realtime.topic())
  )
);
```

---

## Postgres Changes との違い

| 機能 | 制御方法 | `private: true` |
|-----|---------|----------------|
| **Broadcast** | `realtime.messages` RLS | 必要 |
| **Presence** | `realtime.messages` RLS | 必要 |
| **Postgres Changes** | テーブルの RLS | 適用されない |

### Postgres Changes の認証

```typescript
// Postgres Changes は private オプションに関係なく、
// テーブルの RLS ポリシーで制御される
const channel = supabase
  .channel('schema-db-changes')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'messages',
      filter: `room_id=eq.${roomId}`,
    },
    (payload) => console.log(payload)
  )
  .subscribe()
```

テーブルに RLS が設定されていれば、ユーザーが閲覧できるレコードの変更のみが配信される。

---

## 実装例

### チャットルーム

```typescript
'use client'
import { useEffect, useState } from 'react'
import { createClient } from '@workspace/client-supabase/client'

export function ChatRoom({ roomTopic }: { roomTopic: string }) {
  const [messages, setMessages] = useState<Message[]>([])
  const [presenceState, setPresenceState] = useState<Record<string, unknown>>({})
  const supabase = createClient()

  useEffect(() => {
    const channel = supabase.channel(roomTopic, {
      config: { private: true }  // RLS 有効化
    })

    // Broadcast: メッセージ受信
    channel.on('broadcast', { event: 'message' }, ({ payload }) => {
      setMessages(prev => [...prev, payload])
    })

    // Presence: オンライン状態
    channel.on('presence', { event: 'sync' }, () => {
      setPresenceState(channel.presenceState())
    })

    channel.subscribe(async (status) => {
      if (status === 'SUBSCRIBED') {
        // Presence: 自分の状態を track
        await channel.track({
          user_id: (await supabase.auth.getUser()).data.user?.id,
          online_at: new Date().toISOString(),
        })
      }
    })

    return () => {
      channel.unsubscribe()
    }
  }, [roomTopic])

  const sendMessage = async (text: string) => {
    const channel = supabase.channel(roomTopic)
    await channel.send({
      type: 'broadcast',
      event: 'message',
      payload: { text, timestamp: Date.now() },
    })
  }

  return (/* UI */)
}
```

### クリーンアップの重要性

```typescript
// React での適切なクリーンアップ
useEffect(() => {
  const channel = supabase.channel('room:123')

  // ... 設定 ...

  channel.subscribe()

  return () => {
    // 必ずクリーンアップ
    supabase.removeChannel(channel)
  }
}, [])
```

---

## パフォーマンス考慮事項

### Presence の使用を最小化

Presence は CRDT を使用して状態を同期するため、計算コストが高い：

```typescript
// ❌ 高頻度の更新
channel.track({ x: mouseX, y: mouseY })  // マウス移動ごと

// ✅ スロットリング
const throttledTrack = throttle((pos) => {
  channel.track(pos)
}, 100)  // 100ms ごと
```

### RLS の複雑さに注意

RLS ポリシーが複雑だと接続時間が増加：

```sql
-- ✅ シンプルなポリシー
using ( room_topic = (select realtime.topic()) )

-- ❌ 複雑なジョイン（接続遅延の原因）
using (
  exists (
    select 1 from a
    join b on a.id = b.a_id
    join c on b.id = c.b_id
    where ...
  )
)
```

---

## 参照

- [Realtime Authorization](https://supabase.com/docs/guides/realtime/authorization)
- [Realtime Concepts](https://supabase.com/docs/guides/realtime/concepts)
- [Broadcast](https://supabase.com/docs/guides/realtime/broadcast)
- [Presence](https://supabase.com/docs/guides/realtime/presence)
